<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ARMv8-aarch64寄存器和指令集]]></title>
    <url>%2Fpost%2F7190.html</url>
    <content type="text"><![CDATA[ARMv8-A处理器属性 Rockchip RK3399 SoC integrates dual-core Cortex-A72 and quad-core Cortex-A53 with separate NEON coprocessor, and with ARM Mali-T864 GPU. 异常等级软件运行异常级别： EL0： 普通用户应用程序 EL1： 操作系统内核通常被描述为特权 EL2： 管理程序 EL3： 低级固件，包括安全监视器 ARMv8寄存器AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫Xn，运行在32位的时候就叫Wn. 32位W寄存器构成相应64位X寄存器的下半部分。 也就是说，W0映射到X0的低位字，W1映射到X1的低位字。 特殊寄存器 Name Size Description WZR 32bits Zero register XZR 64bits Zero register WSP 32bits Current stack pointer SP 64bits Current stack pointer pC 64bits Program counter ARM 64位架构的ABIARM体系结构的应用程序二进制接口（ABI， Application Binary Interface）指定了基本规则所有可执行的本机代码模块必须遵守，以便它们可以正常工作。 通用寄存器通用寄存器分为4组： 参数寄存器（X0-X7）： 用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值，调用其他函数之间的值（8个寄存器可用于传递参数） 来电保存的临时寄存器（X9-X15）： 如果调用者要求在任何这些寄存器中保留值调用另一个函数，调用者必须将受影响的寄存器保存在自己的堆栈中帧。 它们可以通过被调用的子程序进行修改，而无需保存并在返回调用者之前恢复它们。 被调用者保存的寄存器（X19-X29）： 这些寄存器保存在被调用者帧中。 它们可以被被调用者修改子程序，只要它们在返回之前保存并恢复。 特殊用途寄存器（X8，X16-X18，X29，X30）： X8： 是间接结果寄存器。 用于传递地址的位置间接结果 X16和X17： 程序内调用临时寄存器 X18： 平台寄存器，保留用于平台ABI X29： 帧指针寄存器（FP） X30： 链接寄存器（LR） NEON和浮点寄存器 A64指令集A64特点 移除了批量加载寄存器指令 LDM/STM, PUSH/POP, 使用STP/LDP 一对加载寄存器指令代替； 没有提供访问CPSR的单一寄存器，但是提供访问PSTATE的状态域寄存器； A64没有协处理器的概念，没有协处理器指令MCR,MRC； 相比A32少了很多条件执行指令，只有条件跳转和少数数据处理这类指令才有条件执行.附件为条件指令码； 指令格式1&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; &#123;,&lt;Opcode2&gt;&#125; Opcode：操作码，也就是助记符，说明指令需要执行的操作类型 Cond：指令执行条件码，查看附件图； S：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值 Rd/Xt：目标寄存器，A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30； Rn/Xn：第一个操作数的寄存器，和Rd一样，不同指令有不同要求； Opcode2：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）； 内存访问指令 加载指令1LDR Rt, &lt;addr&gt; LDRB (8-bit, zero extended). LDRSB (8-bit, sign extended). LDRH (16-bit, zero extended). LDRSH (16-bit, sign extended). LDRSW (32-bit, sign extended). 存储指令1STR Rn, &lt;addr&gt; 参考 Programmer’s Guide for ARMv8-A]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化---指令预取]]></title>
    <url>%2Fpost%2F35506.html</url>
    <content type="text"><![CDATA[指令预取: 是指提前将所需要的数据取出来，在使用时可用。 具体方法就是在不命中时，当数据从主存储器中取出送往CPU的同时，把主存储器相邻几个单元中的数据（称为一个数据块）都取出来送入Cache中。 CPU在cache不命中的情况下，将从内存读取一个连续的cacheline大小数据。 如果访问数据地址连续，CPU产生Cache不命中的情况少，省时 如果访问数据地址不连续，CPU产生的Cache不命中的情况多，耗时 示例–矩阵乘法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#if __aarch64__ #define nop asm("nop")#else #define nop#endifint main(int argc, const char *argv[])&#123; unsigned long i, j, k; int N = 700; int res[N][N], mul1[N][N], mul2[N][N]; clock_t start, end; long time1 = 0, time2 = 0; for (i = 0; i &lt; N; ++i) &#123; for (j = 0; j &lt; N; ++j) &#123; mul1[i][j] = (i + 1) * j; mul2[i][j] = i * j; &#125; &#125; start = clock(); /* mul2的地址空间不是连续的 * 初始化时mul2[0][x], 一行一行赋值，地址连续 * 执行读取mul2[x][0], 一列一列读取，地址不连续*/ nop;nop;nop; for (i = 0; i &lt; N; ++i) &#123; for (j = 0; j &lt; N; ++j) &#123; for (k = 0; k &lt; N; ++k) &#123; // 行 x 列 res[i][j] += mul1[i][k] * mul2[k][j]; &#125; &#125; &#125; nop;nop;nop; end = clock(); time1 = end - start; printf("Run Time1 %f s\n", (double)time1 / CLOCKS_PER_SEC); int tmp[N][N]; for (i = 0; i &lt; N; ++i) &#123; for (j = 0; j &lt; N; ++j) &#123; mul1[i][j] = (i + 1) * j; mul2[i][j] = i * j; &#125; &#125; start = clock(); // 矩阵转换，列变换（列变行） for (i = 0; i &lt; N; ++i) &#123; for (j = 0; j &lt; N; ++j) &#123; tmp[i][j] = mul2[j][i]; &#125; &#125; /* CPU读取连续的tmp地址时，使用指令预取（硬件） * DCache 命中效率*/ nop;nop;nop; for (i = 0; i &lt; N; ++i) &#123; for (j = 0; j &lt; N; ++j) &#123; for (k = 0; k &lt; N; ++k) &#123; res[i][j] += mul1[i][k] * tmp[j][k]; &#125; &#125; &#125; nop;nop;nop; end = clock(); time2 = end - start; printf("Run Time2 %f s\n", (double)time2 / CLOCKS_PER_SEC); printf("Time2 and Time1 upgrade %f %\n", (double)(time1 - time2) / time1 * 100); return 0;&#125; 结果–arm平台 1234[shell@localhost:/]$ ./prefetchRun Time1 5.966075 sRun Time2 4.530201 sTime2 and Time1 upgrade 24.067314 % 代码运行速度提升24% 结论 Cache命中率 乘法运算与赋值运算的效率]]></content>
      <categories>
        <category>程序设计</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据压缩算法---霍夫曼编码（Huffman）]]></title>
    <url>%2Fpost%2F3506.html</url>
    <content type="text"><![CDATA[霍夫曼编码是一种基于最小冗余编码的压缩算法。最小冗余编码是指，如果知道一组数据中符号出现的频率，就可以用一种特殊的方式来表示符号从而减少数据需要的存储空间。 用较少的位对出现频率高的符号编码 用较多的位对出现频率低的符号编码 一个符号不一定必须是文本字符，它可以是任何大小的数据，但往往它只占一个字节。 Huffman Coding：译为哈夫曼编码、赫夫曼编码、霍夫曼编码。 是可变字长编码(VLC)的一种。用于无损数据压缩的熵编码（权编码）算法，是一种通过字符出现频率，根据二叉树实现。 编码示例编码字符统计 符号 概率 每个实例的熵 U 12/72 2.584 963 V 18/72 2.000 000 W 7/72 3.362 570 X 15/72 2.263 034 Y 20/72 1.847 997 熵和最小冗余每个数据集都有一定的信息量，这就是所谓的熵。一组数据的熵是数据中每个符号熵的总和1Sz = -lg2 Pz Pz 就数据集中z出现的频率 1Su = -lg2(12/72) = 2.584 963位 72个字符的字符串中，U字符最少可以使用3位表示（四舍五入） 构造霍夫曼树 出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长 用霍夫曼树压缩数据，给定一个具体的符号，从树的根开始，然后沿着树的叶向叶子结点追踪。在向下追踪的过程中. 当向左分支移动时，向当前编码的末尾追加0； 当向右分支移动时，向当前编码的末尾追加1 编码表 字符 编码 U ‘101’ V ‘01’ W ‘100’ X ‘00’ Y ‘11’ 编码效率 不压缩数据大小：72*8=576bit 压缩后数据大小：123+182+73+152+20*2=163bit 压缩比：1 - 163/576 = 71.7% 在通常情况下，霍夫曼编码并不是最高效的压缩方法，但它压缩和解压缩的速度非常快。 一般来说，造成霍夫曼编码比较耗时的原因是它需要扫描两次数据：一次用来计算频率；另一次才是用来压缩数据。 而解压缩数据非常高效，因为解码每个符号的序列只需要扫描一次霍夫曼树。 参考 霍夫曼编码压缩算法]]></content>
      <categories>
        <category>多媒体</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>Huffman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H264码流格式]]></title>
    <url>%2Fpost%2F35564.html</url>
    <content type="text"><![CDATA[H264的两种码流格式，它们分别为：字节流格式和RTP包格式。 字节流格式: 默认的输出格式。它的基本数据单位为NAL单元，也即NALU。为了从字节流中提取出NALU，协议规定，在每个NALU的前面加上起始码：0x000001或0x00000001（0x代表十六进制） RTP包格式: 一种数据传输格式,主要用于网络传送 字节流格式,由于它没有经过传输协议封装，所以也可以称之为裸流 1H264比特流 = Start_Code_Prefix + NALU + Start_Code_Prefix + NALU + ... 起始码与NALU 起始码（Start_Code_Prefix）: 0x00 00 01或0x00 00 00 01 在两个起始码之间的数据，称为NALU NALU NAL Unit: Network Abstract Layer Unit 每个NAL单元包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组对应于视频编码的NAL头信息 1NALU = NALU Header + RBSP SODB:(String of Data Bits)最原始的编码数据，无任何附加数据。 RBSP:在SODB的基础上增加了rbsp_stop_ont_bit(bit值为1)并用0按字节补位对齐。 EBSP:(Encapsulation Byte Sequence Packets)在RBSP的基础上增加了防止伪起始码字节(0x03)。 NALU Header12NAL Header： forbidden_bit， nal_reference_bit（优先级）， nal_unit_type（类型） 1bit 2bit 5bit Slice一个视频图像可编码成一个或更多个条带，每个条带包含整数个宏块（MB），即每个条带至少一个MB，最多时每个条带包含整个图像的宏块。总之，一幅图像中每个条带的宏块数不一定固定。设条带的目的是为了限制误码的扩散和传输，应使编码条带相互间是独立的。某个条带的预测不能以其它条带中的宏块为参考图像，这样某一条带中的预测误差才不会传播到其它条带中去。 参考 H.264的Slice及Slice类型]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>H264</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下GBK文件编码批量转换UTF-8]]></title>
    <url>%2Fpost%2F38869.html</url>
    <content type="text"><![CDATA[Windows默认是GBK编码格式，Linux默认是UTF-8的格式，不同格式之间的乱码处理。 1enca -L zh_CN -x UTF-8 *.c enca – 文件编码123$enca -hUsage: enca [-L LANGUAGE] [OPTION]... [FILE]... enconv [-L LANGUAGE] [OPTION]... [FILE]... 用法：123$ enca -L zh_CN file 检查文件的编码$ enca -L zh_CN -x UTF-8 file 将文件编码转换为"UTF-8"编码$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样 convmv – 文件名编码1$ convmv -f 源编码 -t 新编码 [选项] 文件名 -r 递归处理子文件夹 –notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。 –list 显示所有支持的编码 –unescap 可以做一下转义，比如把%20变成空格 示例：1$ convmv -f GBK -t UTF-8 --notest utf8 filename 1$ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 &#123;&#125; -o utf/&#123;&#125; \; 批量处理]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统应用层的内存申请--memory]]></title>
    <url>%2Fpost%2F9412.html</url>
    <content type="text"><![CDATA[在linux系统编程中常见的内存申请方式和其特性，malloc，calloc, realloc malloc1extern void *malloc(unsigned int num_bytes); 功能： 分配长度为num_bytes字节的内存块 返回值： 如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。 函数的工作机制 malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。 调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。 Linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。 calloc1void *calloc(unsigned n,unsigned size)； 功能： 在内存的动态存储区中分配n个长度为size的内存空间，并初始化为0 返回值： 函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。 malloc的区别1234567891011121314151617#include "ansidecl.h"#include &lt;stddef.h&gt;/* For systems with larger pointers than ints, this must be declared. */PTR malloc (size_t);void bzero (PTR, size_t);PTRcalloc (size_t nelem, size_t elsize)&#123; register PTR ptr; if (nelem == 0 || elsize == 0) nelem = elsize = 1; ptr = malloc (nelem * elsize); if (ptr) bzero (ptr, nelem * elsize); return ptr;&#125; https://code.woboq.org/gcc/libiberty/calloc.c.html 只多做了初始化清零的操作bzero realloc1extern void *realloc(void *mem_address, unsigned int newsize); 功能： 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。 返回值： 如果重新分配成功则返回指向被分配内存的指针，否则返回空指针NULL 注意：这里原始内存中的数据还是保持不变的。当内存不再使用时，应使用free()函数将内存块释放。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux性能测试工具---Lmbench]]></title>
    <url>%2Fpost%2F54953.html</url>
    <content type="text"><![CDATA[Lmbench是一套简易，可移植的，符合ANSI/C标准为UNIX/POSIX而制定的微型测评工具。一般来说，它衡量两个关键特征：反应时间和带宽。Lmbench旨在使系统开发者深入了解关键操作的基础成本。 测试包括文档读写、内存操作、进程创建销毁开销、网络等性能，测试方法简单 Lmbench: http://www.bitmover.com/lmbench 带宽测评(bw_*) &lt;命令&gt; 反应时间测评（lat_*） &lt;命令&gt; 读取缓存文件 bw_file_rd 上下文切换 - 拷贝内存 bw_mem 1M cp 网络： 连接的建立，管道，TCP，UDP和RPC hot potato - 读内存 bw_mem 1M rd 文件系统的建立和删除 - 写内存 bw_mem 1M wr 进程创建 - 管道 bw_pipe 信号处理 - TCP bw_tcp 上层的系统调用 - - - 内存读入反应时间 lat_mem_rd man获取详细信息 移植方便可在buildroot配置 mhz计算处理时钟 12# mhz1290 MHz, 0.7752 nanosec clock tlb获取TLB大小 12# tlbtlb: 10 pages lineCache line大小 12# line64 stream测试内存带宽 123456789# streamSTREAM copy latency: 4.98 nanosecondsSTREAM copy bandwidth: 3213.50 MB/secSTREAM scale latency: 6.71 nanosecondsSTREAM scale bandwidth: 2385.57 MB/secSTREAM add latency: 10.64 nanosecondsSTREAM add bandwidth: 2256.06 MB/secSTREAM triad latency: 12.45 nanosecondsSTREAM triad bandwidth: 1927.25 MB/sec lmdd移动io进行性能和调试测试 12345# time lmdd if=/dev/urandom of=/tmp/xxx bs=1M count=1010.0000 MB in 1.7651 secs, 5.6653 MB/sec #速度real 0m 1.77suser 0m 0.00ssys 0m 1.77s 测试示例拷贝内存12# bw_mem 500M cp500.00 858.05 #500M测试数据，拷贝速度858.05MB/s 内存写入反应时间1234567# lat_mem_rd 1M"stride=64 #步长，0.00049 2.343 #写入大小，反应时间纳秒（ns）0.00098 2.3430.00195 2.3430.00293 2.343^C]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Lmbench</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[proc文件系统解析--进程]]></title>
    <url>%2Fpost%2F30680.html</url>
    <content type="text"><![CDATA[Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 所有说明均可通过man proc获取 系统环境：arm64bit， Linux4.4.70 进程 测试进程1234# ps...570 root 2728 S top... 1234567891011121314151617181920212223242526272829303132333435363738394041424344#ls -ls 0 dr-xr-xr-x 2 root root 0 Jan 1 04:14 attr 0 -r-------- 1 root root 0 Jan 1 04:14 auxv 0 -r--r--r-- 1 root root 0 Jan 1 04:14 cgroup 0 --w------- 1 root root 0 Jan 1 04:14 clear_refs 0 -r--r--r-- 1 root root 0 Jan 1 03:31 cmdline 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 comm 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 coredump_filter 0 -r--r--r-- 1 root root 0 Jan 1 04:14 cpuset 0 lrwxrwxrwx 1 root root 0 Jan 1 04:14 cwd -&gt; /proc 0 -r-------- 1 root root 0 Jan 1 04:14 environ 0 lrwxrwxrwx 1 root root 0 Jan 1 04:14 exe -&gt; /bin/busybox 0 dr-x------ 2 root root 0 Jan 1 04:14 fd 0 dr-x------ 2 root root 0 Jan 1 04:14 fdinfo 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 gid_map 0 -r--r--r-- 1 root root 0 Jan 1 04:14 limits 0 dr-x------ 2 root root 0 Jan 1 04:14 map_files 0 -r--r--r-- 1 root root 0 Jan 1 04:14 maps 0 -rw------- 1 root root 0 Jan 1 04:14 mem 0 -r--r--r-- 1 root root 0 Jan 1 04:14 mountinfo 0 -r--r--r-- 1 root root 0 Jan 1 04:14 mounts 0 -r-------- 1 root root 0 Jan 1 04:14 mountstats 0 dr-xr-xr-x 10 root root 0 Jan 1 04:14 net 0 dr-x--x--x 2 root root 0 Jan 1 04:14 ns 0 -r-------- 1 root root 0 Jan 1 04:14 oom_adj 0 -r--r--r-- 1 root root 0 Jan 1 04:14 oom_score 0 -r-------- 1 root root 0 Jan 1 04:14 oom_score_adj 0 -r-------- 1 root root 0 Jan 1 04:14 pagemap 0 -r-------- 1 root root 0 Jan 1 04:14 personality 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 projid_map 0 lrwxrwxrwx 1 root root 0 Jan 1 04:14 root -&gt; / 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 sched 0 -r--r--r-- 1 root root 0 Jan 1 04:14 schedstat 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 setgroups 0 -r--r--r-- 1 root root 0 Jan 1 04:14 smaps 0 -r-------- 1 root root 0 Jan 1 04:14 stack 0 -r--r--r-- 1 root root 0 Jan 1 03:31 stat 0 -r--r--r-- 1 root root 0 Jan 1 04:14 statm 0 -r--r--r-- 1 root root 0 Jan 1 04:14 status 0 -r-------- 1 root root 0 Jan 1 04:14 syscall 0 dr-xr-xr-x 3 root root 0 Jan 1 04:14 task 0 -rw-rw-rw- 1 root root 0 Jan 1 04:14 timerslack_ns 0 -rw-r--r-- 1 root root 0 Jan 1 04:14 uid_map 0 -r--r--r-- 1 root root 0 Jan 1 04:14 wchan 进程目录123456789101112# ls /proc/570/attr fd ns smapsauxv fdinfo oom_adj stackcgroup gid_map oom_score statclear_refs limits oom_score_adj statmcmdline map_files pagemap statuscomm maps personality syscallcoredump_filter mem projid_map taskcpuset mountinfo root timerslack_nscwd mounts sched uid_mapenviron mountstats schedstat wchanexe net setgroups 选项 说明 cmdline 启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息 cwd 指向当前进程运行目录的一个符号链接 exe 指向启动当前进程的可执行文件（完整路径）的符号链接 fd 指向启动当前进程的可执行文件（完整路径）的符号链接 limits 当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取； maps 当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表； mem 当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取； root 指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录； stat 当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用； statm 当前进程占用内存的状态信息，通常以“页面”（page）表示； status 与stat所提供信息类似，但可读性较好 task 包含由当前进程所运行的每一个线程的相关信息，每个线程的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容 /proc/[PID]/stat 包含了所有CPU活跃的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。 12#cat /proc/570/stat570 (top) S 565 570 565 34817 570 4210688 110 0 0 0 209 648 0 0 20 0 1 0 1266675 2793472 111 18446744073709551615 4194304 4867856 548828687344 548828686432 548186418324 0 0 0 58751527 1 0 0 17 3 0 0 0 0 0 4933392 4937189 1042927616 548828688219 548828688223 548828688223 548828688363 0 序号 表示 说明 1 pid=570 进程(包括轻量级进程，即线程)号 2 comm=top 应用程序或命令的名字 3 task_state=R 任务的状态，R:runnign, S:sleeping (TASK_INTERRUPTIBLE), D:disk sleep (TASK_UNINTERRUPTIBLE), T: stopped, T:tracing stop,Z:zombie, X:dead 4 ppid=565 父进程ID 5 pgid=570 线程组ID 6 session=565 该任务所在的会话组ID 7 tty_nr=34817 该任务的tty终端的设备号 8 tpgid=570 终端的进程组号，当前运行在该任务所在终端的前台任务(包括shell 应用程序)的PID。 9 task-&gt;flags=4210688 进程标志位，查看该任务的特性 10 min_flt=110 该任务不需要从硬盘拷数据而发生的缺页（次缺页）的次数 11 cmin_flt=0 累计的该任务的所有的waited-for进程曾经发生的次缺页的次数目 12 maj_flt=0 该任务需要从硬盘拷数据而发生的缺页（主缺页）的次数 13 cmaj_flt=0 累计的该任务的所有的waited-for进程曾经发生的主缺页的次数目 14 utime=209 该任务在用户态运行的时间，单位为jiffies 15 stime=648 该任务在核心态运行的时间，单位为jiffies 16 cutime=0 累计的该任务的所有的waited-for进程曾经在用户态运行的时间，单位为jiffies 17 cstime=0 累计的该任务的所有的waited-for进程曾经在核心态运行的时间，单位为jiffies 18 priority=20 任务的动态优先级 19 nice=0 任务的静态优先级 20 num_threads=1 该任务所在的线程组里线程的个数 21 it_real_value=0 由于计时间隔导致的下一个 SIGALRM 发送进程的时延，以jiffy为单位. 22 start_time=1266675 该任务启动的时间，单位为jiffies 23 vsize=2793472 该任务的虚拟地址空间大小, 单位为page 24 rss=111 该任务当前驻留物理地址空间的大小，单位为page 25 rlim=18446744073709551615 该任务能驻留物理地址空间的最大值. 单位：byte 26 start_code=4194304 该任务在虚拟地址空间的代码段的起始地址 27 end_code=4867856 该任务在虚拟地址空间的代码段的结束地址 28 startstack=548828687344 堆栈的起始地址（即底部） 29 kstkesp=548828686432 esp(堆栈指针) 的当前值, 与在进程的内核堆栈页得到的一致 30 kstkeip=548186418324 指向将要执行的指令的指针, EIP(指令指针)的当前值. 31 signal=0 待处理信号的位图，记录发送给进程的普通信号 32 blocked=0 阻塞信号的位图 33 sigignore=0 忽略的信号的位图 34 sigcatch=58751527 被俘获的信号的位图 35 wchan=1 如果该进程是睡眠状态，该值给出调度的调用点 36 nswap=0 交换的页数（未维护） 37 cnswap=0 子进程的累积nswap（未维护）。 38 exit_signal=17 该进程结束时，向父进程所发送的信号 39 task_cpu(task)=3 运行在哪个CPU上 40 task_rt_priority=0 实时进程的相对优先级别 41 task_policy=0 进程的调度策略，0=非实时进程，1=FIFO实时进程；2=RR实时进程 42 delayacct_blkio_ticks=0 聚合块I/O延迟，以时钟周期（厘秒,百分之一秒）为单位。 43 guest_time=0 - 44 cguest_time=0 - 45 start_data=4933392 放置程序数据和未初始化（BSS）数据的地址。 46 end_data =4937189 - 47 start_brk=1042927616 可以使用brk(2)扩展程序堆的地址。 48 arg_start=548828688219 放置程序命令行参数（argv）的地址。 49 arg_end =548828688223 - 50 env_start=548828688223 放置程序环境变量的地址。 51 env_end =548828688363 - 52 exit_code=0 线程的退出状态采用waitpid(2)报告的形式。]]></content>
      <categories>
        <category>文件系统</category>
        <category>proc</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾2018的点滴]]></title>
    <url>%2Fpost%2F22139.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu查询相关库的情况]]></title>
    <url>%2Fpost%2F31784.html</url>
    <content type="text"><![CDATA[查询一个库的位置 环境: Ubuntu 18.04.1 LTS 测试库名: libmpfr 库的相关描述1$dpkg -l &quot;*库信息*&quot; 示例:1234567$dpkg -l &quot;*libmpfr*&quot;Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name Version Architecture Description+++-========================================-=========================-=========================-======================================================================================ii libmpfr6:amd64 4.0.1-1 amd64 multiple precision floating-point computation 库的位置查询libmpfr的路径 直接查找1$ldconfig -p | grep &quot;库信息&quot; 示例:12$ldconfig -p | grep &quot;libmpfr&quot; libmpfr.so.6 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libmpfr.so.6 间接查找1dpkg -L &quot;库名称&quot; 示例:1234567891011121314151617$dpkg -L &quot;libmpfr6:amd64&quot;/./usr/usr/lib/usr/lib/x86_64-linux-gnu/usr/lib/x86_64-linux-gnu/libmpfr.so.6.0.1/usr/share/usr/share/doc/usr/share/doc/libmpfr6/usr/share/doc/libmpfr6/AUTHORS/usr/share/doc/libmpfr6/BUGS/usr/share/doc/libmpfr6/NEWS.gz/usr/share/doc/libmpfr6/README/usr/share/doc/libmpfr6/TODO.gz/usr/share/doc/libmpfr6/changelog.Debian.gz/usr/share/doc/libmpfr6/copyright/usr/lib/x86_64-linux-gnu/libmpfr.so.6]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下shell基础--软连接处理]]></title>
    <url>%2Fpost%2F55887.html</url>
    <content type="text"><![CDATA[软连接的截取和定位 场景: 当前所执行的脚本是连接,获取其实际的路径(位置) 判断软连接12345#!/bin/bashif [ -h "a.sh" ]; then echo "It's a soft connection"fi -h: 软连接 1234567891011121314151617181920#!/bin/bashPRG=$0ls=`ls -ld "$PRG"` link=`expr "$ls" : '.*-&gt; \(.*\)$'` echo "Current script PRG: $PRG"echo "Soft connection path link: $link"echo "Get the current path: `dirname "$PRG"`"# 判断软连接是否在当前目录下if expr "$link" : '/.*' &gt; /dev/null; then PRG="$link" else PRG="`dirname "$PRG"`/$link" fi echo "Soft connection path link: $link"echo "Actual script path PRG: $PRG" 测试环境: 保存脚本到xx.sh 123456$mkdir -p aa/bb/cc$mv xx.sh aa/bb/cc$ln -s aa/bb/cc/xx.sh xx.sh$ls -ld xx.shlrwxrwxrwx 1 xxx xxx 14 12月 21 16:57 xx.sh -&gt; aa/bb/cc/xx.sh$./xx.sh 执行脚本:123456$./xx.shCurrent script PRG: ./xx.shSoft connection path link: aa/bb/cc/xx.shGet the current path: .Soft connection path link: aa/bb/cc/xx.shActual script path PRG: ./aa/bb/cc/xx.sh]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程状态-Z:僵尸进程产生的原因]]></title>
    <url>%2Fpost%2F5718.html</url>
    <content type="text"><![CDATA[Z (zombie):僵死状态是一个比较特殊的状态。进程在退出的过程中，处于TASK_DEAD状态。 在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。 123456789101112131415# ps PID USER VSZ STAT COMMAND 1 root 3100 S init 2 root 0 SW [kthreadd] 3 root 0 SW [ksoftirqd/0] 4 root 0 SW [kworker/0:0] 5 root 0 SW&lt; [kworker/0:0H] 6 root 0 SW [kworker/u8:0] ... 1380 root 0 Z [view] #僵尸进程 ... 1392 root 3104 S -/bin/sh 1404 root 0 SW&lt; [kworker/2:1H] 1429 root 0 SW&lt; [kworker/0:1H] 1444 root 0 SW&lt; [kworker/1:1H] 僵尸进程产生的原因??? 如何确定根本原因??? 如何避免??? 僵尸进程产生的原因 僵尸进程: 是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源 原因: 子进程被直接杀死 子进程无法正常关闭 场景:主进程创建的线程在进行数据搬运时,搬运数据的大小超过了放置数据buffer的大小,导致部分数据被污染,最终导致子线程在运行过程中出现段错误,将其直接杀死,没有等到父进程回收,而产生了僵尸进程. 调试&amp;&amp;Debug 查找子进程被杀死的原因,如,段错误可以重新定义段错误信号的处理打印部分信息. 排查显示fork和隐式fork,对子进程的操作. 子进程退出信号signal(SIGCHLD,sig_child)的自定义处理 设计时的预防 父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。 执行wait（）或waitpid（）系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生defunct进程。 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCLD, SIG_IGN）或signal（SIGCHLD, SIG_IGN）通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号 fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做]]></content>
      <categories>
        <category>进程</category>
        <category>进程状态</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM处理器寄存器和汇编指令]]></title>
    <url>%2Fpost%2F25025.html</url>
    <content type="text"><![CDATA[ARM体系结构支持7种处理器模式，分别是：用户、FIQ、IRQ、管理、中止（abort）、未定义和系统模式。除了用户模式外，其余都称之为特权模式。除了用户和系统模式外，其余都称之为异常模式 寄存器ARM的寄存器分为两类, 普通寄存器和状态寄存器 普通寄存器总共16个，分别为R0-R15；状态寄存器共2个，分别为CPSR和SPSR 寄存器(Reg) 寄存器(APCS) 作用域 含义 R0 a1 所有7种模式 工作寄存器 R1 a2 所有7种模式 .. R2 a3 所有7种模式 .. R3 a4 所有7种模式 .. R4 v1 所有7种模式 必须保护 R5 v2 所有7种模式 .. R6 v3 所有7种模式 .. R7 v4 所有7种模式 .. R8 v5 除FIQ模式 .. R9 v6 除FIQ模式 .. R10 sl 除FIQ模式 栈限制 R11 fp 除FIQ模式 帧指针 R12 ip 除FIQ模式 内部过程调用寄存器 R13 sp 用户和系统模式 栈指针 R14 lr 用户和系统模式 连接寄存器 R15 pc 所有7种模式 程序计数器 CPSR - - SPSR - 除用户和系统模式 - R13(sp): 每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。 R14(lr): 每种模式下r14都有自身版组，它有两个特殊功能。 保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一： 当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。 PSARM处理器中通常将寄存器R13作为堆栈指针（SP）。ARM处理器针对不同的模式，共有6个堆栈指针SP, 其中用户模式和系统模式共用一个SP，每种异常模式都有各自专用的R13寄存器（SP）。它们通常指向各模式所对应的专用堆栈，也就是ARM处理器允许用户程序有六个不同的堆栈空间。这些堆栈指针分别为R13、R13_svc、R13_abt、R13_und、R13_irq、R13_fiq. 汇编指令存储器访问指令ARM 处理是加载/存储体系结构的典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。 LDR和STR加载/存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从/到内存。 LDR 指令用于从内存中读取数据放入寄存器中； STR 指令用于将寄存器中的数据保存到内存。 1234LDR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt; ;加载指定地址上的数据(字)，放入Rd中STR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt; ;存储数据(字)到指定地址的存储单元，要存储的数据在Rd中LDR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt; ;加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零STR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt; ;存储字节数据，要存储的数据在Rd，最低字节有效 其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T 立即数 123LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)LDR R1,[R0,#-0x12] ;将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)LDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移) 寄存器 12LDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)LDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变) 寄存器及移位常数 12LDR R1,[R0,R2,LSL #2] ;将R0+R2*4地址处的数据读出，保存到R1中（R0，R2的值不变）LDR R1,[R0,-R2,LSL #2] ;将R0-R2*4地址处的数据计读出，保存到R1中(R0，R2的值不变) 数据处理指令跳转指令状态寄存器指令ARM协处理器指令示例分析源代码1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; int a = 1; int b, c; b = 3; c = a + b; printf("Hello c=%d!\n", c); return 0;&#125; 编译:1arm-linux-gnueabihf-gcc hello.c -o hello --save-temp 汇编代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.arch armv7-a.eabi_attribute 28, 1.eabi_attribute 20, 1.eabi_attribute 21, 1.eabi_attribute 23, 3.eabi_attribute 24, 1.eabi_attribute 25, 1.eabi_attribute 26, 2.eabi_attribute 30, 6.eabi_attribute 34, 1.eabi_attribute 18, 4.file &quot;hello.c&quot;.text.section .rodata.align 2.LC0:.ascii &quot;Hello c=%d!\012\000&quot;.text.align 1.global main.syntax unified.thumb.thumb_func.fpu vfpv3-d16.type main, %functionmain:@ args = 0, pretend = 0, frame = 24@ frame_needed = 1, uses_anonymous_args = 0push &#123;r7, lr&#125;sub sp, sp, #24add r7, sp, #0str r0, [r7, #4]str r1, [r7]movs r3, #1str r3, [r7, #20]movs r3, #3str r3, [r7, #16]ldr r2, [r7, #20]ldr r3, [r7, #16]add r3, r3, r2str r3, [r7, #12]ldr r1, [r7, #12]movw r0, #:lower16:.LC0movt r0, #:upper16:.LC0bl printfmovs r3, #0mov r0, r3adds r7, r7, #24mov sp, r7@ sp neededpop &#123;r7, pc&#125;.size main, .-main.ident &quot;GCC: (Linaro GCC 7.3-2018.05) 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701]&quot;.section .note.GNU-stack,&quot;&quot;,%progbits @: 单行注释 参考 ARM指令集详解 ARM汇编语言学习笔记（一）—ARM汇编的程序结构]]></content>
      <categories>
        <category>ARM</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM--GCC内嵌汇编]]></title>
    <url>%2Fpost%2F4526.html</url>
    <content type="text"><![CDATA[记录ARM平台中相关的汇编操作和总结 空指令–nopNOP指令不产生任何意义的操作,只占用一个机器周期,可以用于简单的延时操作 1asm("nop"); 在C代码中可以通过前后使用nop定位反汇编后代码所在的位置. 实际编程的用途: 需要短暂延时 需要精确控制延时,如控制驱动器步进电机的延时 通过在写NOP指令处填写相应代码实现分支跳转或分支调用??? 解密时用??? 在控制系统中插入NOP指令防止系统飞程??? 参考 NOP 指令作用]]></content>
      <categories>
        <category>ARM</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核工具--Sparse]]></title>
    <url>%2Fpost%2F22743.html</url>
    <content type="text"><![CDATA[Sparse诞生于2004年，是由Linux之父开发的，目的就是提供一个静态检查代码的工具，从而减少Linux内核的隐患。起始，在Sparse之前已经有了一个不错的代码静态检查工具（SWAT），只不过这个工具不是免费软件，使用上有一些限制。所以Linus自己开发了一个静态检查工具。 版本: linux4.4.166 参考文档:Documentation/sparse.txt Sparse通过gcc的扩展属性__attribute__以及自己定义的__context__来对代码进行静态检查。 __xxx双下划线开头的宏,表示编译器相关的一些属性设置 1234567891011121314151617181920212223#ifdef __CHECKER__# define __user __attribute__((noderef, address_space(1)))# define __kernel __attribute__((address_space(0)))# define __safe __attribute__((safe))# define __force __attribute__((force))# define __nocast __attribute__((nocast))# define __iomem __attribute__((noderef, address_space(2)))# define __must_hold(x) __attribute__((context(x,1,1)))# define __acquires(x) __attribute__((context(x,0,1)))# define __releases(x) __attribute__((context(x,1,0)))# define __acquire(x) __context__(x,1)# define __release(x) __context__(x,-1)# define __cond_lock(x,c) ((c) ? (&#123; __acquire(x); 1; &#125;) : 0)# define __percpu __attribute__((noderef, address_space(3)))# define __pmem __attribute__((noderef, address_space(5)))#ifdef CONFIG_SPARSE_RCU_POINTER# define __rcu __attribute__((noderef, address_space(4)))#else# define __rcu#endifextern void __chk_user_ptr(const volatile void __user *);extern void __chk_io_ptr(const volatile void __iomem *);#else file: include/linux/compiler.h 12345678910#ifdef __CHECKER__#define __bitwise__ __attribute__((bitwise))#else#define __bitwise__#endif#ifdef __CHECK_ENDIAN__#define __bitwise __bitwise__#else#define __bitwise#endif file: tools/include/linux/types.h 宏名称 定义 说明 __bitwise __attribute__((bitwise)) 确保变量是相同的位方式(比如 bit-endian, little-endiandeng) __user __attribute__((noderef, address_space(1))) 指针地址必须在用户地址空间 __kernel __attribute__((noderef, address_space(0))) 指针地址必须在内核地址空间 __iomem __attribute__((noderef, address_space(2))) 指针地址必须在设备地址空间 __safe __attribute__((safe)) 变量可以为空 __force __attribute__((force)) 变量可以进行强制转换 __nocast __attribute__((nocast)) 参数类型与实际参数类型必须一致 __acquires(x) __attribute__((context(x, 0, 1))) 参数x 在执行前引用计数必须是0,执行后,引用计数必须为1 __releases(x) __attribute__((context(x, 1, 0))) 与__acquires(x)相反 __acquire(x) __context__(x, 1) 参数x的引用计数+1 __release(x) __context__(x, 1) 与__acquire(x)相反 __cond_lock(x,c) ((c) ? ({ __acquire(x); 1; }) : 0) 参数c 不为0时,引用计数 + 1, 并返回1 其中__acquires(x)和__releases(x)，__acquire(x)和__release(x)必须配对使用,都和锁有关，否则Sparse会发出警告 Sparse 在编译内核中的使用12make C=1 检查所有重新编译的代码make C=2 检查所有代码, 不管是不是被重新编译 如果进行-Wbitwise的检查,需要定义#define __CHECK_ENDIAN__,可以通过CF进行传参12&gt; make C=2 CF=&quot;-D__CHECK_ENDIAN__&quot;&gt; 示例12345678static intfb_open(struct inode *inode, struct file *file)__acquires(&amp;info-&gt;lock)__releases(&amp;info-&gt;lock)&#123; ... return 0;&#125; 在编译阶段检查锁,防止死锁. 参考 内核工具 – Sparse 简介 what-does-static-int-function-acquires-releases-mean]]></content>
      <categories>
        <category>Linux内核</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RTCP协议]]></title>
    <url>%2Fpost%2F32277.html</url>
    <content type="text"><![CDATA[Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP由RFC 3550定义（取代作废的RFC 1889）。RTP 使用一个 偶数 UDP port ；而RTCP 则使用 RTP 的下一个 port，也就是一个奇数 port。RTCP与RTP联合工作，RTP实施实际数据的传输，RTCP则负责将控制包送至电话中的每个人。其主要功能是就RTP正在提供的服务质量(Quality of Service)做出反馈。 RTCP协议将控制包周期发送给所有连接者，应用与数据包相同的分布机制。低层协议提供数据与控制包的复用，如使用单独的UDP端口号。 作用: 主要是提供数据发布的质量反馈 RTCP带有称作规范名字（CNAME）的RTP源持久传输层标识 传送最小连接控制信息，如参加者辨识 RTCP分类 类型 缩写 用途 200 SR（Sender Report） 发送端报告 201 RR（Receiver Report） 接收端报告 202 SDES（Source Description Items） 源点描述 203 BYE 结束传输 204 APP 特定应用 RTCP的扩展 类型 缩写 用途 所在RFC 195 1J(Extended Jitter Report) 扩展Jitter报告 RFC 5450 205 RTPFB(Transport FB) 传输层反馈 RFC 4585 206 PSFB(Payload-specific FB) 负载相关反馈 RFC 5104 207 XR(Exteneded Report) 扩展报告 RFC 3611 FB: Feedback(反馈) 反馈报文类型: Transport layer FB messages Payload-specific FB messages Application layer FB messages 报文格式12345678910110 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| FMT | PT | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC of packet sender | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC of media source | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ : Feedback Control Information (FCI) : : : version(V), 2bits : 标识当前RTP版本2 padding(P), 1bit : 填充位标识 Feedback message type(FMT), 5bits : 标识反馈消息的类型 Payload type (PT), 8 bits : rtcp包的类型 Length, 16 bits : FMT报文子类型 类型 子类型 缩写 用途 205 1 Generic NACK RTP丢包重传 - 3 TMMBR Temporary Maximum Media Stream Bitrate Request - 4 TMMBN Temporary Maximum Media Stream Bitrate Notification 206 1 PLI Picture Loss Indication Generic NACK The Generic NACK message is identified by PT=RTPFB and FMT=1. 消息语法:123450 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PID | BLP | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ PID: Packet ID (PID): 16 bits 丢失RTP包的ID BLP: bitmask of following lost packets (BLP): 16 bits 从PID开始接下来16个RTP数据包的丢失情况,一个NACK报文可以携带多个RTP序列号，NACK接收端对这些序列号逐个处理。 丢包重传如果在接收端检查到出现丢包现象,通过RTCP发送丢包ID接可以让丢包重传. 123456789101112131415161718192021222324252627282930313233static void RequestLostPacket(rtp_t *rtp, unsigned int rtpSsrc, int seqNo)&#123; char FB_msg_packet[128] = &#123;0&#125;; unsigned int srcId = rtpSsrc; int blp = 0; //表示一个只处理一个丢包 FB_msg_packet[0] = 0x80 | 1; // version=2, Generic NACK FB_msg_packet[1] = 205; // RTPFB FB_msg_packet[2] = 0; FB_msg_packet[3] = 3; //length = 3 // SSRC of packet sender FB_msg_packet[4] = 0xde; FB_msg_packet[5] = 0xad; FB_msg_packet[6] = 0xbe; FB_msg_packet[7] = 0xef; //SSRC of media source FB_msg_packet[8] = (srcId &gt;&gt; 24) &amp; 0xff; FB_msg_packet[9] = (srcId &gt;&gt; 16) &amp; 0xff; FB_msg_packet[10] = (srcId &gt;&gt; 8) &amp; 0xff; FB_msg_packet[11] = (srcId &amp; 0xff); //lost packet ID FB_msg_packet[12] = (seqNo &gt;&gt; 8) &amp; 0xff; FB_msg_packet[13] = (seqNo &amp; 0xff); //BLP FB_msg_packet[14] = (blp &gt;&gt; 8) &amp; 0xff; FB_msg_packet[15] = (blp &amp; 0xff); net_session_write(&amp;rtp-&gt;rtcp_net, FB_msg_packet, 16);&#125; 其他格式SR: Sender Report RTCP Packet12345678910111213141516171819202122232425262728293031323334350 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+header |V=2|P| RC | PT=SR=200 | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC of sender | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+sender | NTP timestamp, most significant word |info +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | NTP timestamp, least significant word | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | RTP timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | sender&apos;s packet count | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | sender&apos;s octet count | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+report | SSRC_1 (SSRC of first source) |block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1 | fraction lost | cumulative number of packets lost | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | extended highest sequence number received | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | interarrival jitter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | last SR (LSR) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | delay since last SR (DLSR) | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+report | SSRC_2 (SSRC of second source) |block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 2 : ... : +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | profile-specific extensions | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ RR: Receiver Report RTCP Packet123456789101112131415161718192021222324250 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+header |V=2|P| RC | PT=RR=201 | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC of packet sender | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+report | SSRC_1 (SSRC of first source) |block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+1 | fraction lost | cumulative number of packets lost | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | extended highest sequence number received | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | interarrival jitter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | last SR (LSR) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | delay since last SR (DLSR) | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+report | SSRC_2 (SSRC of second source) |block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+2 : ... : +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | profile-specific extensions | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></content>
      <categories>
        <category>多媒体</category>
        <category>传输</category>
      </categories>
      <tags>
        <tag>rtcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wpa_supplicant源码分析--conf配置文件]]></title>
    <url>%2Fpost%2F50085.html</url>
    <content type="text"><![CDATA[解析wpa_supplicant的配置文件，一般叫做 wpa_supplicant.conf 在wpa_supplicant的源码中都有配置文件的示例wpa_supplicant.conf wpa_supplicant.conf当前项目中使用到的一个配置文件 12345678910111213141516171819202122ctrl_interface=/var/run/socketsdriver_param=use_p2p_group_interface=1p2p_device=1update_config=1device_name=V_9ca2device_type=10-0050F204-5config_methods=virtual_push_button physical_display keypadp2p_go_intent=15p2p_ssid_postfix=-V_9ca2persistent_reconnect=1network=&#123; ssid=&quot;D-H-V_9ca2&quot; bssid=ae:83:f3:b4:9c:a2 psk=&quot;00000000&quot; proto=RSN key_mgmt=WPA-PSK pairwise=CCMP auth_alg=OPEN mode=3 disabled=2 p2p_client_list=1a:f0:e4:87:fb:74 ac:83:f3:b3:72:24 04:e6:76:c3:37:84&#125; 该配置文件用于p2p 1wpa_supplicant -iwlan0 -s -Dnl80211 -O/var/run/sockets -c/etc/wifi/p2p_supplicant.conf -D: 指定使用的wifi驱动, nl80211 = Linux nl80211/cfg80211 -i: 指定端口 -C: 指定配置文件 -O: 覆盖新接口的ctrl_interface参数 配置文件解析以下的数据结构都是从wpa_supplicant_8中的源码获取. 8支持建立热点(hostapd) 可配置参数wpa_supplicant的所有参数都定义在struct wpa_config中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667/** * struct wpa_config - wpa_supplicant configuration data * * This data structure is presents the per-interface (radio) configuration * data. In many cases, there is only one struct wpa_config instance, but if * more than one network interface is being controlled, one instance is used * for each. */struct wpa_config &#123; /** * ssid - Head of the global network list * * This is the head for the list of all the configured networks. * config文件中，存储所有network节点的链表 */ struct wpa_ssid *ssid; /** * pssid - Per-priority network lists (in priority order) * 按照priority排列的network节点 */ struct wpa_ssid **pssid; /** * num_prio - Number of different priorities used in the pssid lists * * This indicates how many per-priority network lists are included in * pssid. */ int num_prio; /** * cred - Head of the credential list * * This is the head for the list of all the configured credentials. */ struct wpa_cred *cred; /** * eapol_version - IEEE 802.1X/EAPOL version number * * wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which * defines EAPOL version 2. However, there are many APs that do not * handle the new version number correctly (they seem to drop the * frames completely). In order to make wpa_supplicant interoperate * with these APs, the version number is set to 1 by default. This * configuration value can be used to set it to the new version (2). */ int eapol_version; /** * ap_scan - AP scanning/selection * * By default, wpa_supplicant requests driver to perform AP * scanning and then uses the scan results to select a * suitable AP. Another alternative is to allow the driver to * take care of AP scanning and selection and use * wpa_supplicant just to process EAPOL frames based on IEEE * 802.11 association information from the driver. * * 1: wpa_supplicant initiates scanning and AP selection (default). * * 0: Driver takes care of scanning, AP selection, and IEEE 802.11 * association parameters (e.g., WPA IE generation); this mode can * also be used with non-WPA drivers when using IEEE 802.1X mode; * do not try to associate with APs (i.e., external program needs * to control association). This mode must also be used when using * wired Ethernet drivers. * * 2: like 0, but associate with APs using security policy and SSID * (but not BSSID); this can be used, e.g., with ndiswrapper and NDIS * drivers to enable operation with hidden SSIDs and optimized roaming; * in this mode, the network blocks in the configuration are tried * one by one until the driver reports successful association; each * network block should have explicit security policy (i.e., only one * option in the lists) for key_mgmt, pairwise, group, proto variables. */ int ap_scan; /** * disable_scan_offload - Disable automatic offloading of scan requests * * By default, %wpa_supplicant tries to offload scanning if the driver * indicates support for this (sched_scan). This configuration * parameter can be used to disable this offloading mechanism. */ int disable_scan_offload; /** * ctrl_interface - Parameters for the control interface * * If this is specified, %wpa_supplicant will open a control interface * that is available for external programs to manage %wpa_supplicant. * The meaning of this string depends on which control interface * mechanism is used. For all cases, the existence of this parameter * in configuration is used to determine whether the control interface * is enabled. * * For UNIX domain sockets (default on Linux and BSD): This is a * directory that will be created for UNIX domain sockets for listening * to requests from external programs (CLI/GUI, etc.) for status * information and configuration. The socket file will be named based * on the interface name, so multiple %wpa_supplicant processes can be * run at the same time if more than one interface is used. * /var/run/wpa_supplicant is the recommended directory for sockets and * by default, wpa_cli will use it when trying to connect with * %wpa_supplicant. * * Access control for the control interface can be configured * by setting the directory to allow only members of a group * to use sockets. This way, it is possible to run * %wpa_supplicant as root (since it needs to change network * configuration and open raw sockets) and still allow GUI/CLI * components to be run as non-root users. However, since the * control interface can be used to change the network * configuration, this access needs to be protected in many * cases. By default, %wpa_supplicant is configured to use gid * 0 (root). If you want to allow non-root users to use the * control interface, add a new group and change this value to * match with that group. Add users that should have control * interface access to this group. * * When configuring both the directory and group, use following format: * DIR=/var/run/wpa_supplicant GROUP=wheel * DIR=/var/run/wpa_supplicant GROUP=0 * (group can be either group name or gid) * * For UDP connections (default on Windows): The value will be ignored. * This variable is just used to select that the control interface is * to be created. The value can be set to, e.g., udp * (ctrl_interface=udp). * * For Windows Named Pipe: This value can be used to set the security * descriptor for controlling access to the control interface. Security * descriptor can be set using Security Descriptor String Format (see * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/security_descriptor_string_format.asp). * The descriptor string needs to be prefixed with SDDL=. For example, * ctrl_interface=SDDL=D: would set an empty DACL (which will reject * all connections). */ char *ctrl_interface; /** * ctrl_interface_group - Control interface group (DEPRECATED) * * This variable is only used for backwards compatibility. Group for * UNIX domain sockets should now be specified using GROUP=group in * ctrl_interface variable. */ char *ctrl_interface_group; /** * fast_reauth - EAP fast re-authentication (session resumption) * * By default, fast re-authentication is enabled for all EAP methods * that support it. This variable can be used to disable fast * re-authentication (by setting fast_reauth=0). Normally, there is no * need to disable fast re-authentication. */ int fast_reauth; /** * opensc_engine_path - Path to the OpenSSL engine for opensc * * This is an OpenSSL specific configuration option for loading OpenSC * engine (engine_opensc.so); if %NULL, this engine is not loaded. */ char *opensc_engine_path; /** * pkcs11_engine_path - Path to the OpenSSL engine for PKCS#11 * * This is an OpenSSL specific configuration option for loading PKCS#11 * engine (engine_pkcs11.so); if %NULL, this engine is not loaded. */ char *pkcs11_engine_path; /** * pkcs11_module_path - Path to the OpenSSL OpenSC/PKCS#11 module * * This is an OpenSSL specific configuration option for configuring * path to OpenSC/PKCS#11 engine (opensc-pkcs11.so); if %NULL, this * module is not loaded. */ char *pkcs11_module_path; /** * pcsc_reader - PC/SC reader name prefix * * If not %NULL, PC/SC reader with a name that matches this prefix is * initialized for SIM/USIM access. Empty string can be used to match * the first available reader. */ char *pcsc_reader; /** * pcsc_pin - PIN for USIM, GSM SIM, and smartcards * * This field is used to configure PIN for SIM/USIM for EAP-SIM and * EAP-AKA. If left out, this will be asked through control interface. */ char *pcsc_pin; /** * driver_param - Driver interface parameters * * This text string is passed to the selected driver interface with the * optional struct wpa_driver_ops::set_param() handler. This can be * used to configure driver specific options without having to add new * driver interface functionality. */ char *driver_param; /** * dot11RSNAConfigPMKLifetime - Maximum lifetime of a PMK * * dot11 MIB variable for the maximum lifetime of a PMK in the PMK * cache (unit: seconds). */ unsigned int dot11RSNAConfigPMKLifetime; /** * dot11RSNAConfigPMKReauthThreshold - PMK re-authentication threshold * * dot11 MIB variable for the percentage of the PMK lifetime * that should expire before an IEEE 802.1X reauthentication occurs. */ unsigned int dot11RSNAConfigPMKReauthThreshold; /** * dot11RSNAConfigSATimeout - Security association timeout * * dot11 MIB variable for the maximum time a security association * shall take to set up (unit: seconds). */ unsigned int dot11RSNAConfigSATimeout; /** * update_config - Is wpa_supplicant allowed to update configuration * * This variable control whether wpa_supplicant is allow to re-write * its configuration with wpa_config_write(). If this is zero, * configuration data is only changed in memory and the external data * is not overriden. If this is non-zero, wpa_supplicant will update * the configuration data (e.g., a file) whenever configuration is * changed. This update may replace the old configuration which can * remove comments from it in case of a text file configuration. */ int update_config; /** * blobs - Configuration blobs */ struct wpa_config_blob *blobs; /** * uuid - Universally Unique IDentifier (UUID; see RFC 4122) for WPS */ u8 uuid[16]; /** * device_name - Device Name (WPS) * User-friendly description of device; up to 32 octets encoded in * UTF-8 */ char *device_name; /** * manufacturer - Manufacturer (WPS) * The manufacturer of the device (up to 64 ASCII characters) */ char *manufacturer; /** * model_name - Model Name (WPS) * Model of the device (up to 32 ASCII characters) */ char *model_name; /** * model_number - Model Number (WPS) * Additional device description (up to 32 ASCII characters) */ char *model_number; /** * serial_number - Serial Number (WPS) * Serial number of the device (up to 32 characters) */ char *serial_number; /** * device_type - Primary Device Type (WPS) */ u8 device_type[WPS_DEV_TYPE_LEN]; /** * config_methods - Config Methods * * This is a space-separated list of supported WPS configuration * methods. For example, "label virtual_display virtual_push_button * keypad". * Available methods: usba ethernet label display ext_nfc_token * int_nfc_token nfc_interface push_button keypad * virtual_display physical_display * virtual_push_button physical_push_button. */ char *config_methods; /** * os_version - OS Version (WPS) * 4-octet operating system version number */ u8 os_version[4]; /** * country - Country code * * This is the ISO/IEC alpha2 country code for which we are operating * in */ char country[2]; /** * wps_cred_processing - Credential processing * * 0 = process received credentials internally * 1 = do not process received credentials; just pass them over * ctrl_iface to external program(s) * 2 = process received credentials internally and pass them over * ctrl_iface to external program(s) */ int wps_cred_processing;#define MAX_SEC_DEVICE_TYPES 5 /** * sec_device_types - Secondary Device Types (P2P) */ u8 sec_device_type[MAX_SEC_DEVICE_TYPES][WPS_DEV_TYPE_LEN]; int num_sec_device_types; int p2p_listen_reg_class; int p2p_listen_channel; int p2p_oper_reg_class; int p2p_oper_channel; int p2p_go_intent; char *p2p_ssid_postfix; int persistent_reconnect; int p2p_intra_bss; unsigned int num_p2p_pref_chan; struct p2p_channel *p2p_pref_chan; int p2p_ignore_shared_freq; struct wpabuf *wps_vendor_ext_m1;#define MAX_WPS_VENDOR_EXT 10 /** * wps_vendor_ext - Vendor extension attributes in WPS */ struct wpabuf *wps_vendor_ext[MAX_WPS_VENDOR_EXT]; /** * p2p_group_idle - Maximum idle time in seconds for P2P group * * This value controls how long a P2P group is maintained after there * is no other members in the group. As a GO, this means no associated * stations in the group. As a P2P client, this means no GO seen in * scan results. The maximum idle time is specified in seconds with 0 * indicating no time limit, i.e., the P2P group remains in active * state indefinitely until explicitly removed. As a P2P client, the * maximum idle time of P2P_MAX_CLIENT_IDLE seconds is enforced, i.e., * this parameter is mainly meant for GO use and for P2P client, it can * only be used to reduce the default timeout to smaller value. A * special value -1 can be used to configure immediate removal of the * group for P2P client role on any disconnection after the data * connection has been established. */ int p2p_group_idle; /** * bss_max_count - Maximum number of BSS entries to keep in memory */ unsigned int bss_max_count; /** * bss_expiration_age - BSS entry age after which it can be expired * * This value controls the time in seconds after which a BSS entry * gets removed if it has not been updated or is not in use. */ unsigned int bss_expiration_age; /** * bss_expiration_scan_count - Expire BSS after number of scans * * If the BSS entry has not been seen in this many scans, it will be * removed. A value of 1 means that entry is removed after the first * scan in which the BSSID is not seen. Larger values can be used * to avoid BSS entries disappearing if they are not visible in * every scan (e.g., low signal quality or interference). */ unsigned int bss_expiration_scan_count; /** * filter_ssids - SSID-based scan result filtering * * 0 = do not filter scan results * 1 = only include configured SSIDs in scan results/BSS table */ int filter_ssids; /** * filter_rssi - RSSI-based scan result filtering * * 0 = do not filter scan results * -n = filter scan results below -n dBm */ int filter_rssi; /** * max_num_sta - Maximum number of STAs in an AP/P2P GO */ unsigned int max_num_sta; /** * freq_list - Array of allowed scan frequencies or %NULL for all * * This is an optional zero-terminated array of frequencies in * megahertz (MHz) to allow for narrowing scanning range. */ int *freq_list; /** * scan_cur_freq - Whether to scan only the current channel * * If true, attempt to scan only the current channel if any other * VIFs on this radio are already associated on a particular channel. */ int scan_cur_freq; /** * changed_parameters - Bitmap of changed parameters since last update */ unsigned int changed_parameters; /** * disassoc_low_ack - Disassocicate stations with massive packet loss */ int disassoc_low_ack; /** * interworking - Whether Interworking (IEEE 802.11u) is enabled */ int interworking; /** * access_network_type - Access Network Type * * When Interworking is enabled, scans will be limited to APs that * advertise the specified Access Network Type (0..15; with 15 * indicating wildcard match). */ int access_network_type; /** * hessid - Homogenous ESS identifier * * If this is set (any octet is non-zero), scans will be used to * request response only from BSSes belonging to the specified * Homogeneous ESS. This is used only if interworking is enabled. */ u8 hessid[ETH_ALEN]; /** * hs20 - Hotspot 2.0 */ int hs20; /** * pbc_in_m1 - AP mode WPS probing workaround for PBC with Windows 7 * * Windows 7 uses incorrect way of figuring out AP's WPS capabilities * by acting as a Registrar and using M1 from the AP. The config * methods attribute in that message is supposed to indicate only the * configuration method supported by the AP in Enrollee role, i.e., to * add an external Registrar. For that case, PBC shall not be used and * as such, the PushButton config method is removed from M1 by default. * If pbc_in_m1=1 is included in the configuration file, the PushButton * config method is left in M1 (if included in config_methods * parameter) to allow Windows 7 to use PBC instead of PIN (e.g., from * a label in the AP). */ int pbc_in_m1; /** * autoscan - Automatic scan parameters or %NULL if none * * This is an optional set of parameters for automatic scanning * within an interface in following format: * &lt;autoscan module name&gt;:&lt;module parameters&gt; */ char *autoscan; /** * wps_nfc_pw_from_config - NFC Device Password was read from config * * This parameter can be determined whether the NFC Device Password was * included in the configuration (1) or generated dynamically (0). Only * the former case is re-written back to the configuration file. */ int wps_nfc_pw_from_config; /** * wps_nfc_dev_pw_id - NFC Device Password ID for password token */ int wps_nfc_dev_pw_id; /** * wps_nfc_dh_pubkey - NFC DH Public Key for password token */ struct wpabuf *wps_nfc_dh_pubkey; /** * wps_nfc_dh_privkey - NFC DH Private Key for password token */ struct wpabuf *wps_nfc_dh_privkey; /** * wps_nfc_dev_pw - NFC Device Password for password token */ struct wpabuf *wps_nfc_dev_pw; /** * ext_password_backend - External password backend or %NULL if none * * format: &lt;backend name&gt;[:&lt;optional backend parameters&gt;] */ char *ext_password_backend; /* * p2p_go_max_inactivity - Timeout in seconds to detect STA inactivity * * This timeout value is used in P2P GO mode to clean up * inactive stations. * By default: 300 seconds. */ int p2p_go_max_inactivity; struct hostapd_wmm_ac_params wmm_ac_params[4]; /** * auto_interworking - Whether to use network selection automatically * * 0 = do not automatically go through Interworking network selection * (i.e., require explicit interworking_select command for this) * 1 = perform Interworking network selection if one or more * credentials have been configured and scan did not find a * matching network block */ int auto_interworking; /** * p2p_go_ht40 - Default mode for HT40 enable when operating as GO. * * This will take effect for p2p_group_add, p2p_connect, and p2p_invite. * Note that regulatory constraints and driver capabilities are * consulted anyway, so setting it to 1 can't do real harm. * By default: 0 (disabled) */ int p2p_go_ht40; /** * p2p_disabled - Whether P2P operations are disabled for this interface */ int p2p_disabled; /** * p2p_no_group_iface - Whether group interfaces can be used * * By default, wpa_supplicant will create a separate interface for P2P * group operations if the driver supports this. This functionality can * be disabled by setting this parameter to 1. In that case, the same * interface that was used for the P2P management operations is used * also for the group operation. */ int p2p_no_group_iface; /** * okc - Whether to enable opportunistic key caching by default * * By default, OKC is disabled unless enabled by the per-network * proactive_key_caching=1 parameter. okc=1 can be used to change this * default behavior. */ int okc; /** * pmf - Whether to enable/require PMF by default * * By default, PMF is disabled unless enabled by the per-network * ieee80211w=1 or ieee80211w=2 parameter. pmf=1/2 can be used to change * this default behavior. */ enum mfp_options pmf; /** * sae_groups - Preference list of enabled groups for SAE * * By default (if this parameter is not set), the mandatory group 19 * (ECC group defined over a 256-bit prime order field) is preferred, * but other groups are also enabled. If this parameter is set, the * groups will be tried in the indicated order. */ int *sae_groups; /** * dtim_period - Default DTIM period in Beacon intervals * * This parameter can be used to set the default value for network * blocks that do not specify dtim_period. */ int dtim_period; /** * beacon_int - Default Beacon interval in TU * * This parameter can be used to set the default value for network * blocks that do not specify beacon_int. */ int beacon_int; /** * ap_vendor_elements: Vendor specific elements for Beacon/ProbeResp * * This parameter can be used to define additional vendor specific * elements for Beacon and Probe Response frames in AP/P2P GO mode. The * format for these element(s) is a hexdump of the raw information * elements (id+len+payload for one or more elements). */ struct wpabuf *ap_vendor_elements; /** * ignore_old_scan_res - Ignore scan results older than request * * The driver may have a cache of scan results that makes it return * information that is older than our scan trigger. This parameter can * be used to configure such old information to be ignored instead of * allowing it to update the internal BSS table. */ int ignore_old_scan_res; /** * sched_scan_interval - schedule scan interval */ unsigned int sched_scan_interval; /** * tdls_external_control - External control for TDLS setup requests * * Enable TDLS mode where external programs are given the control * to specify the TDLS link to get established to the driver. The * driver requests the TDLS setup to the supplicant only for the * specified TDLS peers. * */ int tdls_external_control;&#125;; network节点wpa_supplicant.conf文件中每个network节点都是一个保存的网络, 存储了网络的名称（ssid），密码（psk），加密方式（WPA_PSK），优先级（priority） WIFI网络有多种加密方式，每种加密方式（wpa_psk，wep，open，wapi，各种eap等）的节点书写方式都不同，具体可以参考源代码中wpa_supplicant.conf文件 network节点的结构体struct wpa_ssid 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580/** * struct wpa_ssid - Network configuration data * * This structure includes all the configuration variables for a network. This * data is included in the per-interface configuration data as an element of * the network list, struct wpa_config::ssid. Each network block in the * configuration is mapped to a struct wpa_ssid instance. */struct wpa_ssid &#123; /** * next - Next network in global list * * This pointer can be used to iterate over all networks. The head of * this list is stored in the ssid field of struct wpa_config. */ struct wpa_ssid *next; /** * pnext - Next network in per-priority list * * This pointer can be used to iterate over all networks in the same * priority class. The heads of these list are stored in the pssid * fields of struct wpa_config. */ struct wpa_ssid *pnext; /** * id - Unique id for the network * * This identifier is used as a unique identifier for each network * block when using the control interface. Each network is allocated an * id when it is being created, either when reading the configuration * file or when a new network is added through the control interface. */ int id; /** * priority - Priority group * * By default, all networks will get same priority group (0). If some * of the networks are more desirable, this field can be used to change * the order in which wpa_supplicant goes through the networks when * selecting a BSS. The priority groups will be iterated in decreasing * priority (i.e., the larger the priority value, the sooner the * network is matched against the scan results). Within each priority * group, networks will be selected based on security policy, signal * strength, etc. * * Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are * not using this priority to select the order for scanning. Instead, * they try the networks in the order that used in the configuration * file. */ int priority; /** * ssid - Service set identifier (network name) * * This is the SSID for the network. For wireless interfaces, this is * used to select which network will be used. If set to %NULL (or * ssid_len=0), any SSID can be used. For wired interfaces, this must * be set to %NULL. Note: SSID may contain any characters, even nul * (ASCII 0) and as such, this should not be assumed to be a nul * terminated string. ssid_len defines how many characters are valid * and the ssid field is not guaranteed to be nul terminated. */ u8 *ssid; /** * ssid_len - Length of the SSID */ size_t ssid_len; /** * bssid - BSSID * * If set, this network block is used only when associating with the AP * using the configured BSSID * * If this is a persistent P2P group (disabled == 2), this is the GO * Device Address. */ u8 bssid[ETH_ALEN]; /** * bssid_set - Whether BSSID is configured for this network */ int bssid_set; /** * psk - WPA pre-shared key (256 bits) */ u8 psk[32]; /** * psk_set - Whether PSK field is configured */ int psk_set; /** * passphrase - WPA ASCII passphrase * * If this is set, psk will be generated using the SSID and passphrase * configured for the network. ASCII passphrase must be between 8 and * 63 characters (inclusive). */ char *passphrase; /** * ext_psk - PSK/passphrase name in external storage * * If this is set, PSK/passphrase will be fetched from external storage * when requesting association with the network. */ char *ext_psk; /** * pairwise_cipher - Bitfield of allowed pairwise ciphers, WPA_CIPHER_* */ int pairwise_cipher; /** * group_cipher - Bitfield of allowed group ciphers, WPA_CIPHER_* */ int group_cipher; /** * key_mgmt - Bitfield of allowed key management protocols * * WPA_KEY_MGMT_* */ int key_mgmt; /** * bg_scan_period - Background scan period in seconds, 0 to disable, or * -1 to indicate no change to default driver configuration */ int bg_scan_period; /** * proto - Bitfield of allowed protocols, WPA_PROTO_* */ int proto; /** * auth_alg - Bitfield of allowed authentication algorithms * * WPA_AUTH_ALG_* */ int auth_alg; /** * scan_ssid - Scan this SSID with Probe Requests * * scan_ssid can be used to scan for APs using hidden SSIDs. * Note: Many drivers do not support this. ap_mode=2 can be used with * such drivers to use hidden SSIDs. */ int scan_ssid;#ifdef IEEE8021X_EAPOL#define EAPOL_FLAG_REQUIRE_KEY_UNICAST BIT(0)#define EAPOL_FLAG_REQUIRE_KEY_BROADCAST BIT(1) /** * eapol_flags - Bit field of IEEE 802.1X/EAPOL options (EAPOL_FLAG_*) */ int eapol_flags; /** * eap - EAP peer configuration for this network */ struct eap_peer_config eap;#endif /* IEEE8021X_EAPOL */#define NUM_WEP_KEYS 4#define MAX_WEP_KEY_LEN 16 /** * wep_key - WEP keys */ u8 wep_key[NUM_WEP_KEYS][MAX_WEP_KEY_LEN]; /** * wep_key_len - WEP key lengths */ size_t wep_key_len[NUM_WEP_KEYS]; /** * wep_tx_keyidx - Default key index for TX frames using WEP */ int wep_tx_keyidx; /** * proactive_key_caching - Enable proactive key caching * * This field can be used to enable proactive key caching which is also * known as opportunistic PMKSA caching for WPA2. This is disabled (0) * by default unless default value is changed with the global okc=1 * parameter. Enable by setting this to 1. * * Proactive key caching is used to make supplicant assume that the APs * are using the same PMK and generate PMKSA cache entries without * doing RSN pre-authentication. This requires support from the AP side * and is normally used with wireless switches that co-locate the * authenticator. * * Internally, special value -1 is used to indicate that the parameter * was not specified in the configuration (i.e., default behavior is * followed). */ int proactive_key_caching; /** * mixed_cell - Whether mixed cells are allowed * * This option can be used to configure whether so called mixed cells, * i.e., networks that use both plaintext and encryption in the same * SSID, are allowed. This is disabled (0) by default. Enable by * setting this to 1. */ int mixed_cell;#ifdef IEEE8021X_EAPOL /** * leap - Number of EAP methods using LEAP * * This field should be set to 1 if LEAP is enabled. This is used to * select IEEE 802.11 authentication algorithm. */ int leap; /** * non_leap - Number of EAP methods not using LEAP * * This field should be set to &gt;0 if any EAP method other than LEAP is * enabled. This is used to select IEEE 802.11 authentication * algorithm. */ int non_leap; /** * eap_workaround - EAP workarounds enabled * * wpa_supplicant supports number of "EAP workarounds" to work around * interoperability issues with incorrectly behaving authentication * servers. This is recommended to be enabled by default because some * of the issues are present in large number of authentication servers. * * Strict EAP conformance mode can be configured by disabling * workarounds with eap_workaround = 0. */ unsigned int eap_workaround;#endif /* IEEE8021X_EAPOL */ /** * mode - IEEE 802.11 operation mode (Infrastucture/IBSS) * * 0 = infrastructure (Managed) mode, i.e., associate with an AP. * * 1 = IBSS (ad-hoc, peer-to-peer) * * 2 = AP (access point) * * 3 = P2P Group Owner (can be set in the configuration file) * * 4 = P2P Group Formation (used internally; not in configuration * files) * * Note: IBSS can only be used with key_mgmt NONE (plaintext and * static WEP) and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In * addition, ap_scan has to be set to 2 for IBSS. WPA-None requires * following network block options: proto=WPA, key_mgmt=WPA-NONE, * pairwise=NONE, group=TKIP (or CCMP, but not both), and psk must also * be set (either directly or using ASCII passphrase). */ enum wpas_mode &#123; WPAS_MODE_INFRA = 0, WPAS_MODE_IBSS = 1, WPAS_MODE_AP = 2, WPAS_MODE_P2P_GO = 3, WPAS_MODE_P2P_GROUP_FORMATION = 4, &#125; mode; /** * disabled - Whether this network is currently disabled * * 0 = this network can be used (default). * 1 = this network block is disabled (can be enabled through * ctrl_iface, e.g., with wpa_cli or wpa_gui). * 2 = this network block includes parameters for a persistent P2P * group (can be used with P2P ctrl_iface commands) */ int disabled; /** * disabled_for_connect - Whether this network was temporarily disabled * * This flag is used to reenable all the temporarily disabled networks * after either the success or failure of a WPS connection. */ int disabled_for_connect; /** * peerkey - Whether PeerKey handshake for direct links is allowed * * This is only used when both RSN/WPA2 and IEEE 802.11e (QoS) are * enabled. * * 0 = disabled (default) * 1 = enabled */ int peerkey; /** * id_str - Network identifier string for external scripts * * This value is passed to external ctrl_iface monitors in * WPA_EVENT_CONNECTED event and wpa_cli sets this as WPA_ID_STR * environment variable for action scripts. */ char *id_str;#ifdef CONFIG_IEEE80211W /** * ieee80211w - Whether management frame protection is enabled * * This value is used to configure policy for management frame * protection (IEEE 802.11w). 0 = disabled, 1 = optional, 2 = required. * This is disabled by default unless the default value has been changed * with the global pmf=1/2 parameter. * * Internally, special value 3 is used to indicate that the parameter * was not specified in the configuration (i.e., default behavior is * followed). */ enum mfp_options ieee80211w;#endif /* CONFIG_IEEE80211W */ /** * frequency - Channel frequency in megahertz (MHz) for IBSS * * This value is used to configure the initial channel for IBSS (adhoc) * networks, e.g., 2412 = IEEE 802.11b/g channel 1. It is ignored in * the infrastructure mode. In addition, this value is only used by the * station that creates the IBSS. If an IBSS network with the * configured SSID is already present, the frequency of the network * will be used instead of this configured value. */ int frequency; int ht40; /** * wpa_ptk_rekey - Maximum lifetime for PTK in seconds * * This value can be used to enforce rekeying of PTK to mitigate some * attacks against TKIP deficiencies. */ int wpa_ptk_rekey; /** * scan_freq - Array of frequencies to scan or %NULL for all * * This is an optional zero-terminated array of frequencies in * megahertz (MHz) to include in scan requests when searching for this * network. This can be used to speed up scanning when the network is * known to not use all possible channels. */ int *scan_freq; /** * bgscan - Background scan and roaming parameters or %NULL if none * * This is an optional set of parameters for background scanning and * roaming within a network (ESS) in following format: * &lt;bgscan module name&gt;:&lt;module parameters&gt; */ char *bgscan; /** * ignore_broadcast_ssid - Hide SSID in AP mode * * Send empty SSID in beacons and ignore probe request frames that do * not specify full SSID, i.e., require stations to know SSID. * default: disabled (0) * 1 = send empty (length=0) SSID in beacon and ignore probe request * for broadcast SSID * 2 = clear SSID (ASCII 0), but keep the original length (this may be * required with some clients that do not support empty SSID) and * ignore probe requests for broadcast SSID */ int ignore_broadcast_ssid; /** * freq_list - Array of allowed frequencies or %NULL for all * * This is an optional zero-terminated array of frequencies in * megahertz (MHz) to allow for selecting the BSS. If set, scan results * that do not match any of the specified frequencies are not * considered when selecting a BSS. */ int *freq_list; /** * p2p_client_list - List of P2P Clients in a persistent group (GO) * * This is a list of P2P Clients (P2P Device Address) that have joined * the persistent group. This is maintained on the GO for persistent * group entries (disabled == 2). */ u8 *p2p_client_list; /** * num_p2p_clients - Number of entries in p2p_client_list */ size_t num_p2p_clients;#ifndef P2P_MAX_STORED_CLIENTS#define P2P_MAX_STORED_CLIENTS 100#endif /* P2P_MAX_STORED_CLIENTS */ /** * psk_list - Per-client PSKs (struct psk_list_entry) */ struct dl_list psk_list; /** * p2p_group - Network generated as a P2P group (used internally) */ int p2p_group; /** * p2p_persistent_group - Whether this is a persistent group */ int p2p_persistent_group; /** * temporary - Whether this network is temporary and not to be saved */ int temporary; /** * export_keys - Whether keys may be exported * * This attribute will be set when keys are determined through * WPS or similar so that they may be exported. */ int export_keys;#ifdef ANDROID_P2P /** * assoc_retry - Number of times association should be retried. */ int assoc_retry;#endif#ifdef CONFIG_HT_OVERRIDES /** * disable_ht - Disable HT (IEEE 802.11n) for this network * * By default, use it if it is available, but this can be configured * to 1 to have it disabled. */ int disable_ht; /** * disable_ht40 - Disable HT40 for this network * * By default, use it if it is available, but this can be configured * to 1 to have it disabled. */ int disable_ht40; /** * disable_sgi - Disable SGI (Short Guard Interval) for this network * * By default, use it if it is available, but this can be configured * to 1 to have it disabled. */ int disable_sgi; /** * disable_max_amsdu - Disable MAX A-MSDU * * A-MDSU will be 3839 bytes when disabled, or 7935 * when enabled (assuming it is otherwise supported) * -1 (default) means do not apply any settings to the kernel. */ int disable_max_amsdu; /** * ampdu_factor - Maximum A-MPDU Length Exponent * * Value: 0-3, see 7.3.2.56.3 in IEEE Std 802.11n-2009. */ int ampdu_factor; /** * ampdu_density - Minimum A-MPDU Start Spacing * * Value: 0-7, see 7.3.2.56.3 in IEEE Std 802.11n-2009. */ int ampdu_density; /** * ht_mcs - Allowed HT-MCS rates, in ASCII hex: ffff0000... * * By default (empty string): Use whatever the OS has configured. */ char *ht_mcs;#endif /* CONFIG_HT_OVERRIDES */#ifdef CONFIG_VHT_OVERRIDES /** * disable_vht - Disable VHT (IEEE 802.11ac) for this network * * By default, use it if it is available, but this can be configured * to 1 to have it disabled. */ int disable_vht; /** * vht_capa - VHT capabilities to use */ unsigned int vht_capa; /** * vht_capa_mask - mask for VHT capabilities */ unsigned int vht_capa_mask; int vht_rx_mcs_nss_1, vht_rx_mcs_nss_2, vht_rx_mcs_nss_3, vht_rx_mcs_nss_4, vht_rx_mcs_nss_5, vht_rx_mcs_nss_6, vht_rx_mcs_nss_7, vht_rx_mcs_nss_8; int vht_tx_mcs_nss_1, vht_tx_mcs_nss_2, vht_tx_mcs_nss_3, vht_tx_mcs_nss_4, vht_tx_mcs_nss_5, vht_tx_mcs_nss_6, vht_tx_mcs_nss_7, vht_tx_mcs_nss_8;#endif /* CONFIG_VHT_OVERRIDES */ /** * ap_max_inactivity - Timeout in seconds to detect STA's inactivity * * This timeout value is used in AP mode to clean up inactive stations. * By default: 300 seconds. */ int ap_max_inactivity; /** * dtim_period - DTIM period in Beacon intervals * By default: 2 */ int dtim_period; /** * beacon_int - Beacon interval (default: 100 TU) */ int beacon_int; /** * auth_failures - Number of consecutive authentication failures */ unsigned int auth_failures; /** * disabled_until - Network block disabled until this time if non-zero */ struct os_time disabled_until; /** * parent_cred - Pointer to parent wpa_cred entry * * This pointer can be used to delete temporary networks when a wpa_cred * that was used to create them is removed. This pointer should not be * dereferences since it may not be updated in all cases. */ void *parent_cred;&#125;;]]></content>
      <categories>
        <category>网络</category>
        <category>WIFI</category>
      </categories>
      <tags>
        <tag>WIFI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下shell基础--获取脚本路径]]></title>
    <url>%2Fpost%2F12156.html</url>
    <content type="text"><![CDATA[在执行脚本时我们或多或少的都要知道当前所在的路径,或者脚本存放的路径,记录几个常用的获取路径的方法 脚本路径$(cd dirname $0;pwd) 获取当前脚本所在的绝对路径 1basepath=$(cd `dirname $0`; pwd) dirname $0 :取得当前执行脚本文件的父目录 pwd 获取当前执行脚本的所在的绝对路径 $(readlink -f $(dirname $0)) 获取当前脚本所在的相对路径` 测试 xxx:主机名 测试脚本 12345678910111213#!/bin/bashbasepath1=`pwd`basepath2=$(cd `dirname $0`; pwd)basepath3=$(readlink -f $(dirname $0))basepath4=$(dirname $0)basepath5=$(dirname $(readlink -f $0))echo &quot;basepath1= $basepath1&quot;echo &quot;basepath2= $basepath2&quot;echo &quot;basepath3= $basepath3&quot;echo &quot;basepath4= $basepath4&quot;echo &quot;basepath5= $basepath5&quot; 测试环境 12314:47 [xxx@xxx-pc]~/test=====&gt;$ls -l a.shlrwxrwxrwx 1 xxx xxx 13 11月 24 14:42 a.sh -&gt; aa/bb/cc/a.sh 执行脚本 123456714:48 [xxx@xxx-pc]~=====&gt;$./test/a.shbasepath1= /home/xxxbasepath2= /home/xxx/testbasepath3= /home/xxx/testbasepath4= ./testbasepath5= /home/xxx/test/aa/bb/cc readlink 用来找出符号链接所指向的位置 12$readlink .vimrc/home/xxx/.work_env/vim/vimrc -f: 递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码风格格式化--Astyle]]></title>
    <url>%2Fpost%2F62371.html</url>
    <content type="text"><![CDATA[Astyle是一个用来对C/C++代码进行格式化 文档: Artistic Style 3.1 安装1$sudo apt install astyle 预定风格12345678910111213141516171819202122232425262728293031323334353637default brace styleIf no brace style is requested, the opening braces will not bechanged and closing braces will be broken from the preceding line.--style=allman OR --style=bsd OR --style=break OR -A1Allman style formatting/indenting.Broken braces.--style=java OR --style=attach OR -A2Java style formatting/indenting.Attached braces.--style=kr OR --style=k&amp;r OR --style=k/r OR -A3Kernighan &amp; Ritchie style formatting/indenting.Linux braces....--style=gnu OR -A7GNU style formatting/indenting.Broken braces, indented blocks.--style=linux OR --style=knf OR -A8Linux style formatting/indenting.Linux braces, minimum conditional indent is one-half indent.--style=horstmann OR --style=run-in OR -A9Horstmann style formatting/indenting.Run-in braces, indented switches.--style=1tbs OR --style=otbs OR -A10One True Brace Style formatting/indenting.Linux braces, add braces to all conditionals.--style=google OR -A14Google style formatting/indenting.Attached braces, indented class modifiers. 使用1astyle --style=linux -n ./*.c --style=linux : linux风格缩进 -n : 不保存备份 12&gt;astyle --style=linux --indent=force-tab=4 --convert-tabs --pad-oper --unpad-paren --break-blocks=all --delete-empty-lines *.c *.h&gt; 递归格式化1astyle --style=linux --recursive *.c,*.h 必须中间加, 自定义规则 在--style=linux的基础上修改,只做必要改动 缩进Tab默认tab是4个空格. 1--indent=force-tab=# OR -T# 优先采用空格缩进, 这样配置后同vim中的tab缩进配置4个空格相同,格式化后的代码相当于vim中的gg=G switch缩进默认 操作符两边加空格1--pad-oper OR -p 删除括号()两边多余空格1--unpad-paren OR -U 空行分隔没有关系的块,类,标签(不包括函数块)1--break-blocks OR -f 空行分隔无关系的块,包括else catch等1--break-blocks=all OR -F 删除多余空行1--delete-empty-lines OR -x Tab转换为空格1--convert-tabs OR -c 参考 Astyle编程语言格式化工具的中文说明]]></content>
      <categories>
        <category>程序设计</category>
        <category>代码风格</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP之udhcpc]]></title>
    <url>%2Fpost%2F18609.html</url>
    <content type="text"><![CDATA[动态主机设置协议（英语：Dynamic Host Configuration Protocol，DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途： 用于内部网或网络服务供应商自动分配IP地址； 给用户用于内部网管理员作为对所有计算机作中央管理的手段。 DHCP从一个IP地址池中提供IP地址，该池有DHCP服务器数据库定义，称为scope。如果客户端接受这一地址，则它可在一个预定义的期限内使用该地址，称为租约。如果客户端无法从DHCP服务器获取IP地址，它就无法正常初始化TCP/IP。 DHCP采用的C/S架构,客户端有udhcpc udhcpcbusybox中提供的简易的udhcp client 文档:http://udhcp.busybox.net/README.udhcpc 1udhcpc -b -i eth0 -p /var/run/udhcpc.pid -b:切换到后台指令 -i:指定网络接口 -p:守护进程ID存储在文件中 -s:在DHCP的event中,执行脚本(default:/usr/share/udhcpc/default.script) udhcpc执行脚本12345678910111213141516171819202122232425262728293031323334#!/bin/sh[ -z &quot;$1&quot; ] &amp;&amp; echo &quot;Error: should be called from udhcpc&quot; &amp;&amp; exit 1RESOLV_CONF=&quot;/etc/resolv.conf&quot;[ -n &quot;$broadcast&quot; ] &amp;&amp; BROADCAST=&quot;broadcast $broadcast&quot;[ -n &quot;$subnet&quot; ] &amp;&amp; NETMASK=&quot;netmask $subnet&quot;case &quot;$1&quot; in deconfig) /sbin/ifconfig $interface 0.0.0.0 ;; renew|bound) /sbin/ifconfig $interface $ip $BROADCAST $NETMASK if [ -n &quot;$router&quot; ] ; then echo &quot;deleting routers&quot; while route del default gw 0.0.0.0 dev $interface ; do : done for i in $router ; do route add default gw $i dev $interface done fi echo -n &gt; $RESOLV_CONF [ -n &quot;$domain&quot; ] &amp;&amp; echo search $domain &gt;&gt; $RESOLV_CONF for i in $dns ; do echo adding dns $i echo nameserver $i &gt;&gt; $RESOLV_CONF done ;;esacexit 0 dhcpcd配置静态IP配置文件/etc/dhcpcd.conf 追加IP配置信息：1234interface eth0static ip_address=172.16.xx.xx/24 #配置IP地址 static routers=172.16.xx.xx #网关static domain_name_servers=172.16.xx.xx #DNS 参考 网络基本功（三十一）：细说DHCP]]></content>
      <categories>
        <category>网络</category>
        <category>DHCP</category>
      </categories>
      <tags>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下Anaconda环境搭建]]></title>
    <url>%2Fpost%2F65273.html</url>
    <content type="text"><![CDATA[Anaconda是Python的包管理器和环境管理器 优点: Anaconda附带了一大批常用数据科学包，它附带了conda、Python和 150 多个科学包及其依赖项 管理包. Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的, 包括安装、卸载和更新包 管理环境. 方便创建和使用不同python版本的虚拟环境 安装下载官网:https://www.anaconda.com/download/#linux 安装1bash Anaconda3-5.3.0-Linux-x86_64.sh 在安装的过程中，会问你安装路径(home目录下)，直接回车选择默认。有个地方问你是否将anaconda安装路径加入到环境变量（.bashrc)中，输入yes，默认的是no 如果选择了默认需要手动将anaconda的路径添加到环境变量 打开vi ~/.bashrc 添加anaconda的路径下的bin路径到PATH1export PATH=$PATH:$HOME/.tools/x86:$HOME/anaconda3/bin/ 安装完成后,需要重启终端或者source ~/.bashrc 检查安装是否成功which conda或conda –version12$conda --versionconda 4.5.11 使用命令–conda帮助12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$conda -husage: conda [-h] [-V] command ...conda is a tool for managing and deploying applications, environments and packages.Options:positional arguments: command clean Remove unused packages and caches. config Modify configuration values in .condarc. This is modeled after the git config command. Writes to the user .condarc file (/home/wqshao/.condarc) by default. create Create a new conda environment from a list of specified packages. help Displays a list of available conda commands and their help strings. info Display information about current conda install. install Installs a list of packages into a specified conda environment. list List linked packages in a conda environment. package Low-level conda package utility. (EXPERIMENTAL) remove Remove a list of packages from a specified conda environment. uninstall Alias for conda remove. See conda remove --help. search Search for packages and display associated information. The input is a MatchSpec, a query language for conda packages. See examples below. update Updates conda packages to the latest compatible version. This command accepts a list of package names and updates them to the latest versions that are compatible with all other packages in the environment. Conda attempts to install the newest versions of the requested packages. To accomplish this, it may update some packages that are already installed, or install additional packages. To prevent existing packages from updating, use the --no-update-deps option. This may force conda to install older versions of the requested packages, and it does not prevent additional dependency packages from being installed. If you wish to skip dependency checking altogether, use the &apos;--force&apos; option. This may result in an environment with incompatible packages, so this option must be used with great caution. upgrade Alias for conda update. See conda update --help.optional arguments: -h, --help Show this help message and exit. -V, --version Show the conda version number and exit.conda commands available from other packages: build convert develop env index inspect metapackage render server skeleton 查看已安装的库1$conda list 安装库1$conda install numpy 更新库1$conda update numpy 验证是否安装成功进入python环境使用import numpy进行验证,不报任何错误表示安装成功 1234567$python3.7Python 3.7.0 (default, Jun 28 2018, 13:15:42)[GCC 7.2.0] :: Anaconda, Inc. on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;&gt;&gt;&gt; import numpy&gt;&gt;&gt; Conda的环境管理虚拟环境Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。若需要安装Python3.6，此时，我们需要做的操作如下： 创建Python虚拟环境test，指定Python版本是3.6（不用管是3.6.x，conda会为我们自动寻找3.6.x中的最新版本） 1conda create -n test python=3.6 激活虚拟环境 1source activate test 关闭虚拟环境 1source deactivate zeronet 删除虚拟环境 1conda remove -n test --all 虚拟环境中安装额外的包 1conda install -n test [package] 参考 conda环境管理 conda命令：管理包、管理环境]]></content>
      <categories>
        <category>Python</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频流基础知识1-PSI/SI]]></title>
    <url>%2Fpost%2F10069.html</url>
    <content type="text"><![CDATA[在ts流转成es流的学习过程中,了解到PSI相关的基础知识在这里做一记录总结,方便以后查找和理解. 在数据传输前打包成MPEG-2的TS(传输流)包,这些TS包如果没有引导信息,接收端的解码器将无法找到需要的码流信息,因此MPEG-2专门定义了PSI(节目信息),PSI的作用自动设置和引导解码器进行解码 PSI/SI关键词 序号 关键字 全拼 翻译 备注 1 PSI Program Specific Information 节目引导信息 对单一码流的描述 2 SI Service Information 业务信息 对系统中所有码流的描述，包含了PSI（PSI+9张表） 3 TS包 Transport Packet 传输包 数字视音频、图文数据打包成TS包 4 TS Transport Stream 传输流（TS流） 一个频道（多个节目及业务）的TS包复用后称TS流 5 PAT Program Association Table 节目关联表 将节目号码和节目映射表PID相关联，获取数据的开始 6 PMT Program Map Table 节目映射表 指定一个或多个节目的PID 7 CAT Conditional Access Table 条件接收表 将一个或多个专用EMM流分别与唯一的PID相关联 8 NIT Network Information Table 网络信息表 描述整个网络，如多少TS流、频点和调制方式等信息 9 SDT Service Description Table 业务描述表 包含业务数据（如业务名称、起始时间、持续时间等） 10 BAT Bouquet Association Table 业务群关联表 给出业务群的名称及其业务列表等信息 11 EIT Event Information Table 事件信息表 包含事件或节目相关数据，是生成EPG的主要表 12 RST Running Status Table 运行状态表 给出事件的状态（运行/非运行） 13 TDT Time&amp;Date Table 时间和日期表 给出当前事件和日期相关信息，更新频繁 14 TOT Time Offset Table 时间偏移表 给出了当前时间日期与本地时间偏移的信息 15 ST Stuffing Table 填充表 用于使现有的段无效，如在一个传输系统的边界 16 SIT Stuffing Information Table 选择信息表 仅用于码流片段中，如记录的一段码流，包含描述该码流片段业务信息段的地方 17 DIT Discontinuity Information Table 间断信息表 仅用于码流片段，如记录的一段码流中，它将插入到码流片段业务信息间断的地方 PAT,PMT,CAT,NIT为PSI信息,由MPEG2标准定义,NIT是由SI标准规定 SDT,BAT,EIT,RST,TDT,TOT,ST,SIT,DIT为SI信息 业务(Service)与事件(Event)业务就是指“频道”，事件就是“节目”. 举个例子：CCTV1是一个频道，也就是我们所说的“业务（Service）”；《新闻联播》是一个节目，也就是我们所说的“事件(Event)”。 SI信息的构成 SI信息内容是按照network(网络)→transport strem（传输流）→service（业务）→event（事件）的分层顺序描述 为了能有效地从众多的数据包中组织起SI信息，而使用了很多的标识。有Network_id(网络标识)、 Original_network_id(原始网络标识)、Transport_stream_id(传输流标识)、Service id(业务标识)、eventid_id(事件标识)、Bouquet_id(业务群组标识)。 一个网络信息由network_id来定位。 一个TS由network_id、Original_network_id、Transport_stream_id来定位，标明这个流在那个网络播发，它原属那个网络，并给它加上标识。 一个业务由network_id、Original_network_id、Transport_stream_id、service_id来定位，标明这个业务在那个网络播发，它原属那个网络和那个流，并给它加上标识。这体现在SDT表中。 一个事件由network_id、Original_network_id、Transport_stream_id、service_id、event_id来定位，标明这个事件在那个网络播发，它原属那个网络和那个流及那个业务，并给它加上标识。这体现在EIT表中。 SI和SI信息的各种表的PID Table PID PAT 0x0000 CAT 0x0001 TSDT 0x0002 NIT,ST 0x0010 SDT,BAT,ST 0x0011 EIT,ST 0x0012 RST,ST 0x0013 TDT,TOT,ST 0x0014 DIT 0x001E SIT 0x001F 表 表是组成SI信息的一种数据结构。 由MPEG-2定义的TS里面，数据包携带了两类信息： 一是音、视频等素材的数据， 二是PSI表。 具有给定PID的数据包的有序排列就形成了TS 流。PSI表里的承载的内容主要是TS（本节目流）的描述参数。 由MPEG-2定义的PSI主要包含有三个表：PAT、PMT、CAT。每个表都可作为一个或多个TS包的净荷插入TS中传送。 一个TS数据包的净荷为188个字节，当一个PSI/SI表的字节长度大于184字节时，就要对这个表进行分割，形成段（section）来传送。分段机制主要是将一个数据表分割成多个数据段。在PSI/SI表到TS包的转换过程中，段起到了中介的作用。由于一个数据包只有188字节，而段的长度是可变的，EIT表的段限长4096字节，其余PSI/SI表的段限长为1024字节。因此，一个段要分成几部分插入到TS包的净荷中。 缩写 EPG(Electronic Program Guide) : 电子节目指南 参考 【PSI/SI学习系列】2.PSI/SI深入学习1——预备知识 PSI/SI解析（各种id说明） DVB-T Transport Stream :https://csie.ntut.edu.tw/labaspl/edu/MPEG2_TS(NCTU2)A.pdf]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频 PSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[码率,帧率,分辨率对视频画质的影响]]></title>
    <url>%2Fpost%2F60235.html</url>
    <content type="text"><![CDATA[在这几天的调试中降低码率和帧率后,将会减少延时和花屏的情况,主要是提高了解码的速度,但是对画质的影响,主要在于什么地方? 对帧率的修改,60fps降到25fps后,看到的显示效果没有变化,为什么?对用户体验的影响 用户体验: 只关系视频的画面质量,如果需要存储还需要关心视频文件的大小 流畅度: 主要受视频帧率(FPS)的影响 清晰度: 单位面积的画面所承载的信息，在对视频进行评价是就是当FPS和分辨率固定时，考察视频的清晰度。码率 分辨率: 视频画面的大小 码率 码率:比特率，英文为Bit Rate，是指每秒传送的比特(bit)数 码率影响视频清晰度 当比特率越大，视频清晰度就越高。其影响存在边际效应递减现象，并且存在上限（视频原始数据的画质）。 码率决定了视频大小视频大小size和码率BitRate的关系： size = $\dfrac{VideoDuration * BitRate}{8}$ 帧率—FPS FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数愈多，所显示的动作就会越流畅。 在游戏过程中一般人不觉得卡顿的FPS频率大约是30Hz，想要达到流畅等级则需要60Hz。 帧率对视频画质没有影响 帧率和视频大小正相关。视频大小和FPS/GOP_SIZE存在一定的线性相关性。 GOP_SIZE是ffmpeg中的一个编码参数，表示的每GOP_SIZE个帧存在一个关键帧。 在显示“分辨率”不变的情况下，FPS越高，则对显卡的处理能力要求越高。 分辨率分辨率对视频大小和画质有着非常重要的影响。 如果清晰度和流畅度不变，分辨与视频画质，大小正相关。但是前提条件是清晰度不变，单纯的增加分辨并不能带来更好的画质. 结果显示，同等分辨率的前提下，显示屏幕越大，主观感受越差。 参考 视频质量，分辨率以及码率之间的关系]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频 帧率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下批量文件处理-字符串替换]]></title>
    <url>%2Fpost%2F63603.html</url>
    <content type="text"><![CDATA[sed进行处理多文件中的字符串替换,可以快速的修改函数名或者变量名. sed1sed [-nefri] [动作] -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 -e ：直接在命令列模式上进行 sed 的动作编辑； -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作； -r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法) -i ：直接修改读取的文件内容，而不是输出到终端。 单文件替换1sed -i &apos;s/sockhandle/sock/g&apos; aa.c 多文件替换1grep &quot;sockhandle&quot; . -rl | xargs sed -i &apos;s/sockhandle/sock/g&apos; -rl: 列出文件内容符合指定的范本样式的文件名称 -rn: 在显示符合范本样式的那一列之前，标示出该列的列数编号]]></content>
      <categories>
        <category>shell</category>
        <category>字符串处理</category>
      </categories>
      <tags>
        <tag>Linux shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下去掉^M的方法]]></title>
    <url>%2Fpost%2F18189.html</url>
    <content type="text"><![CDATA[在linux下去掉文件行尾的^M 1cat -A filename 查看到windows下的断元字符^M dos2unix1dos2unix filename 多文件处理1ls ./*.c | xargs dos2unix sed1sed -i &apos;s/^M//g&apos; filename 或1sed -i &apos;s/\r//g&apos; filename 注意：^M的输入方式是 Ctrl + v ，然后Ctrl + M vi将两个命令合并成一个，并添加的vi的快捷键中。1nmap dm :%s/\r\+$//e&lt;cr&gt;:set ff=unix&lt;cr&gt; 用法： 打开文件直接敲dm即可，最后保存]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核数据结构--基础宏]]></title>
    <url>%2Fpost%2F56380.html</url>
    <content type="text"><![CDATA[在阅读内核源码时,存在一些基础的宏定义和函数,这里主要记录一下offsetof和container_of offsetof获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。 1#define offsetof(TYPE, MEMBER) ((size_t)&amp;((TYPE *)0)-&gt;MEMBER) From file:include/linux/stddef.h ((TYPE *)0):将零转型为TYPE类型指针，即TYPE类型的指针的地址是0。 ((TYPE *)0)-&gt;MEMBER:访问结构中的数据成员。 &amp;(((TYPE *)0)-&gt;MEMBER):取出数据成员的地址。由于TYPE的地址是0，这里获取到的地址就是相对MEMBER在TYPE中的偏移。 (size_t)(&amp;(((TYPE*)0)-&gt;MEMBER)): 结果转换类型。对于32位系统而言，size_t是unsigned int类型；对于64位系统而言，size_t是unsigned long类型。 示例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)struct student &#123; char gender; int id; int age; char name[20];&#125;;void main()&#123; int gender_offset, id_offset, age_offset, name_offset; gender_offset = offsetof(struct student, gender); id_offset = offsetof(struct student, id); age_offset = offsetof(struct student, age); name_offset = offsetof(struct student, name); printf("gender_offset = %d\n", gender_offset); printf("id_offset = %d\n", id_offset); printf("age_offset = %d\n", age_offset); printf("name_offset = %d\n", name_offset);&#125; 运行结果:1234gender_offset = 0id_offset = 4age_offset = 8name_offset = 12 图解 TYPE是结构体，它代表”整体”；而MEMBER是成员，它是整体中的某一部分。 将offsetof看作一个数学问题来看待，问题就相当简单了： 已知’整体’和该整体中’某一个部分’，而计算该部分在整体中的偏移。 container_of根据”结构体(type)变量”中的”域成员变量(member)的指针(ptr)”来获取指向整个结构体变量的指针。123#define container_of(ptr, type, member) (&#123; \ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) From file:include/linux/kernel.h typeof(((type *)0)-&gt;member): 取出member成员的变量类型。 const typeof(((type *)0)-&gt;member) *__mptr = (ptr): 定义变量__mptr指针，并将ptr赋值给__mptr。经过这一步, __mptr为member数据类型的常量指针，其指向ptr所指向的地址。 (char *)__mptr: 将__mptr转换为字节型指针。 offsetof(type,member)): 就是获取”member成员”在”结构体type”中的位置偏移。 (char *)__mptr - offsetof(type,member)): 就是用来获取”结构体type”的指针的起始地址（为char *型指针）。 (type *)((char *)__mptr - offsetof(type,member)): 就是将”char 类型的结构体type的指针”转换为”type 类型的结构体type的指针”。 示例12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// 获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)// 根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体变量的指针#define container_of(ptr, type, member) (&#123; \ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ (type *)( (char *)__mptr - offsetof(type,member) );&#125;)struct student &#123; char gender; int id; int age; char name[20];&#125;;void main()&#123; struct student stu; struct student *pstu; stu.gender = '1'; stu.id = 9527; stu.age = 24; strcpy(stu.name, "zhouxingxing"); // 根据"id地址" 获取 "结构体的地址"。 pstu = container_of(&amp;stu.id, struct student, id); // 根据获取到的结构体student的地址，访问其它成员 printf("gender= %c\n", pstu-&gt;gender); printf("age= %d\n", pstu-&gt;age); printf("name= %s\n", pstu-&gt;name);&#125; 运行结果:123gender= 1age= 24name= zhouxingxing 图解 type是结构体，它代表”整体”；而member是成员，它是整体中的某一部分，而且member的地址是已知的。将offsetof看作一个数学问题来看待，问题就相当简单了： 已知’整体’和该整体中’某一个部分’，要根据该部分的地址，计算出整体的地址。 参考 Linux内核中双向链表的经典实现]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核数据结构--链表]]></title>
    <url>%2Fpost%2F58180.html</url>
    <content type="text"><![CDATA[链表操作接口：include/linux/list.h 应用层编程使用mylist.h mylist.h 参考 list_for_each_entry 和 list_for_each_entry_safe函数分析 list_head结构体的理解]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[repo服务器的搭建测试]]></title>
    <url>%2Fpost%2F44256.html</url>
    <content type="text"><![CDATA[repo的作用就是进行多个git仓库的统一管理，其实repo就是一个python的脚本，这里测试repo服务的搭建和使用 下载repo1git clone https://review.mfunz.com/git-repo git-repo-core.git 服务端和客户端 服务端： git-repo-core 客户端： git-repo-core/repo 进入git-repo-core将repo拷贝到客户端或本地的/user/bin/下（或者自定义的目录下使用时通过绝对路径） 指定拷贝后客户端使用的repo中的REPO_URL变量为git-repo-core的路径（服务器将是IP:path）1REPO_URL = &apos;/home/xxx/test/repo-test/server/git-repo-core.git&apos; edit: vi client/repo 测试目录结构123456$tree -L 2.├── client│ └── repo└── server └── git-repo-core.git pwd:/home/xxx/test/repo-test repo服务器新建manifest仓库在server目录下创建1mkdir -p repos/manifest 在manifest目录下添加default.xml文件。123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;manifest&gt; &lt;remote name="origin" fetch="/home/xxx/test/repo-test/server/repos" /&gt; &lt;default remote="origin" revision="master" /&gt; &lt;project name="test1" path="test1"/&gt; &lt;project name="test2" path="test2"/&gt; &lt;project name="test3" path="tst333"/&gt;&lt;/manifest&gt; file: default.xml xml文件语法 remote: 设置服务器端的路径和名称 name: 服务器端名称 fetch：指repo仓库服务器端所在的位置，可以是远程，也可以是本地，测试使用本地123$ git remote -vorigin /home/xxx/test/repo-test/server/repos/test1 (fetch)origin /home/xxx/test/repo-test/server/repos/test1 (push) default: 设置服务器端名和分支名 remote: 服务器端名称（与remote中的name相同） revision: 分支名 sync-j： 指定在sync操作时的线程数，（sync-j=”4”） project: 设置repo管理的git仓库 name： git仓库服务端（远端）的名字 path： clone到本地的名字 revision： 指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit哈希值1&lt;project name=&quot;test1&quot; path=&quot;test1&quot; revision=&quot;088216c4e32e&quot;/&gt; 初始化仓库 进入manifest目录 123$ git init$ git add .$ git commit -m "init manifest" 返回manifest上一级目录 1$ git clone --bare manifest 新建完成manifest.git仓库后，manifest可以删除 123[xxx@xxx-pc]~/test/repo-test/server/repos=====&gt;$lsmanifest manifest.git 新建test1和test2仓库12345678$ mkdir test1 test2$ cd test1$ echo test1 &gt; readme.md$ git init$ git add .$ git commit -m "init test1"$ cd ..$ git clone --bare test1 test2仓库以相同的步骤建立 结果：123[xxx@xxx-pc]~/test/repo-test/server/repos=====&gt;$lsmanifest manifest.git test1 test1.git test2 test2.git test3 test3.git repo测试进入client目录 初始化 repo init12345678910111213141516171819202122232425$./repo init -u /home/xxx/test/repo-test/server/repos/manifest.gitGet /home/xxx/test/repo-test/server/git-repo-core.gitremote: Counting objects: 4050, done.remote: Compressing objects: 100% (1844/1844), done.remote: Total 4050 (delta 2144), reused 4050 (delta 2144)Receiving objects: 100% (4050/4050), 3.45 MiB | 31.58 MiB/s, done.Resolving deltas: 100% (2144/2144), done.From /home/xxx/test/repo-test/server/git-repo-core * [new branch] stable -&gt; origin/stable * [new tag] v1.0 -&gt; v1.0 ... * [new tag] v1.9.4 -&gt; v1.9.4 * [new tag] v1.9.5 -&gt; v1.9.5 * [new tag] v1.9.6 -&gt; v1.9.6Get /home/xxx/test/repo-test/server/repos/manifest.gitremote: Counting objects: 9, done. remote: Compressing objects: 100% (6/6), done. remote: Total 9 (delta 2), reused 0 (delta 0) From /home/xxx/test/repo-test/server/repos/manifest * [new branch] master -&gt; origin/masterYour identity is: xxx &lt;xxx@xx.com&gt;If you want to change this, please re-run 'repo init' with --config-namerepo has been initialized in /home/xxx/test/repo-test/client 同步代码 repo sync1234567891011$./repo syncFetching project test2remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) From /home/xxx/test/repo-test/server/repos/test2 * [new branch] master -&gt; origin/masterFetching project test1remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) From /home/xxx/test/repo-test/server/repos/test1 * [new branch] master -&gt; origin/master 下载目录12$lsrepo test1 test2 tst333 遍历repo每个仓库并执行相同代码 repo forall12345678910111213141516171819202122./repo forall -hUsage: repo forall [&lt;project&gt;...] -c &lt;command&gt; [&lt;arg&gt;...]repo forall -r str1 [str2] ... -c &lt;command&gt; [&lt;arg&gt;...]"Options: -h, --help show this help message and exit -r, --regex Execute the command only on projects matching regex or wildcard expression -i, --inverse-regex Execute the command only on projects not matching regex or wildcard expression -g GROUPS, --groups=GROUPS Execute the command only on projects matching the specified groups -c, --command Command (and arguments) to execute -e, --abort-on-errors Abort if a command exits unsuccessfully Output: -p Show project headers before output -v, --verbose Show command error messages -j JOBS, --jobs=JOBS number of commands to execute simultaneously 示例1234567891011=====&gt;$./repo forall -c "git log"commit 088216c4e32e0257ec23f2ac61c87866f8e8dd98 (HEAD, origin/master, m/master)Author: xxx &lt;xxx@xx.com&gt;Date: Thu Oct 11 20:04:17 2018 +0800 init test1commit c150415858ffbdfa7c010d35d66b6282cd7b3cbe (HEAD, origin/master, m/master)Author: xxx &lt;xxx@xx.com&gt;Date: Thu Oct 11 20:05:19 2018 +0800 init test2 repo支持命令1234567891011121314151617181920212223242526$./repo --traceusage: repo COMMAND [ARGS]The most commonly used repo commands are: abandon Permanently abandon a development branch branch View current topic branches branches View current topic branches checkout Checkout a branch for development cherry-pick Cherry-pick a change. diff Show changes between commit and working tree diffmanifests Manifest diff utility download Download and checkout a change grep Print lines matching a pattern info Get info on the manifest branch, current branch or unmerged branches init Initialize repo in the current directory list List projects and their associated directories overview Display overview of unmerged project branches prune Prune (delete) already merged topics rebase Rebase local branches on upstream branch smartsync Update working tree to the latest known good revision stage Stage file(s) for commit start Start a new branch for development status Show the working tree status sync Update working tree to the latest revision upload Upload changes for code reviewSee 'repo help &lt;command&gt;' for more information on a specific command.See 'repo help --all' for a complete list of recognized commands. 参考 本地/远程搭建repo 简易repo服务器搭建]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发相关记录]]></title>
    <url>%2Fpost%2F2578.html</url>
    <content type="text"><![CDATA[记录Android开发中遇到的一些方法和问题。 remount system分区可读可写 查看挂载点 12345678910111213141516# cat /proc/mounts rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,relatime,mode=600,ptmxmode=000 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0tmpfs /mnt/asec tmpfs rw,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,relatime,mode=755,gid=1000 0 0tmpfs /storage/external_storage tmpfs rw,relatime,mode=775,uid=1000,gid=1023 0 0adb /dev/usb-ffs/adb functionfs rw,relatime 0 0/dev/block/system /system ext4 ro,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0/dev/block/data /data ext4 rw,nosuid,nodev,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0/dev/block/cache /cache ext4 rw,nosuid,nodev,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/block/zram0 /swap_zram0 ext2 rw,relatime,errors=continue 0 0 重新挂载system分区 1# mount -o remount -rw /dev/block/system]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程--pthread]]></title>
    <url>%2Fpost%2F8868.html</url>
    <content type="text"><![CDATA[Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件&lt;pthread.h&gt;，链接时需要使用库libpthread.so。Linux下pthread的实现是通过系统调用clone()来实现的。 1gcc pthread_create.c -o pthread_create -lpthread pthread12345$ldd pthread_create linux-vdso.so.1 (0x00007fff45dfe000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5a42a08000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5a42617000) /lib64/ld-linux-x86-64.so.2 (0x00007f5a42e29000) 线程进程是程序执行时的一个实例，即它是程序已经执行到何种程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。 线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程由几个线程组成（拥有很多相对独立的执行流的用户程序共享应用程序的大部分数据结构），线程与同属一个进程的其他的线程共享进程所拥有的全部资源。 “进程——资源分配的最小单位，线程——程序执行的最小单位” 进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间） 优点： 提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。 使用多线程的理由 理由之一是和进程相比，它是一种非常”节俭”的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。 理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。 从函数调用上来说，进程创建使用fork()操作；线程创建使用clone()操作。Richard Stevens大师这样说过： fork is expensive. Memory is copied from the parent to the child, all descriptors are duplicated in the child, and so on. Current implementations use a technique called copy-on-write, which avoids a copy of the parent’s data space to the child until the child needs its own copy. But, regardless of this optimization, fork is expensive. IPC is required to pass information between the parent and child after the fork. Passing information from the parent to the child before the fork is easy, since the child starts with a copy of the parent’s data space and with a copy of all the parent’s descriptors. But, returning information from the child to the parent takes more work. Threads help with both problems. Threads are sometimes called lightweight processes since a thread is “lighter weight” than a process. That is, thread creation can be 10–100 times faster than process creation. All threads within a process share the same global memory. This makes the sharing of information easy between the threads, but along with this simplicity comes the problem of synchronization. pthread接口 #include &lt;pthread.h&gt; #/usr/include/pthread.h pthread_create1234567/* Create a new thread, starting with execution of START-ROUTINE getting passed ARG. Creation attributed come from ATTR. The new handle is stored in *NEWTHREAD. */extern int pthread_create (pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine) (void *), void *__restrict __arg) __THROWNL __nonnull ((1, 3)); 用于创建一个线程，成功返回0，否则返回Exxx（为正数）。 pthread_exit12345/* Terminate calling thread. The registered cleanup handlers are called via exception handling so we cannot mark this function with __THROW.*/extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__)); 用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。 pthread_join1234567/* Make calling thread wait for termination of the thread TH. The exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN is not NULL. This function is a cancellation point and therefore not marked with __THROW. */extern int pthread_join (pthread_t __th, void **__thread_return); 以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。 作用： 主线程等待子线程的终止 在子线程调用了pthread_join()`方法后面的代码，只有等到子线程结束了才能执行。 pthread_detach12345/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN. The resources of TH will therefore be freed immediately when it terminates, instead of waiting for another thread to perform PTHREAD_JOIN on it. */extern int pthread_detach (pthread_t __th) __THROW; 用于是指定线程变为分离状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。 pthread_self12/* Obtain the identifier of the current thread. */ extern pthread_t pthread_self (void) __THROW __attribute__ ((__const__)); 获取线程自身的ID，该id由线程库维护，其id空间是各个进程独立的（即不同进程中的线程可能有相同的id）。 比较两个线程ID123/* Compare two thread identifiers. */ extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) __THROW __attribute__ ((__const__)); 线程属性线程属性结构体pthread_attr_t 1234567891011typedef struct&#123; int etachstate; //线程的分离状态 int schedpolicy; //线程的调度策略 struct sched schedparam;//线程的调度参数 int inheritsched; //线程的继承性 int scope; //线程的作用域 size_t guardsize; //线程栈末尾的警戒缓冲区大小 int stackaddr_set; //线程栈的设置 void* stackaddr; //线程栈的启始位置 size_t stacksize; //线程栈大小&#125;pthread_attr_t; 操作接口函数： 123456789101112131415161718/* Initialize thread attribute *ATTR with default attributes (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER, no user-provided stack). */ extern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1)); /* Destroy thread attribute *ATTR. */ extern int pthread_attr_destroy (pthread_attr_t *__attr) __THROW __nonnull ((1)); /* Get detach state attribute. */ extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr, int *__detachstate) __THROW __nonnull ((1, 2)); /* Set detach state attribute. */ extern int pthread_attr_setdetachstate (pthread_attr_t *__attr, int __detachstate) __THROW __nonnull ((1)); 线程之间互斥互斥锁： 使用互斥锁（互斥）可以使线程按顺序执行。通常，互斥锁通过确保一次只有一个线程执行代码的临界段来同步多个线程。互斥锁还可以保护单线程代码。 1234567891011121314151617181920212223242526272829303132333435/* Mutex handling. *//* Initialize a mutex. */extern int pthread_mutex_init (pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) __THROW __nonnull ((1));/* Destroy a mutex. */extern int pthread_mutex_destroy (pthread_mutex_t *__mutex) __THROW __nonnull ((1));/* Try locking a mutex. */extern int pthread_mutex_trylock (pthread_mutex_t *__mutex) __THROWNL __nonnull ((1));/* Lock a mutex. */extern int pthread_mutex_lock (pthread_mutex_t *__mutex) __THROWNL __nonnull ((1));/* Unlock a mutex. */extern int pthread_mutex_unlock (pthread_mutex_t *__mutex) __THROWNL __nonnull ((1));/* Get the priority ceiling of MUTEX. */extern int pthread_mutex_getprioceiling (const pthread_mutex_t * __restrict __mutex, int *__restrict __prioceiling) __THROW __nonnull ((1, 2));/* Set the priority ceiling of MUTEX to PRIOCEILING, return old priority ceiling value in *OLD_CEILING. */extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) __THROW __nonnull ((1, 3)); 临界资源保护： 声明pthread_mutex_t类型的变量，并初始化pthread_mutex_init 对临界资源加锁pthread_mutex_lock 其他操作（Do something） 对临界资源解锁pthread_mutex_unlock 线程同步信号量： 使用条件变量（信号量）可以以原子方式阻塞线程，直到某个特定条件为真为止。条件变量始终与互斥锁一起使用。对条件的测试是在互斥锁（互斥）的保护下进行的。如果条件为假，线程通常会基于条件变量阻塞，并以原子方式释放等待条件变化的互斥锁。 12345678910111213141516171819202122232425262728293031323334353637383940/* Functions for handling conditional variables. *//* Initialize condition variable COND using attributes ATTR, or use the default values if later is NULL. */extern int pthread_cond_init (pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) __THROW __nonnull ((1));/* Destroy condition variable COND. */extern int pthread_cond_destroy (pthread_cond_t *__cond) __THROW __nonnull ((1));/* Wake up one thread waiting for condition variable COND. */extern int pthread_cond_signal (pthread_cond_t *__cond) __THROWNL __nonnull ((1));/* Wake up all threads waiting for condition variables COND. */extern int pthread_cond_broadcast (pthread_cond_t *__cond) __THROWNL __nonnull ((1));/* Wait for condition variable COND to be signaled or broadcast. MUTEX is assumed to be locked before. This function is a cancellation point and therefore not marked with __THROW. */extern int pthread_cond_wait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __nonnull ((1, 2));/* Wait for condition variable COND to be signaled or broadcast until ABSTIME. MUTEX is assumed to be locked before. ABSTIME is an absolute time specification; zero is the beginning of the epoch (00:00:00 GMT, January 1, 1970). This function is a cancellation point and therefore not marked with __THROW. */extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __nonnull ((1, 2, 3)); pthread_cond_wait用于等待某个特定的条件为真，pthread_cond_signal用于通知阻塞的线程某个特定的条件为真了。在调用者两个函数之前需要声明一个pthread_cond_t类型的变量，用于这两个函数的参数。 pthread_cond_wait只是唤醒等待某个条件变量的一个线程。如果需要唤醒所有等待某个条件变量的线程，需要调用：1int pthread_cond_broadcast (pthread_cond_t *__cond) pthread_barrier_xxx线程同步，pthread_barrier_*其实只做且只能做一件事，就是充当栏杆（barrier意为栏杆)。形象的说就是把先后到达的多个线程挡在同一栏杆前，直到所有线程到齐，然后撤下栏杆同时放行。 1234567891011121314/* Initialize BARRIER with the attributes in ATTR. The barrier is opened when COUNT waiters arrived. */ extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) __THROW __nonnull ((1)); /* Destroy a previously dynamically initialized barrier BARRIER. */ extern int pthread_barrier_destroy (pthread_barrier_t *__barrier) __THROW __nonnull ((1)); /* Wait on barrier BARRIER. */ extern int pthread_barrier_wait (pthread_barrier_t *__barrier) __THROWNL __nonnull ((1)); init函数负责指定要等待的线程个数 wait()函数由每个线程主动调用，它告诉栏杆“我到起跑线前了”。 wait(）执行末尾栏杆会检查是否所有人都到栏杆前了 如果是，栏杆就消失所有线程继续执行下一句代码 如果不是，则所有已到wait()的线程等待，剩下没执行到wait()的线程继续执行 destroy函数释放init申请的资源。 应用场景： 比如A和B两人相约在某一个地点C集合去打猎，A和B都知道地方C，但是他们到达的时间不确定，因此谁先到就需要在C点等。 pthread_once123456789/* Guarantee that the initialization function INIT_ROUTINE will be called only once, even if pthread_once is executed several times with the same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or extern variable initialized to PTHREAD_ONCE_INIT. The initialization functions might throw exception which is why this function is not marked with __THROW. */ extern int pthread_once (pthread_once_t *__once_control, void (*__init_routine) (void)) __nonnull ((1, 2)); pthread_once能够保证__init_routine只被调用一次，具体在哪个线程中执行是不定的 用法:12345pthread_once_t once=PTHREAD_ONCE_INIT;&#123; ... pthread_once(&amp;once,once_init_routine);&#125; 线程私有数据Thread Specific Data (TSD)在单线程程序中，我们经常使用 “全局变量” 以实现多个函数间共享数据，在多线程环境下，由于数据空间是共享的，因此全局变量也为所有线程所共享。但有时应用程序设计中有必要提供线程私有的全局变量，仅在某个线程中有效，但却可以跨多个函数访问 123456789101112131415161718192021/* Functions for handling thread-specific data. */ /* Create a key value identifying a location in the thread-specific data area. Each thread maintains a distinct thread-specific data area. DESTR_FUNCTION, if non-NULL, is called with the value associated to that key when the key is destroyed. DESTR_FUNCTION is not called if the value associated is NULL when the key is destroyed. */ extern int pthread_key_create (pthread_key_t *__key, void (*__destr_function) (void *)) __THROW __nonnull ((1)); /* Destroy KEY. */ extern int pthread_key_delete (pthread_key_t __key) __THROW; /* Return current value of the thread-specific data slot identified by KEY. */extern void *pthread_getspecific (pthread_key_t __key) __THROW; /* Store POINTER in the thread-specific data slot identified by KEY. */ extern int pthread_setspecific (pthread_key_t __key, const void *__pointer) __THROW ; 数据结构 /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h 12345678910111213141516171819202122232425262728293031323334353637/* Thread identifiers. The structure of the attribute type is not exposed on purpose. */ typedef unsigned long int pthread_t; /* Keys for thread-specific data */ typedef unsigned int pthread_key_t; /* Once-only execution */ typedef int __ONCE_ALIGNMENT pthread_once_t; union pthread_attr_t &#123; char __size[__SIZEOF_PTHREAD_ATTR_T]; long int __align; &#125;; #ifndef __have_pthread_attr_t typedef union pthread_attr_t pthread_attr_t; # define __have_pthread_attr_t 1 #endif typedef union &#123; struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; &#125; pthread_mutex_t; typedef union &#123; struct __pthread_cond_s __data; char __size[__SIZEOF_PTHREAD_COND_T]; __extension__ long long int __align; &#125; pthread_cond_t; 示例 pthread.c threadpool 参考 Linux多线程编程（不限Linux) pthreads 的基本用法]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket错误号]]></title>
    <url>%2Fpost%2F54884.html</url>
    <content type="text"><![CDATA[socket编程中的出现的错误号基本含义： 1234567#include &lt;errno.h&gt;...&#123; ... ret = sendto(fd, msg, msgLen, 0, (struct sockaddr*)&amp;un, size); printf("%d sendto errno:%d\n", getpid(), errno);&#125; 错误号—errno123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define NUM 135int main(void)&#123; int i; for (i = 0; i &lt; NUM; i++) &#123; printf("%d: %s\n", i, strerror(i)); &#125; return 0;&#125; 结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341350: Success1: Operation not permitted2: No such file or directory3: No such process4: Interrupted system call5: Input/output error6: No such device or address7: Argument list too long8: Exec format error9: Bad file descriptor10: No child processes11: Resource temporarily unavailable12: Cannot allocate memory13: Permission denied14: Bad address15: Block device required16: Device or resource busy17: File exists18: Invalid cross-device link19: No such device20: Not a directory21: Is a directory22: Invalid argument23: Too many open files in system24: Too many open files25: Inappropriate ioctl for device26: Text file busy27: File too large28: No space left on device29: Illegal seek30: Read-only file system31: Too many links32: Broken pipe33: Numerical argument out of domain34: Numerical result out of range35: Resource deadlock avoided36: File name too long37: No locks available38: Function not implemented39: Directory not empty40: Too many levels of symbolic links41: Unknown error 4142: No message of desired type43: Identifier removed44: Channel number out of range45: Level 2 not synchronized46: Level 3 halted47: Level 3 reset48: Link number out of range49: Protocol driver not attached50: No CSI structure available51: Level 2 halted52: Invalid exchange53: Invalid request descriptor54: Exchange full55: No anode56: Invalid request code57: Invalid slot58: Unknown error 5859: Bad font file format60: Device not a stream61: No data available62: Timer expired63: Out of streams resources64: Machine is not on the network65: Package not installed66: Object is remote67: Link has been severed68: Advertise error69: Srmount error70: Communication error on send71: Protocol error72: Multihop attempted73: RFS specific error74: Bad message75: Value too large for defined data type76: Name not unique on network77: File descriptor in bad state78: Remote address changed79: Can not access a needed shared library80: Accessing a corrupted shared library81: .lib section in a.out corrupted82: Attempting to link in too many shared libraries83: Cannot exec a shared library directly84: Invalid or incomplete multibyte or wide character85: Interrupted system call should be restarted86: Streams pipe error87: Too many users88: Socket operation on non-socket89: Destination address required90: Message too long91: Protocol wrong type for socket92: Protocol not available93: Protocol not supported94: Socket type not supported95: Operation not supported96: Protocol family not supported97: Address family not supported by protocol98: Address already in use99: Cannot assign requested address100: Network is down101: Network is unreachable102: Network dropped connection on reset103: Software caused connection abort104: Connection reset by peer105: No buffer space available106: Transport endpoint is already connected107: Transport endpoint is not connected108: Cannot send after transport endpoint shutdown109: Too many references: cannot splice110: Connection timed out111: Connection refused112: Host is down113: No route to host114: Operation already in progress115: Operation now in progress116: Stale file handle117: Structure needs cleaning118: Not a XENIX named type file119: No XENIX semaphores available120: Is a named type file121: Remote I/O error122: Disk quota exceeded123: No medium found124: Wrong medium type125: Operation canceled126: Required key not available127: Key has expired128: Key has been revoked129: Key was rejected by service130: Owner died131: State not recoverable132: Operation not possible due to RF-kill133: Memory page has hardware error134: Unknown error 134 宏定义 include/uapi/asm-generic/errno-base.h/_ASM_GENERIC_ERRNO_BASE_H include/uapi/asm-generic/errno.h/_ASM_GENERIC_ERRNO_H Linux内核中的位置 111： ECONNREFUSED A connect() on a stream socket found no one listening on the remote address. From: man connect 拒绝连接。一般发生在连接建立时 拔服务器端网线测试，客户端设置keep alive时，recv较快返回0， 先收到ECONNREFUSED (Connection refused)错误码，其后都是ETIMEOUT。 an error returned from connect(), so it can only occur in a client(if a client is defined as the party that initiates the connection 场景：使用UDP在进程间socket通信，sendto发送消息时，返回错误，错误号为111. 对端的socket没有进行接收所致。 115: EINPROGRESS The socket is nonblocking and the connection cannot be completed immediately. It is possible to select(2) or poll(2) for completion by selecting the socket for writing. After select(2) indicates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining the reason for the failure). From: man connect 非阻塞的socket，connect调用后立即返回，连接过程还在执行 场景： TCP连接中进行connect错误后，返回值：-1，错误号：115 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int connect_timeout(int fd, struct sockaddr_in *addr, unsigned int wait_seconds)&#123; int ret; socklen_t addrlen = sizeof(struct sockaddr_in); if (wait_seconds &gt; 0) activate_nonblock(fd); //设为非阻塞 ret = connect(fd, (struct sockaddr*)addr, addrlen); if (ret &lt; 0 &amp;&amp; errno == EINPROGRESS) &#123; struct timeval timeout; fd_set write_fdset; FD_ZERO(&amp;write_fdset); FD_SET(fd, &amp;write_fdset); timeout.tv_sec = wait_seconds; timeout.tv_usec = 0; do &#123; ret = select(fd + 1, NULL, &amp;write_fdset, NULL, &amp;timeout); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); if (ret == 0) &#123; ret = -1; errno = ETIMEDOUT; printf("%s:%d, select error[%d]:%s, ret=%d\n", __func__, __LINE__, errno, strerror(errno), ret); &#125; else if (ret &lt; 0) &#123; printf("%s:%d, select error[%d]:%s, ret=%d\n", __func__, __LINE__, errno, strerror(errno), ret); return -1; &#125; else if (ret == 1) &#123; int err; socklen_t socklen = sizeof(err); ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen); if (ret == -1) &#123; printf("%s:%d, getsockopt error[%d]:%s, ret=%d\n", __func__, __LINE__, errno, strerror(errno), ret); return -1; &#125; if (err == 0) &#123; ret = 0; //success &#125; else &#123; errno = err; ret = -1; printf("%s:%d, getsockopt error[%d]:%s, ret=%d\n", __func__, __LINE__, errno, strerror(errno), ret); &#125; &#125; &#125; if (wait_seconds &gt; 0) &#123; deactivate_nonblock(fd); //设回阻塞 &#125; return ret;&#125;int net_set_nonblocking(int sock) &#123; int flags, res; flags = fcntl(sock, F_GETFL, 0); if (flags &lt; 0) &#123; flags = 0; &#125; res = fcntl(sock, F_SETFL, flags | O_NONBLOCK); if (res &lt; 0) &#123; printf("fcntl return err:%d!\n", res); return -1; &#125; return 0; &#125; 4: EINTR123do &#123; n = recv(new_fd, buff, 500, 0); &#125; while (n &lt; 0 &amp;&amp; errno == EINTR); 34: ERANGE #define ERANGE 34 / Math result not representable / 结果无法表示 在socket连接中，server端关闭了该连接]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>错误号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言——锁]]></title>
    <url>%2Fpost%2F37537.html</url>
    <content type="text"><![CDATA[锁：原子锁, 线程安全 12345678910static int _a = 0;++_a;/* ++_a 大致可以拆分为下面三步(MIPS 指令) 1' 把 _a 的值放入`寄存器$1`中 【lw】 2' 把`寄存器$1`中值加1 【add】 3' 返回`寄存器$1`中值并且设置给a 【sw】 */ 自加1和自减1：在GCC中提供了相应的原子指令操作，排除多线程对一个变量的操作的不可预期性。 123456type __sync_fetch_and_add (type *ptr, type value, ...)type __sync_fetch_and_sub (type *ptr, type value, ...)type __sync_fetch_and_or (type *ptr, type value, ...)type __sync_fetch_and_and (type *ptr, type value, ...)type __sync_fetch_and_xor (type *ptr, type value, ...)type __sync_fetch_and_nand (type *ptr, type value, ...) 原子锁与自旋锁 原子锁和自旋锁的本质相同，通过对一个变量的自加和自减操作（这里的自加、自减都是通过一条原子指令完成），判断临界区的可操作性。 memory barriermemory barrier有几种类型： acquire barrier : 不允许将barrier之后的内存读取指令移到barrier之前（linux kernel中的wmb()）。 release barrier : 不允许将barrier之前的内存读取指令移到barrier之后 (linux kernel中的rmb())。 full barrier : 以上两种barrier的合集(linux kernel中的mb())。 1__sync_synchronize (...) GCC: This builtin issues a full memory barrier. 应用层：原子锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#ifndef _H_SIMPLEC_SCATOM#define _H_SIMPLEC_SCATOM#if defined(__GNUC__)// v += a ; return v;#define ATOM_ADD(v, a) __sync_add_and_fetch(&amp;(v), (a))// type tmp = v ; v = a; return tmp;#define ATOM_SET(v, a) __sync_lock_test_and_set(&amp;(v), (a))// v &amp;= a; return v;#define ATOM_AND(v, a) __sync_and_and_fetch(&amp;(v), (a))// return ++v;#define ATOM_INC(v) __sync_add_and_fetch(&amp;(v), 1)// return --v;#define ATOM_DEC(v) __sync_sub_and_fetch(&amp;(v), 1)// bool b = v == c; b ? v=a : ; return b;#define ATOM_CAS(v, c, a) __sync_bool_compare_and_swap(&amp;(v), (c), (a)) // 保证代码不乱序#define ATOM_SYNC() __sync_synchronize()// 对ATOM_LOCK 解锁, 当然 直接调用相当于 v = 0;#define ATOM_UNLOCK(v) __sync_lock_release(&amp;(v))#endif // __GNUC__/* * 试图加锁, 用法举例 if(ATOM_TRYLOCK(v)) &#123; // 已经有人加锁了, 处理返回事件 ... &#125; // 得到锁资源, 开始处理 ... ATOM_UNLOCK(v); * 返回1表示已经有人加锁了, 竞争锁失败. * 返回0表示得到锁资源, 竞争锁成功 */#define ATOM_TRYLOCK(v) ATOM_SET(v, 1)//// 使用方式:// int lock = 0;// ATOM_LOCK(lock);// ...// ATOM_UNLOCK(lock);//#define ATOM_LOCK(v) while(ATOM_SET(v, 1))#endif // !_H_SIMPLEC_SCATOM scatom.h 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/time.h&gt;#include "include/atom.h"int g_iFlagAtom = 0;#define WORK_SIZE 5000000#define WORKER_COUNT 10pthread_t g_tWorkerID[WORKER_COUNT];int g_iSum = 0;int lock = 0;void * thr_worker(void *arg)&#123; printf("WORKER THREAD %08X STARTUP\n", (unsigned int)pthread_self()); int i=0; for (i=0; i&lt;WORK_SIZE; ++i) &#123; if (g_iFlagAtom) &#123; ATOM_INC(g_iSum); &#125; else &#123; //ATOM_LOCK(lock); g_iSum ++; //ATOM_UNLOCK(lock); &#125; &#125; return NULL;&#125;void * thr_management(void *arg)&#123; printf("MANAGEMENT THREAD %08X STARTUP\n", (unsigned int)pthread_self()); int i; for (i=0;i&lt;WORKER_COUNT;++i) &#123; pthread_join(g_tWorkerID[i], NULL); &#125; printf("ALL WORKER THREADS FINISHED.\n"); return NULL;&#125;int main(int argc, const char* argv[])&#123; pthread_t tManagementID; int i=0; struct timeval start, end; gettimeofday(&amp;start, NULL); pthread_create (&amp;tManagementID, NULL, thr_management, NULL); for (i=0;i&lt;WORKER_COUNT;++i) &#123; pthread_create(&amp;g_tWorkerID[i], NULL, thr_worker, NULL); &#125; printf("CREATED %d WORKER THREADS\n", i); pthread_join(tManagementID, NULL); gettimeofday(&amp;end, NULL); printf("THE SUM: %d\n", g_iSum); printf("Run time: %ldms\n", 1000 * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1000); return 0;&#125; 结果 g_iSum++ 12THE SUM: 14617872Run time: 201ms ATOM_INC 12THE SUM: 50000000Run time: 1612ms ATOM_LOCK 12THE SUM: 50000000Run time: 11821ms 读写锁12345678910111213141516171819202122232425262728#ifndef _H_SIMPLEC_SCRWLOCK#define _H_SIMPLEC_SCRWLOCK#include "scatom.h"/* * create simple write and read lock * struct rwlock need zero. * is scatom ext */// init need all is 0struct rwlock &#123; int rlock; int wlock;&#125;;// add read lockextern void rwlock_rlock(struct rwlock * lock);// add write lockextern void rwlock_wlock(struct rwlock * lock);// add write lockextern void rwlock_unrlock(struct rwlock * lock);// unlock writeextern void rwlock_unwlock(struct rwlock * lock);#endif // !_H_SIMPLEC_SCRWLOCK 1234567891011121314151617181920212223242526272829303132333435363738// add read lockvoidrwlock_rlock(struct rwlock * lock) &#123; for (;;) &#123; // 看是否有人在试图读, 得到并防止代码位置优化 while (lock-&gt;wlock) ATOM_SYNC(); ATOM_INC(lock-&gt;rlock); // 没有写占用, 开始读了 if (!lock-&gt;wlock) break; // 还是有写, 删掉添加的读 ATOM_DEC(lock-&gt;rlock); &#125;&#125;// unlock read lockinline voidrwlock_unrlock(struct rwlock * lock) &#123; ATOM_DEC(lock-&gt;rlock);&#125;/ add write lockvoidrwlock_wlock(struct rwlock * lock) &#123; ATOM_LOCK(lock-&gt;wlock); // 等待读占用锁 while (lock-&gt;rlock) ATOM_SYNC();&#125;// unlock write lockinline voidrwlock_unwlock(struct rwlock * lock) &#123; ATOM_UNLOCK(lock-&gt;wlock);&#125; 参考 Built-in functions for atomic memory access 原子锁线程协程]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell获取git信息和编译时间]]></title>
    <url>%2Fpost%2F56769.html</url>
    <content type="text"><![CDATA[记录软件版本每一个编译的时间和log信息： 1234567891011#!/bin/shGIT_SHA1=`(git show-ref --head --hash=8 2&gt; /dev/null || echo 00000000) | head -n1`GIT_DIRTY=`git diff --no-ext-diff 2&gt; /dev/null | wc -l`BUILD_ID=`uname -n`"-"`date +%Y%m%d%H%M%S`test -f release.h || touch release.h(cat release.h | grep SHA1 | grep $GIT_SHA1) &amp;&amp; \(cat release.h | grep DIRTY | grep $GIT_DIRTY) &amp;&amp; exit 0 # Already up-to-dateecho "#define REDIS_GIT_SHA1 \"$GIT_SHA1\"" &gt; release.hecho "#define REDIS_GIT_DIRTY \"$GIT_DIRTY\"" &gt;&gt; release.hecho "#define REDIS_BUILD_ID \"$BUILD_ID\"" &gt;&gt; release.h#touch release.c # Force recompile of release.c 结果：123#define REDIS_GIT_SHA1 &quot;ed5b0648&quot;#define REDIS_GIT_DIRTY &quot;13&quot;#define REDIS_BUILD_ID &quot;xxxx-pc-20180918152335&quot; release.h]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本调试——bash]]></title>
    <url>%2Fpost%2F18379.html</url>
    <content type="text"><![CDATA[shell脚本调试： Bash帮助信息：1$bash -c &quot;help set&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081set: set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...] Set or unset values of shell options and positional parameters. Change the value of shell attributes and positional parameters, or display the names and values of shell variables. Options: -a Mark variables which are modified or created for export. -b Notify of job termination immediately. -e Exit immediately if a command exits with a non-zero status. -f Disable file name generation (globbing). -h Remember the location of commands as they are looked up. -k All assignment arguments are placed in the environment for a command, not just those that precede the command name. -m Job control is enabled. -n Read commands but do not execute them. -o option-name Set the variable corresponding to option-name: allexport same as -a braceexpand same as -B emacs use an emacs-style line editing interface errexit same as -e errtrace same as -E functrace same as -T hashall same as -h histexpand same as -H history enable command history ignoreeof the shell will not exit upon reading EOF interactive-comments allow comments to appear in interactive commands keyword same as -k monitor same as -m noclobber same as -C noexec same as -n noglob same as -f nolog currently accepted but ignored notify same as -b nounset same as -u onecmd same as -t physical same as -P pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status posix change the behavior of bash where the default operation differs from the Posix standard to match the standard privileged same as -p verbose same as -v vi use a vi-style line editing interface xtrace same as -x -p Turned on whenever the real and effective user ids do not match. Disables processing of the $ENV file and importing of shell functions. Turning this option off causes the effective uid and gid to be set to the real uid and gid. -t Exit after reading and executing one command. -u Treat unset variables as an error when substituting. -v Print shell input lines as they are read. -x Print commands and their arguments as they are executed. -B the shell will perform brace expansion -C If set, disallow existing regular files to be overwritten by redirection of output. -E If set, the ERR trap is inherited by shell functions. -H Enable ! style history substitution. This flag is on by default when the shell is interactive. -P If set, do not resolve symbolic links when executing commands such as cd which change the current directory. -T If set, the DEBUG trap is inherited by shell functions. -- Assign any remaining arguments to the positional parameters. If there are no remaining arguments, the positional parameters are unset. - Assign any remaining arguments to the positional parameters. The -x and -v options are turned off. Using + rather than - causes these flags to be turned off. The flags can also be used upon invocation of the shell. The current set of flags may be found in $-. The remaining n ARGs are positional parameters and are assigned, in order, to $1, $2, .. $n. If no ARGs are given, all shell variables are printed. Exit Status: Returns success unless an invalid option is given. -x: 执行过程中打印出执行的命令。 -v: 执行时打印脚本中的所有信息。 用法1$bash -x a.sh]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC编译器内部预宏定义]]></title>
    <url>%2Fpost%2F37120.html</url>
    <content type="text"><![CDATA[查看GCC编译器内部的预定义宏： 1gcc -E -dM - &lt;/dev/null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354$gcc --version gcc (Ubuntu 7.3.0-16ubuntu3) 7.3.0Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$gcc -E -dM - &lt;/dev/null#define __SSP_STRONG__ 3#define __DBL_MIN_EXP__ (-1021)#define __FLT32X_MAX_EXP__ 1024#define __UINT_LEAST16_MAX__ 0xffff#define __ATOMIC_ACQUIRE 2#define __FLT128_MAX_10_EXP__ 4932#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F#define __GCC_IEC_559_COMPLEX 2#define __UINT_LEAST8_TYPE__ unsigned char#define __SIZEOF_FLOAT80__ 16#define __INTMAX_C(c) c ## L#define __CHAR_BIT__ 8#define __UINT8_MAX__ 0xff#define __WINT_MAX__ 0xffffffffU#define __FLT32_MIN_EXP__ (-125)#define __ORDER_LITTLE_ENDIAN__ 1234#define __SIZE_MAX__ 0xffffffffffffffffUL#define __WCHAR_MAX__ 0x7fffffff#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1#define __GCC_ATOMIC_CHAR_LOCK_FREE 2#define __GCC_IEC_559 2#define __FLT32X_DECIMAL_DIG__ 17#define __FLT_EVAL_METHOD__ 0#define __unix__ 1#define __FLT64_DECIMAL_DIG__ 17#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2#define __x86_64 1#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL#define __SIG_ATOMIC_TYPE__ int#define __DBL_MIN_10_EXP__ (-307)#define __FINITE_MATH_ONLY__ 0#define __GNUC_PATCHLEVEL__ 0#define __FLT32_HAS_DENORM__ 1#define __UINT_FAST8_MAX__ 0xff#define __has_include(STR) __has_include__(STR)#define __DEC64_MAX_EXP__ 385#define __INT8_C(c) c#define __INT_LEAST8_WIDTH__ 8#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL#define __SHRT_MAX__ 0x7fff#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L#define __FLT64X_MAX_10_EXP__ 4932#define __UINT_LEAST8_MAX__ 0xff#define __GCC_ATOMIC_BOOL_LOCK_FREE 2#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128#define __UINTMAX_TYPE__ long unsigned int#define __linux 1#define __DEC32_EPSILON__ 1E-6DF#define __FLT_EVAL_METHOD_TS_18661_3__ 0#define __unix 1#define __UINT32_MAX__ 0xffffffffU#define __LDBL_MAX_EXP__ 16384#define __FLT128_MIN_EXP__ (-16381)#define __WINT_MIN__ 0U#define __linux__ 1#define __FLT128_MIN_10_EXP__ (-4931)#define __INT_LEAST16_WIDTH__ 16#define __SCHAR_MAX__ 0x7f#define __FLT128_MANT_DIG__ 113#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)#define __INT64_C(c) c ## L#define __DBL_DIG__ 15#define __GCC_ATOMIC_POINTER_LOCK_FREE 2#define __FLT64X_MANT_DIG__ 64#define __SIZEOF_INT__ 4#define __SIZEOF_POINTER__ 8#define __USER_LABEL_PREFIX__#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x#define __STDC_HOSTED__ 1#define __LDBL_HAS_INFINITY__ 1#define __FLT32_DIG__ 6#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F#define __SHRT_WIDTH__ 16#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L#define __STDC_UTF_16__ 1#define __DEC32_MAX__ 9.999999E96DF#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x#define __FLT32X_HAS_INFINITY__ 1#define __INT32_MAX__ 0x7fffffff#define __INT_WIDTH__ 32#define __SIZEOF_LONG__ 8#define __STDC_IEC_559__ 1#define __STDC_ISO_10646__ 201706L#define __UINT16_C(c) c#define __PTRDIFF_WIDTH__ 64#define __DECIMAL_DIG__ 21#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64#define __gnu_linux__ 1#define __INTMAX_WIDTH__ 64#define __has_include_next(STR) __has_include_next__(STR)#define __FLT64X_MIN_10_EXP__ (-4931)#define __LDBL_HAS_QUIET_NAN__ 1#define __FLT64_MANT_DIG__ 53#define __GNUC__ 7#define __pie__ 2#define __MMX__ 1#define __FLT_HAS_DENORM__ 1#define __SIZEOF_LONG_DOUBLE__ 16#define __BIGGEST_ALIGNMENT__ 16#define __FLT64_MAX_10_EXP__ 308#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)#define __INT_FAST32_MAX__ 0x7fffffffffffffffL#define __DBL_HAS_INFINITY__ 1#define __DEC32_MIN_EXP__ (-94)#define __INTPTR_WIDTH__ 64#define __FLT32X_HAS_DENORM__ 1#define __INT_FAST16_TYPE__ long int#define __LDBL_HAS_DENORM__ 1#define __FLT128_HAS_INFINITY__ 1#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL#define __INT_LEAST32_MAX__ 0x7fffffff#define __DEC32_MIN__ 1E-95DF#define __DBL_MAX_EXP__ 1024#define __WCHAR_WIDTH__ 32#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32#define __DEC128_EPSILON__ 1E-33DL#define __SSE2_MATH__ 1#define __ATOMIC_HLE_RELEASE 131072#define __PTRDIFF_MAX__ 0x7fffffffffffffffL#define __amd64 1#define __STDC_NO_THREADS__ 1#define __ATOMIC_HLE_ACQUIRE 65536#define __FLT32_HAS_QUIET_NAN__ 1#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL#define __SIZEOF_SIZE_T__ 8#define __FLT64X_MIN_EXP__ (-16381)#define __SIZEOF_WINT_T__ 4#define __LONG_LONG_WIDTH__ 64#define __FLT32_MAX_EXP__ 128#define __GCC_HAVE_DWARF2_CFI_ASM 1#define __GXX_ABI_VERSION 1011#define __FLT_MIN_EXP__ (-125)#define __FLT64X_HAS_QUIET_NAN__ 1#define __INT_FAST64_TYPE__ long int#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)#define __PIE__ 2#define __LP64__ 1#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x#define __DECIMAL_BID_FORMAT__ 1#define __FLT64_MIN_EXP__ (-1021)#define __FLT64_MIN_10_EXP__ (-307)#define __FLT64X_DECIMAL_DIG__ 21#define __DEC128_MIN__ 1E-6143DL#define __REGISTER_PREFIX__#define __UINT16_MAX__ 0xffff#define __DBL_HAS_DENORM__ 1#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32#define __UINT8_TYPE__ unsigned char#define __NO_INLINE__ 1#define __FLT_MANT_DIG__ 24#define __LDBL_DECIMAL_DIG__ 21#define __VERSION__ &quot;7.3.0&quot;#define __UINT64_C(c) c ## UL#define _STDC_PREDEF_H 1#define __GCC_ATOMIC_INT_LOCK_FREE 2#define __FLT128_MAX_EXP__ 16384#define __FLT32_MANT_DIG__ 24#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__#define __STDC_IEC_559_COMPLEX__ 1#define __FLT128_HAS_DENORM__ 1#define __FLT128_DIG__ 33#define __SCHAR_WIDTH__ 8#define __INT32_C(c) c#define __DEC64_EPSILON__ 1E-15DD#define __ORDER_PDP_ENDIAN__ 3412#define __DEC128_MIN_EXP__ (-6142)#define __FLT32_MAX_10_EXP__ 38#define __INT_FAST32_TYPE__ long int#define __UINT_LEAST16_TYPE__ short unsigned int#define __FLT64X_HAS_INFINITY__ 1#define unix 1#define __INT16_MAX__ 0x7fff#define __SIZE_TYPE__ long unsigned int#define __UINT64_MAX__ 0xffffffffffffffffUL#define __FLT64X_DIG__ 18#define __INT8_TYPE__ signed char#define __ELF__ 1#define __GCC_ASM_FLAG_OUTPUTS__ 1#define __FLT_RADIX__ 2#define __INT_LEAST16_TYPE__ short int#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L#define __UINTMAX_C(c) c ## UL#define __SSE_MATH__ 1#define __k8 1#define __SIG_ATOMIC_MAX__ 0x7fffffff#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2#define __SIZEOF_PTRDIFF_T__ 8#define __FLT32X_MANT_DIG__ 53#define __x86_64__ 1#define __FLT32X_MIN_EXP__ (-1021)#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF#define __INT_FAST16_MAX__ 0x7fffffffffffffffL#define __FLT64_DIG__ 15#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL#define __UINT_LEAST64_TYPE__ long unsigned int#define __FLT_HAS_QUIET_NAN__ 1#define __FLT_MAX_10_EXP__ 38#define __LONG_MAX__ 0x7fffffffffffffffL#define __FLT64X_HAS_DENORM__ 1#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL#define __FLT_HAS_INFINITY__ 1#define __UINT_FAST16_TYPE__ long unsigned int#define __DEC64_MAX__ 9.999999999999999E384DD#define __INT_FAST32_WIDTH__ 64#define __CHAR16_TYPE__ short unsigned int#define __PRAGMA_REDEFINE_EXTNAME 1#define __SIZE_WIDTH__ 64#define __SEG_FS 1#define __INT_LEAST16_MAX__ 0x7fff#define __DEC64_MANT_DIG__ 16#define __INT64_MAX__ 0x7fffffffffffffffL#define __UINT_LEAST32_MAX__ 0xffffffffU#define __SEG_GS 1#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32#define __GCC_ATOMIC_LONG_LOCK_FREE 2#define __SIG_ATOMIC_WIDTH__ 32#define __INT_LEAST64_TYPE__ long int#define __INT16_TYPE__ short int#define __INT_LEAST8_TYPE__ signed char#define __STDC_VERSION__ 201112L#define __DEC32_MAX_EXP__ 97#define __INT_FAST8_MAX__ 0x7f#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128#define __INTPTR_MAX__ 0x7fffffffffffffffL#define linux 1#define __FLT64_HAS_QUIET_NAN__ 1#define __FLT32_MIN_10_EXP__ (-37)#define __SSE2__ 1#define __FLT32X_DIG__ 15#define __LDBL_MANT_DIG__ 64#define __DBL_HAS_QUIET_NAN__ 1#define __FLT64_HAS_INFINITY__ 1#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)#define __code_model_small__ 1#define __k8__ 1#define __INTPTR_TYPE__ long int#define __UINT16_TYPE__ short unsigned int#define __WCHAR_TYPE__ int#define __SIZEOF_FLOAT__ 4#define __pic__ 2#define __UINTPTR_MAX__ 0xffffffffffffffffUL#define __INT_FAST64_WIDTH__ 64#define __DEC64_MIN_EXP__ (-382)#define __FLT32_DECIMAL_DIG__ 9#define __INT_FAST64_MAX__ 0x7fffffffffffffffL#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1#define __FLT_DIG__ 6#define __FLT32_HAS_INFINITY__ 1#define __FLT64X_MAX_EXP__ 16384#define __UINT_FAST64_TYPE__ long unsigned int#define __INT_MAX__ 0x7fffffff#define __amd64__ 1#define __INT64_TYPE__ long int#define __FLT_MAX_EXP__ 128#define __ORDER_BIG_ENDIAN__ 4321#define __DBL_MANT_DIG__ 53#define __SIZEOF_FLOAT128__ 16#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2#define __DEC64_MIN__ 1E-383DD#define __WINT_TYPE__ unsigned int#define __UINT_LEAST32_TYPE__ unsigned int#define __SIZEOF_SHORT__ 2#define __SSE__ 1#define __LDBL_MIN_EXP__ (-16381)#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64#define __WINT_WIDTH__ 32#define __INT_LEAST8_MAX__ 0x7f#define __FLT32X_MAX_10_EXP__ 308#define __SIZEOF_INT128__ 16#define __LDBL_MAX_10_EXP__ 4932#define __ATOMIC_RELAXED 0#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128#define _LP64 1#define __UINT8_C(c) c#define __FLT64_MAX_EXP__ 1024#define __INT_LEAST32_TYPE__ int#define __SIZEOF_WCHAR_T__ 4#define __UINT64_TYPE__ long unsigned int#define __FLT128_HAS_QUIET_NAN__ 1#define __INT_FAST8_TYPE__ signed char#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x#define __GNUC_STDC_INLINE__ 1#define __FLT64_HAS_DENORM__ 1#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32#define __DBL_DECIMAL_DIG__ 17#define __STDC_UTF_32__ 1#define __INT_FAST8_WIDTH__ 8#define __FXSR__ 1#define __DEC_EVAL_METHOD__ 2#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x#define __UINT32_C(c) c ## U#define __INTMAX_MAX__ 0x7fffffffffffffffL#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F#define __INT8_MAX__ 0x7f#define __LONG_WIDTH__ 64#define __PIC__ 2#define __UINT_FAST32_TYPE__ long unsigned int#define __CHAR32_TYPE__ unsigned int#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F#define __INT32_TYPE__ int#define __SIZEOF_DOUBLE__ 8#define __FLT_MIN_10_EXP__ (-37)#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64#define __INT_LEAST32_WIDTH__ 32#define __INTMAX_TYPE__ long int#define __DEC128_MAX_EXP__ 6145#define __FLT32X_HAS_QUIET_NAN__ 1#define __ATOMIC_CONSUME 1#define __GNUC_MINOR__ 3#define __INT_FAST16_WIDTH__ 64#define __UINTMAX_MAX__ 0xffffffffffffffffUL#define __DEC32_MANT_DIG__ 7#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x#define __DBL_MAX_10_EXP__ 308#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L#define __INT16_C(c) c#define __STDC__ 1#define __PTRDIFF_TYPE__ long int#define __ATOMIC_SEQ_CST 5#define __UINT32_TYPE__ unsigned int#define __FLT32X_MIN_10_EXP__ (-307)#define __UINTPTR_TYPE__ long unsigned int#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD#define __DEC128_MANT_DIG__ 34#define __LDBL_MIN_10_EXP__ (-4931)#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128#define __SIZEOF_LONG_LONG__ 8#define __FLT128_DECIMAL_DIG__ 36#define __GCC_ATOMIC_LLONG_LOCK_FREE 2#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x#define __LDBL_DIG__ 18#define __FLT_DECIMAL_DIG__ 9#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL#define __GCC_ATOMIC_SHORT_LOCK_FREE 2#define __INT_LEAST64_WIDTH__ 64#define __UINT_FAST8_TYPE__ unsigned char#define __ATOMIC_ACQ_REL 4#define __ATOMIC_RELEASE 3]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中__attribute__的作用]]></title>
    <url>%2Fpost%2F12087.html</url>
    <content type="text"><![CDATA[1234struct __attribute__ ((__packed__)) sc3 &#123; char a; char *b;&#125;; attribute：属性，主要是用来在函数或数据声明中设置其属性,与编译器相关 GNU C的一大特色就是__attribute__机制。__attribute__可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。 语法格式：1__attribute__ ((attribute-list)) attribute 数据声明： __attribute__ ((packed)): 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。 __attribute__((aligned(n))): 内存对齐，指定内存对齐n字节 函数声明： __attribute__((noreturn)): 的作用告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。 __attribute__((weak)): 虚函数，弱符号 用法packed1234567891011struct sc1 &#123; char a; char *b;&#125;;printf("sc1: sizeof-char* = %ld\n", sizeof(struct sc1));struct __attribute__ ((__packed__)) sc3 &#123; char a; char *b;&#125;;printf("sc3: packed sizeof-char* = %ld\n", sizeof(struct sc3)); 运行结果：12sc1: sizeof-char* = 16sc3: packed sizeof-char* = 9 该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。 aligned(n)12345678910111213141516171819202122struct __attribute__ ((aligned(4))) sc5 &#123; char a; char *b;&#125;;struct __attribute__ ((aligned(4))) sc6 &#123; char a; char b[];&#125;;printf("sc5: aligned 4 sizeof-char* = %ld\n", sizeof(struct sc5));printf("sc6: aligned 4 sizeof-char[] = %ld\n", sizeof(struct sc6));struct __attribute__ ((aligned(2))) sc7 &#123; char a; char *b;&#125;;struct __attribute__ ((aligned(2))) sc8 &#123; char a; char b[];&#125;;printf("sc7: aligned 2 sizeof-char* = %ld\n", sizeof(struct sc7));printf("sc8: aligned 2 sizeof-char[] = %ld\n", sizeof(struct sc8)); 运行结果：1234sc5: aligned 4 sizeof-char* = 16sc6: aligned 4 sizeof-char[] = 4sc7: aligned 2 sizeof-char* = 16sc8: aligned 2 sizeof-char[] = 2 noreturn This attribute tells the compiler that the function won’t ever return, and this can be used to suppress errors about code paths not being reached. The C library functions abort() and exit() are both declared with this attribute: 12extern void exit(int) __attribute__((noreturn));extern void abort(void) __attribute__((noreturn)); 函数不会返回。 weak12345int __attribute__((weak)) func(...)&#123; ... return 0;&#125; func转成弱符号类型 如果遇到强符号类型（即外部模块定义了func, extern int func(void);），那么我们在本模块执行的func将会是外部模块定义的func。 如果外部模块没有定义，那么将会调用这个弱符号，也就是在本地定义的func，直接返回了一个1（返回值视具体情况而定）相当于增加了一个默认函数。 原理：链接器发现同时存在弱符号和强符号，就先选择强符号，如果发现不存在强符号，只存在弱符号，则选择弱符号。如果都不存在：静态链接，恭喜，编译时报错，动态链接：对不起，系统无法启动。 weak属性只会在静态库(.o .a )中生效，动态库(.so)中不会生效。 参考 #define PACK_STRUCT attribute ((packed))编译器按字独立分配]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中char*和char[]的区别]]></title>
    <url>%2Fpost%2F44009.html</url>
    <content type="text"><![CDATA[char *c : char型指针，只表示所指向的内存单元 char [] : 表示数组型的内存单元 结论： char a[]或char a[0]形式的定义在结构体中不占内存大小。 以下所有测试在64bit系统中进行，结果与32bit系统存在差别。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int int_a; int* int_a_p; char char_b; char* char_b_p; printf("\tSystem Data Width:\n"); printf("sizeof int(%ld), int*(%ld), char(%ld), char*(%ld)\n", sizeof(int_a), sizeof(int_a_p), sizeof(char_b), sizeof(char_b_p)); char *c1 = "a b c d"; char c2[] = "a b c d"; printf("c1: %s\n", c1); printf("c2: %s\n", c2); printf("c1-c1[0]=%c\n", c1[0]); printf("c2-c2[0]=%c\n", c2[0]); //c1[0] = 'x'; /* Segmentation fault (core dumped) */ c2[0] = 'y'; printf("c1-c1[0]=%c\n", c1[0]); printf("c2-c2[0]=%c\n", c2[0]); struct sc1 &#123; char a; char *b; &#125;; struct sc2 &#123; char a; char b[]; &#125;; struct sc2_1 &#123; char a; char b[0]; &#125;; printf("sc1: sizeof-char* = %ld\n", sizeof(struct sc1)); //8 + 8 printf("sc2: sizeof-char[] = %ld\n", sizeof(struct sc2)); //1 printf("sc2_1: packed sizeof-char[0] = %ld\n", sizeof(struct sc2_1)); //1 struct __attribute__ ((__packed__)) sc3 &#123; char a; char *b; &#125;; struct __attribute__ ((__packed__)) sc4 &#123; char a; char b[]; &#125;; printf("sc3: packed sizeof-char* = %ld\n", sizeof(struct sc3)); //1 + 8 printf("sc4: packed sizeof-char[] = %ld\n", sizeof(struct sc4)); //1 return 0;&#125; 运行：12345678910111213System Data Width:sizeof int(4), int*(8), char(1), char*(8)c1: a b c dc2: a b c dc1-c1[0]=ac2-c2[0]=ac1-c1[0]=ac2-c2[0]=ysc1: sizeof-char* = 16sc2: sizeof-char[] = 1sc2_1: packed sizeof-char[0] = 1sc3: packed sizeof-char* = 9sc4: packed sizeof-char[] = 1 内存地址对比12345678910struct sc1 sc1_a; printf("\tsc1_a addr: %p\n", &amp;sc1_a); printf("\tsc1_a.a addr: %p\n", &amp;sc1_a.a); printf("\tsc1_a.b addr: %p\n", &amp;sc1_a.b); struct sc2 sc2_a, sc2_b; printf("\tsc2_a addr: %p\n", &amp;sc2_a); printf("\tsc2_a.a addr: %p\n", &amp;sc2_a.a); printf("\tsc2_a.b addr: %p\n", &amp;sc2_a.b); printf("\tsc2_b addr: %p\n", &amp;sc2_b); 运行结果：1234567sc1_a addr: 0x7ffd44ed7d60sc1_a.a addr: 0x7ffd44ed7d60sc1_a.b addr: 0x7ffd44ed7d68sc2_a addr: 0x7ffd44ed7d7esc2_a.a addr: 0x7ffd44ed7d7esc2_a.b addr: 0x7ffd44ed7d7fsc2_b addr: 0x7ffd44ed7d7f 在结构体中使用char buf[]形式的定义，不占用内存空间 应用内核部分结构体：如MMC中sdhci的结构体定义1234struct sdhci_host &#123; ... unsigned long private[0] ____cacheline_aligned;&#125;; 利于将自定义结构体部分和公共结构体之间相关联。 自定义结构体：123456789101112struct sdhci_custom &#123; int xxx;&#125;;struct sdhci_host *host;struct sdhci_custom *custom;//一次性申请内存看见host = kmalloc(sizeof(struct sdhci_host) + sizeof(struct sdhci_custom));//自定义结构体位置custom = host-&gt;private; 参考 ____cacheline_aligned和____cacheline_aligned_in_smp]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg学习笔记——ffmpeg命令]]></title>
    <url>%2Fpost%2F41754.html</url>
    <content type="text"><![CDATA[ffmpeg命令相关用法。 环境： ubuntu 18.04 ffmpeg版本： 3.4.4-0ubuntu0.18.04.1 制作ts流1ffmpeg -i test.mp4 -ss 00:00:12 -to 00:00:13 -vcodec libx264 -g 1 -crf 1 test.ts ts流中包含I帧 参数解析： -i： 设定输入流（input） -ss time_off： 开始时间 -to time_stop： 结束时间 -vcodec codec：设定视频编解码器，未设定时则使用与输入流相同的编解码器，(‘copy’ to copy stream) libx264： ts流 -g &lt;int&gt;：关键帧(I帧)间隔控制 -crf &lt;int&gt;：（Constant Rate Factor） 量化比例的范围为0~51，其中0为无损模式，23为缺省值，51可能是最差的。该数字越小，图像质量越好 1ffmpeg -i water.mp4 -codec copy -bsf:v h264_mp4toannexb water.ts 转H2641ffmpeg -i water.mp4 -c:v copy -bsf:v h264_mp4toannexb -an water.h264 wav转mp41ffmpeg -i water.wmv -c:v libx264 -strict -2 water.mp4 ffmpge帮助信息1ffmpeg -h full &gt; help.txt]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg学习笔记——颜色编码]]></title>
    <url>%2Fpost%2F49519.html</url>
    <content type="text"><![CDATA[颜色编码：YUV、RGB BT601 UV 的坐标图（量化后）： （横坐标为u，纵坐标为v，左下角为原点） U越大, 蓝色越蓝; V越大，红色越红 YUVYUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值（gray）；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 作用： 主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。 格式YUV Formats分成两个格式： 紧缩格式（packed formats）：将Y、U、V值储存成Macro Pixels阵列，和RGB的存放方式类似, 将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素（macro-pixel）。 平面格式（planar formats）：将Y、U、V的三个分量分别存放在不同的矩阵中, 使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。 采样方式主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0 YUV4:4:4:表示完全取样。 YUV4:2:2:表示2:1的水平取样，垂直完全采样。 YUV4:2:0:表示2:1的水平取样，垂直2：1采样。 黑点:表示采样该像素点的Y分量; 空心圆圈:表示采用该像素点的UV分量。 YUV 4:4:4采样，每一个Y对应一组UV分量， 每个像素32bit。 YUV 4:2:2采样，每两个Y共用一组UV分量， 每个像素16bit。 YUV 4:2:0采样，每四个Y共用一组UV分量， 每个像素16bit。 存储方式下面我用图的形式给出常见的YUV码流的存储方式，并在存储方式后面附有取样每个像素点的YUV数据的方法，其中，Cb、Cr的含义等同于U、V。 YUYV格式 （属于YUV422） YUV 4:2:2 1234start + 0: Y&apos;00 Cb00 Y&apos;01 Cr00 Y&apos;02 Cb01 Y&apos;03 Cr01start + 8: Y&apos;10 Cb10 Y&apos;11 Cr10 Y&apos;12 Cb11 Y&apos;13 Cr11start +16: Y&apos;20 Cb20 Y&apos;21 Cr20 Y&apos;22 Cb21 Y&apos;23 Cr21start +24: Y&apos;30 Cb30 Y&apos;31 Cr30 Y&apos;32 Cb31 Y&apos;33 Cr31 YUYV为YUV422采样的存储格式中的一种，相邻的两个Y共用其相邻的两个Cb、Cr，分析，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00，其他的像素点的YUV取值依次类推。 UYVY格式（属于YUV422）1234start + 0: Cb00 Y&apos;00 Cr00 Y&apos;01 Cb01 Y&apos;02 Cr01 Y&apos;03start + 8: Cb10 Y&apos;10 Cr10 Y&apos;11 Cb11 Y&apos;12 Cr11 Y&apos;13start +16: Cb20 Y&apos;20 Cr20 Y&apos;21 Cb21 Y&apos;22 Cr21 Y&apos;23start +24: Cb30 Y&apos;30 Cr30 Y&apos;31 Cb31 Y&apos;32 Cr31 Y&apos;33 每四字节代表两个像素，包含两个Y’，一个Cb和Cr。两个Y是两个像素的数据，而Cb和Cr对于两个像素来说都是一样的。如你所见，Cr和Cb部分只有相对于Y部分的一半竖向分辨率。 YV12，YU12格式（属于YUV420） YUV4:2:0 12345678start + 0: Y&apos;00 Y&apos;01 Y&apos;02 Y&apos;03start + 4: Y&apos;10 Y&apos;11 Y&apos;12 Y&apos;13start + 8: Y&apos;20 Y&apos;21 Y&apos;22 Y&apos;23start +12: Y&apos;30 Y&apos;31 Y&apos;32 Y&apos;33start +16: Cr00 Cr01 start +18: Cr10 Cr11 start +20: Cb00 Cb01 start +22: Cb10 Cb11 YU12和YV12属于YUV420格式，也是一种Plane模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00，其他依次类推。 NV12、NV21格式（属于YUV420） YUV4:2:0 123456start + 0: Y&apos;00 Y&apos;01 Y&apos;02 Y&apos;03start + 4: Y&apos;10 Y&apos;11 Y&apos;12 Y&apos;13start + 8: Y&apos;20 Y&apos;21 Y&apos;22 Y&apos;23start +12: Y&apos;30 Y&apos;31 Y&apos;32 Y&apos;33start +16: Cb00 Cr00 Cb01 Cr01start +20: Cb10 Cr10 Cb11 Cr11 NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。其提取方式与上一种类似，即Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00 存储空间假设，图片大小：w，h 这里的w和h，代表的是y在整个编码中的个数 YUV420 Y = w * h UV = (w * h)/2 所占内存：YUV = Y + UV = (w h 3) / 2 YUV422 所占内存：YUV = (w h) 2 RGBRGB： 三原色光模式（RGB color model），又称RGB颜色模型或红绿蓝颜色模型，是一种加色模型，将红（Red）、绿（Green）、蓝（Blue）三原色的色光以不同的比例相加，以产生多种多样的色光。(且三原色的红绿蓝不可能用其他单色光合成) 三原色光的相加：红光加绿光为黄光，黄光加蓝光为白光 RGB颜色查询对照表 RGB颜色查询对照表 格式 RGB565: 每个像素用16位表示，RGB分量分别使用5位、6位、5位 RGB555: 每个像素用16位表示，RGB分量都使用5位（剩下1位不用） RGB24: 每个像素用24位表示，RGB分量各使用8位 RGB32: 每个像素用32位表示，RGB分量各使用8位（剩下8位不用） ARGB32: 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值） 存储方式RGB565123high low7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0R R R R R G G G G G G B B B B B 123456789#define RGB565_MASK_RED 0xF800#define RGB565_MASK_GREEN 0x07E0#define RGB565_MASK_BLUE 0x001FR = (wPixel &amp; RGB565_MASK_RED) &gt;&gt; 11; // 取值范围0-31G = (wPixel &amp; RGB565_MASK_GREEN) &gt;&gt; 5; // 取值范围0-63B = wPixel &amp; RGB565_MASK_BLUE; // 取值范围0-31#define RGB(r,g,b) (unsigned int)( (r|0x08 &lt;&lt; 10) | (g|0x08 &lt;&lt; 5) | b|0x08 ) RGB5551X R R R R R G G G G G B B B B B RGB2412345typedef struct rgb24 &#123; unsigned char rgbtBlue; unsigned char rgbtGreen; unsigned char rgbtRed;&#125; RGB; RGB32123456typedef struct rgb32 &#123; unsigned char rgbBlue; unsigned char rgbGreen; unsigned char rgbRed; unsigned char rgbReserved;&#125; RGB； YUV模型和RGB模型的关系YUV色彩模型来源于RGB模型，该模型的特点是将亮度和色度分离开，从而适合于图像处理领域。 应用——模拟领域 123456Y&apos;= 0.299*R&apos; + 0.587*G&apos; + 0.114*B&apos;U&apos;= -0.147*R&apos; - 0.289*G&apos; + 0.436*B&apos; = 0.492*(B&apos;- Y&apos;)V&apos;= 0.615*R&apos; - 0.515*G&apos; - 0.100*B&apos; = 0.877*(R&apos;- Y&apos;)R&apos; = Y&apos; + 1.140*V&apos;G&apos; = Y&apos; - 0.394*U&apos; - 0.581*V&apos;B&apos; = Y&apos; + 2.032*U&apos; 应用——数字领域 123456Y’ = 0.257*R&apos; + 0.504*G&apos; + 0.098*B&apos; + 16Cb&apos; = -0.148*R&apos; - 0.291*G&apos; + 0.439*B&apos; + 128Cr&apos; = 0.439*R&apos; - 0.368*G&apos; - 0.071*B&apos; + 128R&apos; = 1.164*(Y’-16) + 1.596*(Cr&apos;-128)G&apos; = 1.164*(Y’-16) - 0.813*(Cr&apos;-128) - 0.392*(Cb&apos;-128)B&apos; = 1.164*(Y’-16) + 2.017*(Cb&apos;-128) YCbCr模型来源于YUV模型。YCbCr是 YUV 颜色空间的偏移版本. 上面各个符号都带了一撇，表示该符号在原值基础上进行了伽马校正,伽马校正有助于弥补在抗锯齿的过程中，线性分配伽马值所带来的细节损失，使图像细节更加丰富。在没有采用伽马校正的情况下，暗部细节不容易显现出来，而采用了这一图像增强技术以后，图像的层次更加明晰了。所以说H264里面的YUV应属于YCbCr. 参考 V4L2文档翻译（十） YUV与RGB互转各种公式 运用NEON指令集加速RGB与YUV相互转换]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg学习笔记——环境搭建]]></title>
    <url>%2Fpost%2F24238.html</url>
    <content type="text"><![CDATA[本地环境：ubuntu18.04 FFmpeg版本：3.4.4 环境搭建本地环境1sudo apt-get install -y nasm 编译FFmpeg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/bashPWD=`pwd`build_dir="ffmpeg"ffmpeg_version="n3.4.4"build_out="out"function local_env_prepare()&#123; sudo apt-get install -y nasm&#125;function ffmpeg_prepare()&#123; if [ ! -d $build_dir ]; then mkdir $build_dir fi echo "Download FFmpeg ..." if [ -f $&#123;PWD&#125;/$&#123;build_dir&#125;/$&#123;ffmpeg_version&#125;.tar.gz ]; then return 3 fi wget -P $build_dir https://github.com/FFmpeg/FFmpeg/archive/$&#123;ffmpeg_version&#125;.tar.gz tar zxvf $build_dir/$&#123;ffmpeg_version&#125;.tar.gz -C $build_dir&#125;function ffmpeg_build()&#123; local root_pwd=$PWD cd ./$&#123;build_dir&#125;/FFmpeg-$&#123;ffmpeg_version&#125; echo "Currect dir $PWD" if [ -d $&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125; ]; then return 4 fi ./configure --enable-shared --prefix=$&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125; echo "./configure --enable-shared --prefix=$&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125;" make make install cd -&#125;# main#local_env_prepareffmpeg_prepareif [ $? == 3 ]; then echo "FFmpeg Installation package [$&#123;ffmpeg_version&#125;.tar.gz] already exists" exit 1fiffmpeg_buildif [ $? == 4 ]; then echo "Already built exit !!!" exit 1fi 环境测试123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;#define __STDC_CONSTANT_MACROS extern "C" &#123;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"#include "libavutil/avutil.h"&#125;int main(int argc, char *argv[])&#123; cout &lt;&lt; "FFmpeg Test!" &lt;&lt; endl; av_register_all(); cout &lt;&lt; "FFmpeg version:" &lt;&lt; avcodec_version() &lt;&lt; endl; return 0;&#125; 所有代码：https://github.com/Winddoing/ffmpeg-study.git]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体硬件接口-HDMI、VGA]]></title>
    <url>%2Fpost%2F57610.html</url>
    <content type="text"><![CDATA[常用的多媒体硬件接口的特性和基本数据传输原理 HDMI H-High，D-Definition，M-Multimedia，I-Interface；高清晰度多媒体接口 硬件接口 19pin脚 TMDS data channels (6 pins) TMDS clock channel (2 pins) Consumer Electronics Control (CEC) (1 pin) Display Data Channel (DDC)(1 pin) +5V power (1 pin) Hot Plug Detect (1 pin) TMDS Shield Lines (4 pins designated in yellow) CEC/DDC Ground (1 pin) 逻辑接口 信号介绍： 4对TMDS差分信号：1对时钟+3对数据: TMDS通道0传输B信号，同时H信号和V信号也嵌入该通道 TMDS通道1传输G信号 TMDS通道2传输R信号，R和G通道的多余位置用来传输音频信号 CEC：消费电子控制通道，通过这条通道可以控制设备之间的交互 DDC：就是I²C信号，主要是获取显示器的基本信息(比如EDID信息) HPD：热插拔信号，该信号比较重要，当HPD引脚大于2V，TMDS才会输出。因此，如果屏幕没有显示，首先要测量该信号 DCC遵守的是I2C协议，EDID 存储在一个ROM 芯片中，HDMI协议规定ROM的I2C 地址必须是0xA0.电路设计中DDC端口上需要安装上拉电阻，电阻值最小要求达到1.3K。 CEC是一套完整的协议，电子设备可以借着CEC信号让用者可控制HDMI接口上所连接的装置。如单键播放(One Touch Play)，系统待机(System Standby)。 即是如果用者将影碟放进蓝光播放器时，电视会由于CEC信号的通知而自动开机，然后视频通道亦会自动切换到播放器连接的通道上。而当用者关掉电视时，CEC信号亦会通知HDMI相连接的装置一同进入待机。由于这样，所以就可以完全变成单一遥控器控制所有HDMI连接的装置。 HDMI接口中的数据信号采用的是S最小化传输差分信号协议。这种协议会将标准8bit数据转换为10bit信号，并且在转换过程中使用微分传送。 CECCEC是单总线协议，通过Phsical address Discovery Process机制来分配物理地址，DDC信号把物理地址传输到设备中。当一个带CEC功能的设备获取到一个物理地址的时候，他将进行以下处理： 主动申请分配与设备类型相应的逻辑地址 通过广播的方式来报告物理地址和对应的逻辑地址，实现绑定。 最大分辨率 接口所支持的协议不同，最大分辨率将不同 VGAVGA（Video Graphics Array）即视频图形阵列，是IBM在1987年随PS/2（PS/2 原是“Personal System 2”的意思，“个人系统2”. VGA接口就是显卡上面输出模拟信号的接口。VGA接口是一种D型接口，上面共有15针孔，分成3排，每排5个， DDC:Display Data Channel(显示数据通道)， 用于EDID信息的传送，其实就是I2C数据线。 信号VGA显示中，FPGA需要产生５个信号分别是：行同步信号HS、场同步信号VS、R、G、B三基色信号。 信号 定义 HS 行同步信号（3.3V） VS 场 / 帧 同步信号（3.3V） R 红基色 （0~0.714V 模拟信号） G 绿基色 （0~0.714V 模拟信号） B 蓝基色 （0~0.714V 模拟信号） 最大分辨率VGA接口所能支持的最大分辨率是2048X1536px DVIDVI（Digital Visual Interface），即数字视频接口. DVI是基于TMDS(Transition Minimized Differential Signaling)，转换最小差分信号技术来传输数字信号，TMDS运用先进的编码算法把8bit数据(R、G、B中的每路基色信号)通过最小转换编码为10bit数据(包含行场同步信息、时钟信息、数据DE、纠错等)，经过DC平衡后，采用差分信号传输数据，它和LVDS、TTL相比有较好的电磁兼容性能，可以用低成本的专用电缆实现长距离、高质量的数字信号传输。 分类 DVI-A（12+5） DVI-D（24+1/18+1）: 只有数字接口 DVI-I（24+5）: 有数字和模拟接口 最大分辨率 DVI-I单通道最大分辨率:1920x1200,60Hz DVI-I双通道最大分辨率:2560x1600,60Hz/1920x1200,120Hz DVI-D单通道最大分辨率:1920x1200,60Hz DVI-D双通道最大分辨率:2560x1600,60Hz/1920x1080,120Hz DPDisplayPort也是一种高清数字显示接口标准，可以连接电脑和显示器，也可以连接电脑和家庭影院。 参考 HDMI接口基础知识及硬件设计]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Socket recv —— Connection reset by peer (104)]]></title>
    <url>%2Fpost%2F33577.html</url>
    <content type="text"><![CDATA[1n = recv(socket_fd, buf, len, 0); 在接收数据时: 有时recv的返回值n&lt;0，错误码：104（Connection reset by peer），为啥？ 有时recv的返回值n=0,对端socket关闭，如果对端socket没有关闭，为啥n=0？ Connection reset by peer : (ECONNRESET 104)socket read/recv过程中，对方socket中断，read/recv会先返回已经发送的字节数,再次write时返回-1,errno号为ECONNRESET(104).即：read/recv 一个已收到RST的socket，系统会发SIGPIPE信号给该进程，如果将这个信号交给系统处理或者直接忽略掉了，read/recv都返回EPIPE错误.因此对于socket通信一定要捕获此信号，进行适当处理 ，否则程序的异常退出将会给你带来灾难。 The client’s call to readline may happen before the server’s RST is received by the client, or it may happen after.If the readline happens before the RST is received, as we’ve shown in our example, the result is an unexpected EOF in the client.But if the RST arrives first, the result is an ECONNRESET (&quot;Connection reset by peer&quot;) error return from readline.What happens if the client ignores the error return from readline and writes more data to the server?This can happen, for example, if the client needs to perform two writes to the server before reading anything back, with the first write eliciting the RST.The rule that applies is: When a process writes to a socket that has received an RST, the SIGPIPE signal is sent to the process.The default action of this signal is to terminate the process, so the process must catch the signal to avoid being involuntarily terminated.If the process either catches the signal and returns from the signal handler, or ignores the signal, the write operation returns EPIPE. tcp_syncookies在高并发的情况下，内核会认为系统受到了SYN flood攻击，会发送cookies（possible SYN flooding on port 80. Sending cookies），这样会减慢影响请求的速度，所以在应用服务武器上设置下这个参数为0禁用系统保护就可以进行大并发测试了。1net.ipv4.tcp_syncookies = 0 返回值: n==0TCP_NODELAY参考 TCP连接的状态详解以及故障排查 Linux网络编程socket错误分析 apache ab压力测试报错（apr_socket_recv: Connection reset by peer (104)） socket recv阻塞与非阻塞error总结]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频同步]]></title>
    <url>%2Fpost%2F56216.html</url>
    <content type="text"><![CDATA[音视频同步主要指两类： a. 同一设备播放音视频数据之间的同步 b. 不同设备（同一个音视频源通过组播播放）时，多个设备之间的音视频同步。（特例） 在使用组播进行多路投放时，视频数据画面同步，但是音频数据不同步，没有丢音效果。 同一设备标准规定在原始音频和视频流中,PTS的间隔不能超过0.7s，出现在TS包头的PCR间隔不能超过0.1s。 同步模式： 以音频为准 以视频为准 在音频和视频数据中的什么作为参考？？？ 不同设备 问题：实际视频投放中，视频画面同步，但是音频数据存在不同步现象。 音频产生不同步的可能性： 网络延时。 R端音频处理缓存区过大，数据处理之间存在时间差所致。 R端socket的接收buffer过大。 参考 FFmpeg学习6：视音频同步]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEC红外遥控协议]]></title>
    <url>%2Fpost%2F34467.html</url>
    <content type="text"><![CDATA[NEC 8位地址码，8位命令码 完整发射两次地址码和命令码，以提高可靠性 脉冲时间长短调制方式 38KHz载波频率 位时间1.12ms或2.25ms 参考 NEC Protocol NEC红外遥控协议理解与实现 红外遥控器工作原理]]></content>
  </entry>
  <entry>
    <title><![CDATA[IGMP snooping 查询器]]></title>
    <url>%2Fpost%2F51576.html</url>
    <content type="text"><![CDATA[IGMP在本地网络上的主机和路由器之间传达组成员信息，路由器定时向所有主机组多播IGMP查询。主机多播IGMP报告报文以响应查询。 123400:43:16.580029 IP (tos 0x0, ttl 1, id 0, offset 0, flags [DF], proto IGMP (2), length 28) 192.168.99.112 &gt; 224.0.0.1: igmp query v100:43:17.460173 IP (tos 0xc0, ttl 1, id 0, offset 0, flags [DF], proto IGMP (2), length 32, options (RA)) 192.168.99.64 &gt; 239.0.0.11: igmp v1 report 239.0.0.11 IGMPv1报文格式1234560 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+---------------------------------------------------------------|Version| Type | Unused | Checksum |+---------------------------------------------------------------| Group Address |+--------------------------------------------------------------- 字段 长度 描述 Version 4比特 IGMP版本号，在IGMPv1中应为0x1。 Type 4比特 即IGMP报文类型： 1 = Host Membership Query 主机成员查询; 2 = Host Membership Report 主机成员报告 Unused 8比特 未使用的字段，发送时必须填0，接收时忽略。 Checksum 16比特 IGMP消息的校验和。该字段在进行校验计算时设为0。当传送报文的时候，必须计算该校验字并插入到该字段中去。当接收包的时候，该校验字必须在处理该包之前进行检验。 Group Address 32比特 组播地址。 IGMPv1协议主要基于查询和响应机制完成组播组管理，支持查询和加入报文，处理过程与IGMPv2相同。IGMPv1与IGMPv2的不同之处是：主机离开组播组时不主动发送离开报文，收到查询消息后不反馈Report消息，待维护组成员关系的定时器超时后，路由器删除组记录。 协议栈结构123456789+-------------------------------+| IGMPv1 |+-------------------------------+| IP (Protocol = 0x02) |+-------------------------------+| L2 |+-------------------------------+| L1 |+-------------------------------+ IGMPv1消息封装在IP报文中。IP头部的Protocol字段值为0x02，用来标识数据部分封装了IGMP消息。 IP报文头的目的地址字段用来标识该IGMP消息的目的接收端。IP报文头的TTL字段值为1，表示IGMP消息只在本地网段传播。 格式：123456789101112131415 +---------------------+------------------------+ |type|code| cksum | group addr | +---------------------+------------------------+ ^ ^ | | | | +-------+ +----------+ | | | |+--------------------------------------------------------------+| | || IP首部 | || | |+-----------------------------------+--------------------------+&lt;------------------------ IP数据包 -------------------------&gt; 数据结构1234567891011121314151617181920212223242526struct igmp &#123; uint8_t igmp_type; /* IGMP type */ uint8_t igmp_code; /* routing code */ uint16_t igmp_cksum; /* checksum */ struct in_addr igmp_group; /* group address */ &#125;;/* * Message types, including version number. */ #define IGMP_MEMBERSHIP_QUERY 0x11 /* membership query */ #define IGMP_V1_MEMBERSHIP_REPORT 0x12 /* Ver. 1 membership report */ #define IGMP_V2_MEMBERSHIP_REPORT 0x16 /* Ver. 2 membership report */ #define IGMP_V2_LEAVE_GROUP 0x17 /* Leave-group message */ #define IGMP_DVMRP 0x13 /* DVMRP routing message */ #define IGMP_PIM 0x14 /* PIM routing message */ #define IGMP_TRACE 0x15 #define IGMP_MTRACE_RESP 0x1e /* traceroute resp.(to sender)*/ #define IGMP_MTRACE 0x1f /* mcast traceroute messages */ #define IGMP_MAX_HOST_REPORT_DELAY 10 /* max delay for response to */ /* query (in seconds) according */ /* to RFC1112 */ #define IGMP_TIMER_SCALE 10 /* denotes that the igmp code field */ /* specifies time in 10th of seconds */ /usr/include/netinet/igmp.h 校验：TCP、UDP、ICMP、IGMP包首部中的检验和都是针对整个包（首部和数据部分）做检验的。 IGMP_MEMBERSHIP_QUERY成员关系查询，RFC1075推荐多播路由器每120秒至少发布一次IGMP成员关系查询。把查询发给224.0.0.1组（所有主机组）。 IGMP_HOST_MEMEBER_REPORT &amp;&amp; IGMP_V2_MEMBERSHIP_REPORT成员关系报告 实现1234567891011121314151617uint16_t cksum(void *buf, size_t len)&#123; uint32_t cksum = 0; int i; int short_len = len / 2; for (i = 0; i &lt; short_len; i++) &#123; cksum += ((uint16_t*)buf)[i]; &#125; if (len % 2) &#123; cksum += ((uint8_t*)buf)[len - 1]; &#125; cksum = (cksum &gt;&gt; 16) + (cksum &amp; 0xFFFF); cksum = cksum + (cksum &gt;&gt; 16); return (~cksum &amp; 0xFFFF);&#125; IP数据报的检验和： 为了计算一份数据报的I P检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份I P数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。 1234567891011121314151617181920212223242526272829303132333435363738struct igmp igmp;struct in_addr mgroup, allhosts;struct sockaddr_in dst;/* Create socket */sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_IGMP);/* Multicast groups */mgroup.s_addr = inet_addr("0.0.0.0");if (mgroup.s_addr == INADDR_NONE) &#123; printf("Invalid multicast group '0.0.0.0'"); goto fail; &#125; allhosts.s_addr = inet_addr("224.0.0.1"); if (allhosts.s_addr == INADDR_NONE) &#123; printf("Invalid multicast group '224.0.0.1'"); goto fail; &#125; /* IGMPv1 query */ igmp.igmp_type = IGMP_MEMBERSHIP_QUERY; igmp.igmp_code = 0; igmp.igmp_cksum = 0; igmp.igmp_group = mgroup; igmp.igmp_cksum = cksum(&amp;igmp, sizeof(igmp)); /* Destination */ dst.sin_family = AF_INET; dst.sin_port = htons(0); dst.sin_addr = allhosts; /* Transmit loop */ while (1) &#123; if (sendto(sockfd, &amp;igmp, sizeof(igmp), 0, (struct sockaddr*)&amp;dst, sizeof(dst)) == -1) &#123; printf("Could not send IGMP query: %s", strerror(errno)); &#125; sleep(options-&gt;interval); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[socket编程--网站]]></title>
    <url>%2Fpost%2F23509.html</url>
    <content type="text"><![CDATA[一个有价值的网络编程的网站： https://www.winsocketdotnetworkprogramming.com/clientserversocketnetworkcommunication8chap.html The Tenouk’s Linux Socket (network) programming tutorialhttps://www.tenouk.com/cnlinuxsockettutorials.html ORYX embedded https://www.oryx-embedded.com 相关协议源码 源码目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[WIFI配置中涉及到的相关名词]]></title>
    <url>%2Fpost%2F1797.html</url>
    <content type="text"><![CDATA[AP配置中遇到的相关名词，作用及含义： AP模式: Access Point，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由/网桥工作在该模式下。AP和AP之间允许相互连接 sta模式: Station, 类似于无线终端，sta本身并不接受无线的接入，它可以连接到AP，一般无线网卡即工作在该模式 WMMWMM是一个英文缩写，是指Wi-Fi多媒体 u-apsdAAAAAA是认证（Authentication）、授权（Authorization）和计费（Accounting）的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和计费三种安全服务。 认证（Authentication）：是对用户的身份进行验证，判断其是否为合法用户。 授权（Authorization）：是对通过认证的用户，授权其可以使用哪些服务。 计费（Accounting）：是记录用户使用网络服务的资源情况，这些信息将作为计费的依据。 EDCA EDCA机制详解 频宽 （20MHz、40MHz、80MHz）指的是你的路由器的发射频率宽度， 也就是信道带宽。 频宽越大，传输中受到的干扰也就越大；但是频宽大时，数据传输带宽也会变大。 频宽 传输带宽 20MHz 65M 40MHz 150M 80MHz - 802.11acIEEE 802.11ac，是一个802.11无线局域网（WLAN）通信标准，它通过5GHz频带（也是其得名原因）进行通信。理论上，它能够提供最多1Gbps带宽进行多站式无线局域网通信，或是最少500Mbps的单一连接传输带宽。 穿透性5GHz信号的波长要比2.4GHz信号的要短，而波长越短的电磁波穿透力就越强。但因为 频率越高消耗在穿透上的能量越大，导致信号浪费，设备接受到的反而是反射衍射过来的信号。2.4Ghz下，衍射和反射比5Ghz要多，因此设备接受到的信号反而强。 协议标准 标准号 IEEE 802.11b IEEE 802.11a IEEE 802.11g IEEE 802.11n 标准发布时间 1999年9月 1999年9月 2003年6月 2009年9月 工作频率范围 2.4－2.4835GHz 5.150－5.350GHz 5.475－5.725GHz 5.725－5.850GHz 2.4－2.4835GHz 2.4－2.4835GHz 5.150－5.850GHz 非重叠信道数 3 24 3 15 物理速率（Mbps） 11 54 54 600 实际吞吐量（Mbps） 6 24 24 100以上 频宽（MHz） 20 20 20 20/40 调制方式 CCK/DSSS OFDM CCK/DSSS/OFDM MIMO-OFDM/DSSS/CCK 兼容性 802.11b 802.11a 802.11b/g 802.11a/b/g/n 2.4G频段WiFi总共有14个信道 IEEE 802.11b/g标准工作在2.4G频段，频率范围为2.400—2.4835GHz，共83.5M带宽 划分为14个子信道 每个子信道宽度为22MHz, 有效带宽为20MHz, 另外还有2MHz的强制隔离频带（类似于公路上的隔离带） 相邻信道的中心频点间隔5MHz 相邻的多个信道存在频率重叠(如1信道与2、3、4、5信道有频率重叠) 整个频段内只有3个（1、6、11）互不干扰信道 802.11b和802.11g的工作频段在2.4GHz（2.4GHz-2.4835GHz），其可用带宽为83.5MHz，中国划分为13个信道，每个信道带宽为22MHz 信道划分信道也称作通道(Channel)、频段，是以无线信号（电磁波）作为传输载体的数据信号传送通道。无线网络（路由器、AP热点、电脑无线网卡）可在多个信道上运行。在无线信号覆盖范围内的各种无线网络设备应该尽量使用不同的信道，以避免信号之间的干扰。 中心频率为2412MHz的1信道，其频率范围为2401~2423MHz freq = 2400 + 20/2 + 2 + 5 * (channel - 1) MHz 信道 中心频率 信道 中心频率 1 2412MHz 8 2447MHz 2 2417MHz 9 2452MHz 3 2422MHz 10 2457MHz 4 2427MHz 11 2462MHz 5 2432MHz 12 2467MHz 6 2437MHz 13 2472MHz 7 2442MHz - - 在WiFi的世界中，有一条原则雷打不动，那就是在同一信道范围内，同一时刻，只有一台设备可以发信号，其他设备都需要等待。 5G频段 freq = 5000 + 5 * channel 网络划分：在ISO/IEC 8802规范划分数据链路层（Data Link Layer）而得到的Logic Link Control Sub Layer（简称LLC）和Medium Acess Control Sub Layer（简称MAC）。 MAC Sub Layer（Media Acess Control SubLayer：媒介访问控制子层）：该子层的目的是为了解决局域网（Local Area Network，以后简写为LAN）中共用信道的使用产生竞争时，如何分配信道的使用权问题。目前LAN中常用的媒介访问控制方法是CSMA/CD（争用型介质访问控制）。由于无线网络的特殊性，MAC的控制方法略有不同。我们将在下文介绍相关内容。 LLC Sub Layer（逻辑链路控制子层）：该子层实现了两个站点之间帧的交换，实现端到端（源到目的），无差错的帧传输和应答功能及流量控制功能。 参考 WIFI的传输信道与标准WIFI的频道传输能力 《深入理解Android：Wi-Fi，NFC和GPS》章节连载[节选]–第三章 Wi-Fi基础知识 世界各个地区WIFI 2.4G及5G信道划分表（附无线通信频率分配表）]]></content>
      <categories>
        <category>网络</category>
        <category>WIFI</category>
      </categories>
      <tags>
        <tag>WIFI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方向]]></title>
    <url>%2Fpost%2F7367.html</url>
    <content type="text"><![CDATA[想升高。有两样东西，那就必须作鹰，或者作爬行动物。 ——巴尔扎克 新工作已经按个月了，与之前的工作方式和工作内容都有很大的差别。但是没有排斥的感觉，会有烦恼和抱怨，可是也有充实吧。 从底层到上层的工作，与之前设想的基本一致，上一份工作中对驱动的理解和对音频方面的工作，与新工作中视频的工作方向，打算以后的主要针对音视频方面发展。 优势： 底层驱动（存储，音频） 对linux系统和CPU的了解 底层程序的执行原理的认识[C和汇报（mips）了解] 劣势： 网络编程欠缺 应用层的软件开发欠缺 视频相关知识欠缺 方向：【音视频】 视频相关知识 视频的采集（V4L2） 视频编解码 设想：以底层为基础自下而上的接触和学习相关技能，完善自己的知识体系。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络-ping命令]]></title>
    <url>%2Fpost%2F51638.html</url>
    <content type="text"><![CDATA[判断网络的连通性和延时情况，通常使用ping命令。 ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。它是用来检查网络是否通畅或者网络连接速度的命令 ping12345678910$ping -helpUsage: ping [-aAbBdDfhLnOqrRUvV64] [-c count] [-i interval] [-I interface] [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline] [-W timeout] [hop1 ...] destinationUsage: ping -6 [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-p pattern] [-Q tclass] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline] [-W timeout] destination 参数 说明 -c ping的次数 -W 一次ping的超时时间 -s 发送数据包的大小，默认为32字节，最大可以定义到65500字节 实现网络上的机器都有唯一确定的IP地址，我们给目标IP地址发送一个数据包，对方就要返回一个同样大小的数据包，根据返回的数据包我们可以确定目标主机的存在，可以初步判断目标主机的操作系统等。 数据包12--&gt; 28 26.646884 192.168.100.3 192.168.100.2 ICMP 98 Echo (ping) request id=0xdc04, seq=0/0, ttl=64 (reply in 29)&lt;-- 29 26.646957 192.168.100.2 192.168.100.3 ICMP 98 Echo (ping) reply id=0xdc04, seq=0/0, ttl=64 (request in 28） 应用 判断本地tcp/ip协议是否正常 1ping 127.0.0.1 程序中判断网络连接情况 1234567891011121314151617181920for (i = 0; i &lt; MAX_S_CONNECT_NUM; i++) &#123; if (rIpList[i].valid == 1) &#123; retry_num = 5; memset(cmd, 0, 120 * sizeof(char)); sprintf(cmd, "ping %s -c 1 -W 1 &gt; /dev/null", rIpList[i].ipstr);retry: ret = system(cmd); if (ret != 0 &amp;&amp; retry_num) &#123; retry_num--; goto retry; &#125; if (ret != 0 || !retry_num) &#123; printf("ip: %s, disconnected retry:%d !!!\n", rIpList[i].ipstr, retry_num); VXLOG("ip: %s, disconnected retry:%d !!!\n", rIpList[i].ipstr, retry_num); rIpList[i].valid = 0; alive--; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RC电路]]></title>
    <url>%2Fpost%2F40769.html</url>
    <content type="text"><![CDATA[由电阻R和电容C组成的电路称为阻容电路，简称RC电路 RC串联电路RC并联电路RC 串并联电路参考 RC电路（一）RC串联、并联电路详解]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时钟线中串联电阻的作用--阻抗匹配]]></title>
    <url>%2Fpost%2F20813.html</url>
    <content type="text"><![CDATA[时钟线上接电阻，对整个电路的影响，和输出时钟的影响 如果阻抗不匹配会有什么不良后果呢？如果不匹配，则会形成反射，能量传递不过去，降低效率；会在传输线上形成驻波（简单的理解，就是有些地方信号强，有些地方信号弱），导致传输线的有效功率容量降低；功率发射不出去，甚至会损坏发射设备。 信号线电阻串联应用高速信号线中才考虑使用这样的电阻，在低频信号线，一般是直接连接； 作用： 第一:阻抗匹配。因为信号源的阻抗很低，跟信号线之间阻抗不匹配，串上一个电阻后，可改善匹配情况，以减少反射，避免振荡等； 第二：可以减少信号边沿的陡峭程度，从而减少高频噪声以及过冲等，因为串联的电阻，跟信号线的分布电容以及负载的输入电容等形成一个RC电路，这样就会降低信号边沿的陡峭程度，如果一个信号的边沿非常陡峭，含有大量的高频成分，将会辐射干扰，另外，也容易产生过冲； 阻抗匹配阻抗匹配是指信号源或者传输线跟负载之间的一种合适的搭配方式阻抗匹配分为低频和高频两种情况 先从直流电压源驱动一个负载入手。由于实际的电压源，总是有内阻的（请参看输出阻抗一问），我们可以把一个实际电压源，等效成一个理想的电压源跟一个电阻r串联的模型。 假设负载电阻为R，电源电动势为U，内阻为r，那么我们可以计算： 负载R的电流为：1I=U/(R+r) 负载电阻R越小，则输出电流越大。 负载R的电压为：1Uo=IR=U/[1+(r/R)] 负载电阻R越大，则输出电压Uo越高。 负载R消耗的功率为：123P=I^2×R=[U/(R+r)]^2×R=U^2×R/(R^2+2xR×r+r^2) =U^2×R/[(R-r)^2+4×R×r] =U^2/&#123;[(R-r)2/R]+4×r&#125; 对于一个给定的信号源，其内阻r是固定的，而负载电阻R则是由我们来选择的注意式中[(R-r)2/R]:当R=r时，[(R-r)2/R]可取得最小值0，这时负载电阻R上可获得最大输出功率Pmax=U^2/(4×r)即，当负载电阻跟信号源内阻相等时，负载可获得最大输出功率，这就是我们常说的阻抗匹配之一。 对于纯电阻电路，此结论同样适用于低频电路及高频电路，当交流电路中含有容性或感性阻抗时，结论有所改变，就是需要信号源与负载阻抗的实部相等，虚部互为相反数，这叫做共扼匹配； 在低频电路中，我们一般不考虑传输线的匹配问题，只考虑信号源跟负载之间的情况，因为低频信号的波长相对于传输线来说很长，传输线可以看成是“短线”，反射可以不考虑（可以这么理解：因为线短，即使反射回来，跟原信号还是一样的） 在高频电路中，我们还必须考虑反射的问题当信号的频率很高时，则信号的波长就很短，当波长短得跟传输线长度可以比拟时，反射信号叠加在原信号上将会改变原信号的形状，如果传输线的特征阻抗跟负载阻抗不相等（即不匹配）时，在负载端就会产生反射。 总结 如果是高速信号线上串小电阻，那就应该是终端阻抗匹配 如果是GPIO口上串了小电阻，很可能是抗小能量电压脉冲 参考 信号线时钟线地址线GPIO串联小电阻作用]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell字符串处理——配置文件获取版本号]]></title>
    <url>%2Fpost%2F35545.html</url>
    <content type="text"><![CDATA[字符串的截取和最后一个字符的删除 配置文件：123456software_version = xxxxxxx-V1.0.2hdmi_info=1920*1080p@60@48000wlan_ip= 0.0.0.0mac_address= 00:00:00:00:00:00encode_rate =8192wfd_mode_tcp =true 过滤脚本：1234CFGD_CONF="$&#123;OSDRV_DIR&#125;/conf/db/cfgd.conf" software_version=`grep "software_version" $&#123;VANXUM_CFGD_CONF&#125; | awk '&#123;sub(/.$/,"")&#125;1' | awk '&#123;print $3&#125;'` echo "current software_version: [$&#123;software_version&#125;]" awk &#39;{sub(/.$/,&quot;&quot;)}1&#39;: 去掉最后一个字符 awk &#39;{print $3}&#39;：输出版本号 直接使用grep得到的software_version这行最后一个字符是？，影响输出结果因此要去掉]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络带宽测试]]></title>
    <url>%2Fpost%2F21135.html</url>
    <content type="text"><![CDATA[iperf是一个网络性能测试工具。Iperf可以测试TCP和UDP带宽质量。Iperf可以测量最大TCP带宽，具有多种参数和UDP特性。 Iperf可以报告带宽，延迟抖动和数据包丢失。利用Iperf这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。 安装PC下载地址： here 交叉编译123456789101112131415161718#!/bin/bashIPERF_VERSION="3.1.3"ARM_GCC="arm-linux-gnueabihf-gcc"PWD=`pwd`wget https://iperf.fr/download/source/iperf-$&#123;IPERF_VERSION&#125;-source.tar.gztar zxvf iperf-$&#123;IPERF_VERSION&#125;-source.tar.gzcd iperf-$&#123;IPERF_VERSION&#125;/mkdir install./configure --host=arm-linux CC=$&#123;ARM_GCC&#125; --prefix=$&#123;PWD&#125;/installmakemake install iperf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# iperf --helpUsage: iperf [-s|-c host] [options] iperf [-h|--help] [-v|--version]Client/Server: -f, --format [kmKM] format to report: Kbits, Mbits, KBytes, MBytes -i, --interval # seconds between periodic bandwidth reports -l, --len #[KM] length of buffer to read or write (default 8 KB) -m, --print_mss print TCP maximum segment size (MTU - TCP/IP header) -o, --output &lt;filename&gt; output the report or error message to this specified file -p, --port # server port to listen on/connect to -u, --udp use UDP rather than TCP -w, --window #[KM] TCP window size (socket buffer size) -B, --bind &lt;host&gt; bind to &lt;host&gt;, an interface or multicast address -C, --compatibility for use with older versions does not sent extra msgs -M, --mss # set TCP maximum segment size (MTU - 40 bytes) -N, --nodelay set TCP no delay, disabling Nagle's Algorithm -V, --IPv6Version Set the domain to IPv6Server specific: -s, --server run in server mode -U, --single_udp run in single threaded UDP mode -D, --daemon run the server as a daemonClient specific: -b, --bandwidth #[KM] for UDP, bandwidth to send at in bits/sec (default 1 Mbit/sec, implies -u) -c, --client &lt;host&gt; run in client mode, connecting to &lt;host&gt; -d, --dualtest Do a bidirectional test simultaneously -n, --num #[KM] number of bytes to transmit (instead of -t) -r, --tradeoff Do a bidirectional test individually -t, --time # time in seconds to transmit for (default 10 secs) -F, --fileinput &lt;name&gt; input the data to be transmitted from a file -I, --stdin input the data to be transmitted from stdin -L, --listenport # port to receive bidirectional tests back on -P, --parallel # number of parallel client threads to run -T, --ttl # time-to-live, for multicast (default 1) -Z, --linux-congestion &lt;algo&gt; set TCP congestion control algorithm (Linux only)Miscellaneous: -x, --reportexclude [CDMSV] exclude C(connection) D(data) M(multicast) S(settings) V(server) reports -y, --reportstyle C report as a Comma-Separated Values -h, --help print this message and quit -v, --version print version information and quit[KM] Indicates options that support a K or M suffix for kilo- or mega-The TCP window size option can be set by the environment variableTCP_WINDOW_SIZE. Most other options can be set by an environment variableIPERF_&lt;long option name&gt;, such as IPERF_BANDWIDTH.Report bugs to &lt;iperf-users@lists.sourceforge.net&gt; 命令行选项 描述 -i, –interval 设置每次报告之间的时间间隔，单位为秒。如果设置为非零值，就会按照此时间间隔输出测试报告。默认值为零。 -l, –len #[KM] 设置读写缓冲区的长度。TCP方式默认为8KB，UDP方式默认为1470字节。 -p, –port 设置端口，与服务器端的监听端口一致。默认是5001端口，与ttcp的一样。 -u, –udp 使用UDP方式而不是TCP方式。参看-b选项。 Server -s, –server Iperf服务器模式 -c, –client host 如果Iperf运行在服务器模式，并且用-c参数指定一个主机，那么Iperf将只接受指定主机的连接。此参数不能工作于UDP模式。 Client -c, –client host 运行Iperf的客户端模式，连接到指定的Iperf服务器端。 -t, –time # 设置传输的总时间。Iperf在指定的时间内，重复的发送指定长度的数据包。默认是10秒钟。参考-l与-n选项。 -P, –parallel # 线程数。指定客户端与服务端之间使用的线程数。默认是1线程。需要客户端与服务器端同时使用此参数。 -d, –dualtest 运行双测试模式。这将使服务器端反向连接到客户端，使用-L 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。这些在操作的同时就立即完成了。如果你想要一个交互的测试，请尝试-r参数。 示例带宽测试通常采用UDP模式，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为100Mbps，先用-b 100M进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。 TCP服务器端：1iperf -s 客户端：1iperf -c 192.168.1.1 -t 60 在tcp模式下，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。 1iperf -c 192.168.1.1 -P 30 -t 60 客户端同时向服务器端发起30个连接线程。 1iperf -c 192.168.1.1 -d -t 60 进行上下行带宽测试。 UDP服务器端：1iperf -u -s 客户端：1iperf -u -c 192.168.1.1 -b 100M -t 60 在udp模式下，以100Mbps为数据发送速率，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。 1iperf -u -c 192.168.1.1 -b 5M -P 30 -t 60 客户端同时向服务器端发起30个连接线程，以5Mbps为数据发送速率。 1iperf -u -c 192.168.1.1 -b 100M -d -t 60 以100M为数据发送速率，进行上下行带宽测试。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM绘图--dot、uml]]></title>
    <url>%2Fpost%2F44070.html</url>
    <content type="text"><![CDATA[在整理软件逻辑和设计思路时，通过VIM进行画图记录。 DOT + graphviz: 结构图和流程图 plantuml: UML图 DrawIt: 简易图（ASCII） DOT + graphviz1vi aaa.dot 使用DOT语法，绘画 DOT语法graph（无向图）或者digraph（无向图）表示图，然后{}中的内容是对图的描述，注释风格和C类似（“//”用于单行注释，/**/用于多行注释）。如一个无向图：1234567891011121314151617181920//usr/bin/dot graph graph1 &#123; label = &quot;this is a graph&quot;; aa; bb; a -- b; &#123;p, q&#125; -- &#123;x, y&#125;; &#123;c, d&#125; -- o; o -- end [style = dotted, color = red]; subgraph subgraph1 &#123; label = &quot;This is subgraph&quot;; bgcolor = greenyellow; cc; dd; &#125; ccc -- ddd [label = &quot;test&quot;] &#125; Dot脚本语言语法整理 DOT + graphviz 轻松画图神器 Plantuml1vi aaa.uml 类图 时序图 流程图 DrawIt1234567+----------------+| |+-------+--------+| | || +--------+| | |+-------+--------+ 绘图–操作 :DIstart – 启动（默认虚线—-）:DIstop – 停止:DIdbl – 双实线(════):DInrml – 单虚线(—-):DIsngl – 单实现(────) 划线： 方向键（直线）；Page up、Page Down（斜线） 箭头： &lt;、&gt;、^、v 擦除： 空格切换]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>dot</tag>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TS流]]></title>
    <url>%2Fpost%2F36727.html</url>
    <content type="text"><![CDATA[TS流 数据结构TS头123456789101112// Transport packet headertypedef struct TS_packet_header&#123; unsigned sync_byte : 8; //同步字节, 固定为0x47,表示后面的是一个TS分组 unsigned transport_error_indicator : 1; //传输误码指示符 unsigned payload_unit_start_indicator : 1; //效荷载单元起始指示符 unsigned transport_priority : 1; //传输优先, 1表示高优先级,传输机制可能用到，解码用不着 unsigned PID : 13; //PID unsigned transport_scrambling_control : 2; //传输加扰控制 unsigned adaption_field_control : 2; //自适应控制 01仅含有效负载，10仅含调整字段，11含有调整字段和有效负载。为00解码器不进行处理 unsigned continuity_counter : 4; //连续计数器 一个4bit的计数器，范围0-15&#125; TS_packet_header; TS包的标识(即sync_byte)为0x47，并且为了确保这个TS包里的数据有效，所以我们一开始查找47 40 00这三组16进制数 包头大小: 4Byte adaption_field_control : 调整字段控制 0x00 : reserved for future use by ISO/IEC 0x01 : 无调整字段,仅含有效负载 0x10 : 仅含调整字段,无有效负载 0x11 : 调整字段后含有效负载123456789if (adaption_field_control == '10' || adaption_field_control == '11') &#123; adaption_fields() //调整字段的处理&#125;if (adaption_field_control == '01' || adaption_field_control == '11') &#123; for(i = 0; i &lt; N ; i++) //N值 = 184 - 调整字段的字节数 &#123; &#125;&#125; continuity_counter : 用于对传输误码进行检测。在发送端对所有的包都做0-15的循环计数，在接收终端，如发现循环计数器的值有中断，表明数据在传输中有丢失。 PAT123456789101112131415161718192021// Program Association Tabletypedef struct PAT_Packet_tag&#123; unsigned table_id : 8; //固定为0x00 ，标志是该表是PAT unsigned section_syntax_indicator : 1; //段语法标志位，固定为1 unsigned zero : 1; //0 unsigned reserved_1 : 2; //保留位 unsigned section_length : 12; //表示这个字节后面有用的字节数，包括CRC32 unsigned transport_stream_id : 16; //该传输流的ID，区别于一个网络中其它多路复用的流 unsigned reserved_2 : 2; //保留位 unsigned version_number : 5; //范围0-31，表示PAT的版本号 unsigned current_next_indicator : 1; //发送的PAT是当前有效还是下一个PAT有效 unsigned section_number : 8; //分段的号码。PAT可能分为多段传输，第一段为00，以后每个分段加1，最多可能有256个分段 unsigned last_section_number : 8; //最后一个分段的号码 // for(i=0; i&lt;N; i++) &#123; //N = (section_length - 4(CRC的4Byte) - 5(section_lengt以后的5Byte))/4 unsigned program_number : 16; unsigned reserved_3 : 3; unsigned network_PID : 16; // 或者program_map_PID // &#125; unsigned CRC_32 : 32;&#125; PAT_Packet; PMT123456789101112131415161718192021222324252627// Program Map Tabletypedef struct PMT_Packet_tag&#123; unsigned table_id : 8; unsigned section_syntax_indicator : 1; unsigned zero : 1; unsigned reserved_1 : 2; unsigned section_length : 12; unsigned program_number : 16; unsigned reserved_2 : 2; unsigned version_number : 5; unsigned current_next_indicator : 1; unsigned section_number : 8; unsigned last_section_number : 8; unsigned reserved_3 : 3; unsigned PCR_PID : 13; unsigned reserved_4 : 4; unsigned program_info_length : 12; // for(i=0; i&lt;N; i++) &#123; unsigned stream_type : 8; unsigned reserved_5 : 3; unsigned elementary_PID : 13; unsigned reserved_6 : 4; unsigned ES_info_length : 12; // &#125; unsigned CRC_32 : 32;&#125; PMT_Packet; 数据包123451 0.000000000 MPEG TS 188 Service Description Table (SDT)2 0.000055764 MPEG TS 188 Program Association Table (PAT)3 0.000111529 MPEG TS 188 Program Map Table (PMT)4 0.000167294 MPEG TS 188 [MP2T fragment of a reassembled packet]...... 开始时解析到的数据包:SDT-&gt;PAT-&gt;PMT SDT包只出现在TS文件的开头，而PAT和PMT包，每隔42Packet将出现一次。 SDT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Frame 1: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits) Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138) Arrival Time: Jan 1, 1970 08:00:00.000000000 CST [Time shift for this packet: 0.000000000 seconds] Epoch Time: 0.000000000 seconds [Time delta from previous captured frame: 0.000000000 seconds] [Time delta from previous displayed frame: 0.000000000 seconds] [Time since reference or first frame: 0.000000000 seconds] Frame Number: 1 Frame Length: 188 bytes (1504 bits) Capture Length: 188 bytes (1504 bits) [Frame is marked: False] [Frame is ignored: False] [Protocols in frame: mp2t:mpeg_sect:dvb_sdt]ISO/IEC 13818-1 PID=0x11 CC=0 Header: 0x47401110 0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47) .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0 .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1 .... .... ..0. .... .... .... .... .... = Transport Priority: 0 .... .... ...0 0000 0001 0001 .... .... = PID: Unknown (0x0011) .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0) .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1) .... .... .... .... .... .... .... 0000 = Continuity Counter: 0 [MPEG2 PCR Analysis] Pointer: 0DVB Service Description Table Table ID: Service Description Table (SDT), current network (0x42) 1... .... .... .... = Syntax indicator: 1 .111 .... .... .... = Reserved: 0x7 .... 0000 0010 0101 = Length: 37 Transport Stream ID: 0x0001 11.. .... = Reserved: 0x3 ..00 000. = Version Number: 0x00 .... ...1 = Current/Next Indicator: Currently applicable (1) Section Number: 0 Last Section Number: 0 Original Network ID: 0xff01 Reserved: 0xff Service 0x0001 Service ID: 0x0001 1111 11.. = Reserved: 0x3f .... ..0. = EIT Schedule Flag: 0 .... ...0 = EIT Present Following Flag: 0 100. .... .... .... = Running Status: Running (0x4) ...0 .... .... .... = Free CA Mode: Not Scrambled (0x0) .... 0000 0001 0100 = Descriptors Loop Length: 0x014 Descriptor Tag=0x48 Descriptor Tag: Service Descriptor (0x48) Descriptor Length: 18 Service Type: digital television service (0x01) Provider Name Length: 6 [Default character table (Latin)] Service Provider Name: FFmpeg Service Name Length: 9 [Default character table (Latin)] Service Name: Service01 CRC 32: 0x777c43ca [unverified] [CRC 32 Status: Unverified]Stuffing Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff... PAT123456789101112131415161718192021222324252627282930313233343536373839404142434445Frame 2: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits) Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138) Arrival Time: Jan 1, 1970 08:00:00.000055764 CST [Time shift for this packet: 0.000000000 seconds] Epoch Time: 0.000055764 seconds [Time delta from previous captured frame: 0.000055764 seconds] [Time delta from previous displayed frame: 0.000055764 seconds] [Time since reference or first frame: 0.000055764 seconds] Frame Number: 2 Frame Length: 188 bytes (1504 bits) Capture Length: 188 bytes (1504 bits) [Frame is marked: False] [Frame is ignored: False] [Protocols in frame: mp2t:mpeg_sect:mpeg_pat]ISO/IEC 13818-1 PID=0x0 CC=0 Header: 0x47400010 0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47) .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0 .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1 .... .... ..0. .... .... .... .... .... = Transport Priority: 0 .... .... ...0 0000 0000 0000 .... .... = PID: Program Association Table (0x0000) .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0) .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1) .... .... .... .... .... .... .... 0000 = Continuity Counter: 0 [MPEG2 PCR Analysis] Pointer: 0 //自适应区,1Byte,如果为0 表示没有自适应区MPEG2 Program Association Table Table ID: Program Association Table (PAT) (0x00) 1... .... .... .... = Syntax indicator: 1 .011 .... .... .... = Reserved: 0x3 .... 0000 0000 1101 = Length: 13 Transport Stream ID: 0x0001 11.. .... = Reserved: 0x3 ..00 000. = Version Number: 0x00 .... ...1 = Current/Next Indicator: Currently applicable Section Number: 0 Last Section Number: 0 Program 0x0001 -&gt; PID 0x1000 Program Number: 0x0001 111. .... .... .... = Reserved: 0x7 ...1 0000 0000 0000 = Program Map PID: 0x1000 CRC 32: 0x2ab104b2 [unverified] [CRC 32 Status: Unverified]Stuffing Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff... PMT1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Frame 3: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits) Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138) Arrival Time: Jan 1, 1970 08:00:00.000111529 CST [Time shift for this packet: 0.000000000 seconds] Epoch Time: 0.000111529 seconds [Time delta from previous captured frame: 0.000055765 seconds] [Time delta from previous displayed frame: 0.000055765 seconds] [Time since reference or first frame: 0.000111529 seconds] Frame Number: 3 Frame Length: 188 bytes (1504 bits) Capture Length: 188 bytes (1504 bits) [Frame is marked: False] [Frame is ignored: False] [Protocols in frame: mp2t:mpeg_sect:mpeg_pmt]ISO/IEC 13818-1 PID=0x1000 CC=0 Header: 0x47500010 0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47) .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0 .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1 .... .... ..0. .... .... .... .... .... = Transport Priority: 0 .... .... ...1 0000 0000 0000 .... .... = PID: Unknown (0x1000) .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0) .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1) .... .... .... .... .... .... .... 0000 = Continuity Counter: 0 [MPEG2 PCR Analysis] Pointer: 0MPEG2 Program Map Table Table ID: Program Map Table (PMT) (0x02) 1... .... .... .... = Syntax indicator: 1 .011 .... .... .... = Reserved: 0x3 .... 0000 0001 1101 = Length: 29 Program Number: 0x0001 11.. .... = Reserved: 0x3 ..00 000. = Version Number: 0x00 .... ...1 = Current/Next Indicator: Currently applicable (0x1) Section Number: 0 Last Section Number: 0 111. .... .... .... = Reserved: 0x7 ...0 0001 0000 0000 = PCR PID: 0x0100 1111 .... .... .... = Reserved: 0xf .... 0000 0000 0000 = Program Info Length: 0x000 Stream PID=0x0100 Stream type: AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video (0x1b) 111. .... .... .... = Reserved: 0x7 ...0 0001 0000 0000 = Elementary PID: 0x0100 1111 .... .... .... = Reserved: 0xf .... 0000 0000 0000 = ES Info Length: 0x000 Stream PID=0x0101 Stream type: ISO/IEC 11172 Audio (0x03) 111. .... .... .... = Reserved: 0x7 ...0 0001 0000 0001 = Elementary PID: 0x0101 1111 .... .... .... = Reserved: 0xf .... 0000 0000 0110 = ES Info Length: 0x006 Descriptor Tag=0x0a Descriptor Tag: ISO 639 Language Descriptor (0x0a) Descriptor Length: 4 ISO 639 Language Code: und ISO 639 Language Type: Undefined (0x00) CRC 32: 0x30afbe63 [unverified] [CRC 32 Status: Unverified]Stuffing Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff... packet12345678910111213141516171819202122232425262728293031323334353637Frame 4: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits) Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138) Arrival Time: Jan 1, 1970 08:00:00.000167294 CST [Time shift for this packet: 0.000000000 seconds] Epoch Time: 0.000167294 seconds [Time delta from previous captured frame: 0.000055765 seconds] [Time delta from previous displayed frame: 0.000055765 seconds] [Time since reference or first frame: 0.000167294 seconds] Frame Number: 4 Frame Length: 188 bytes (1504 bits) Capture Length: 188 bytes (1504 bits) [Frame is marked: False] [Frame is ignored: False] [Protocols in frame: mp2t]ISO/IEC 13818-1 PID=0x100 CC=0 Header: 0x47410030 0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47) .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0 .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1 .... .... ..0. .... .... .... .... .... = Transport Priority: 0 .... .... ...0 0001 0000 0000 .... .... = PID: Unknown (0x0100) .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0) .... .... .... .... .... .... ..11 .... = Adaptation Field Control: Adaptation Field and Payload (0x3) .... .... .... .... .... .... .... 0000 = Continuity Counter: 0 [MPEG2 PCR Analysis] Adaptation Field Length: 7 Adaptation Field 0... .... = Discontinuity Indicator: 0 .1.. .... = Random Access Indicator: 1 ..0. .... = Elementary Stream Priority Indicator: 0 ...1 .... = PCR Flag: 1 .... 0... = OPCR Flag: 0 .... .0.. = Splicing Point Flag: 0 .... ..0. = Transport Private Data Flag: 0 .... ...0 = Adaptation Field Extension Flag: 0 Program Clock Reference: 0x000000000132a20cReassembled in: 7139]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EDID]]></title>
    <url>%2Fpost%2F47714.html</url>
    <content type="text"><![CDATA[环境： ubuntu 18.04 EDID: Extended Display Identification Data edid读取工具： get-edid EDID的大小：VGA/DVI=128Byte; HDMI=256Byte get-edid1sudo apt-get install read-edid 获取EDID原始数据并存储到文件1sudo get-edid &gt; edid.bin 解析edid在线解析 在http://www.edidreader.com/网站可以对该数据进行在线解析。把以上128字节复制到该网站的对应数据窗口 本地解析1parse-edid &lt; edid.bin Window： EDID Manager下载：EDID Manager Window： EDID编辑下载：Phoenix EDID Designer 示例： Lenovo 1600x900 视频输出接口： VGA 12345678900000000: 003f 3f3f 3f3f 3f00 303f 3f65 0101 0101 .??????.0??e.... 00000010: 071a 0103 6c2c 1978 2e2c c5a4 5650 3f28 ....l,.x.,..VP?( 00000020: 0f50 543f 3f00 714f 3f3f 3f3f 3fc0 a9cf .PT??.qO?????... 00000030: 9500 0101 0101 302a 403f 603f 6430 1850 ......0*@?`?d0.P 00000040: 1300 3f3f 1000 001e 0000 003f 0055 3041 ..??.......?.U0A 00000050: 595a 3834 300a 2020 2020 0000 003f 0032 YZ840. ...?.2 00000060: 4b1e 5315 000a 2020 2020 2020 0000 003f K.S... ...? 00000070: 004c 454e 204c 5332 3033 3377 480a 0049 .LEN LS2033wH..I 00000080: 0a . EDID： 128-byte EDID successfully retrieved from i2c bus 0 解析：Edid Manager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127 Time: 11:22:16 Date: 2018年9月13日 EDID Manager Version: 1.0.0.14 ___________________________________________________________________ Block 0 (EDID Base Block), Bytes 0 - 127, 128 BYTES OF EDID CODE: 0 1 2 3 4 5 6 7 8 9 000 | 00 FF FF FF FF FF FF 00 30 AE 010 | A9 65 01 01 01 01 07 1A 01 03 020 | 6C 2C 19 78 2E 2C C5 A4 56 50 030 | A1 28 0F 50 54 AF EF 00 71 4F 040 | 81 80 81 8A A9 C0 A9 CF 95 00 050 | 01 01 01 01 30 2A 40 C8 60 84 060 | 64 30 18 50 13 00 B0 F0 10 00 070 | 00 1E 00 00 00 FF 00 55 30 41 080 | 59 5A 38 34 30 0A 20 20 20 20 090 | 00 00 00 FD 00 32 4B 1E 53 15 100 | 00 0A 20 20 20 20 20 20 00 00 110 | 00 FC 00 4C 45 4E 20 4C 53 32 120 | 30 33 33 77 48 0A 00 49(8-9) ID Manufacture Name : LEN(10-11) ID Product Code : 65A9(12-15) ID Serial Number : N/A(16) Week of Manufacture : 7(17) Year of Manufacture : 2016(18) EDID Version Number : 1(19) EDID Revision Number: 3(20) Video Input Definition: Analog 0.700, 0.000 (0.700 V p-p) Separate SyncsComposite Syncs(21) Maximum Horizontal Image Size: 44 cm(22) Maximum Vertical Image Size : 25 cm(23) Display Gamma : 2.20(24) Power Management and Supported Feature(s): Active Off/Very Low Power, RGB Color, sRGB, Preferred Timing Mode(25-34) Color Characteristics Red Chromaticity : Rx = 0.641 Ry = 0.338 Green Chromaticity : Gx = 0.315 Gy = 0.625 Blue Chromaticity : Bx = 0.159 By = 0.055 Default White Point: Wx = 0.313 Wy = 0.329(35) Established Timings I 720 x 400 @ 70Hz (IBM, VGA) 640 x 480 @ 60Hz (IBM, VGA) 640 x 480 @ 72Hz (VESA) 640 x 480 @ 75Hz (VESA) 800 x 600 @ 56Hz (VESA) 800 x 600 @ 60Hz (VESA)(36) Established Timings II 800 x 600 @ 72Hz (VESA) 800 x 600 @ 75Hz (VESA) 832 x 624 @ 75Hz (Apple, Mac II) 1024 x 768 @ 60Hz (VESA) 1024 x 768 @ 70Hz(VESA) 1024 x 768 @ 75Hz (VESA) 1280 x 1024 @ 75Hz (VESA)(37) Manufacturer&apos;s Timings (Not Used)(38-53) Standard Timings 1152x864 @ 75 Hz (4:3 Aspect Ratio) 1280x1024 @ 60 Hz (5:4 Aspect Ratio) 1280x1024 @ 70 Hz (5:4 Aspect Ratio) 1600x900 @ 60 Hz (16:9 Aspect Ratio) 1600x900 @ 75 Hz (16:9 Aspect Ratio) 1440x900 @ 60 Hz (16:10 Aspect Ratio)(54-71) Detailed Descriptor #1: Preferred Detailed Timing (1600x900 @ 60Hz) Pixel Clock : 108 MHz Horizontal Image Size : 432 mm Vertical Image Size : 240 mm Refresh Mode : Non-interlaced Normal Display, No Stereo Horizontal: Active Time : 1600 Pixels Blanking Time : 200 Pixels Sync Offset : 24 Pixels Sync Pulse Width: 80 Pixels Border : 0 Pixels Frequency : 60 kHz Vertical: Active Time : 900 Lines Blanking Time : 100 Lines Sync Offset : 1 Lines Sync Pulse Width: 3 Lines Border : 0 Lines Digital Separate, Horizontal Polarity (+), Vertical Polarity (+) Modeline: &quot;1600x900&quot; 108.000 1600 1624 1704 1800 900 901 904 1000 +hsync +vsync(72-89) Detailed Descriptor #2: Monitor Serial Number Monitor Serial Number: U0AYZ840(90-107) Detailed Descriptor #3: Monitor Range Limits Horizontal Scan Range: 30kHz-83kHz Vertical Scan Range : 50Hz-75Hz Supported Pixel Clock: 210 MHz Secondary GTF : Not Supported(108-125) Detailed Descriptor #4: Monitor Name Monitor Name: LEN LS2033wH(126-127) Extension Flag and Checksum Extension Block(s) : 0 Checksum Value : 73 ___________________________________________________________________ Horizontal: 水平方向 Vertical： 垂直方向 Active Time： 有效区域 Blanking Time： 空白区域（包括上部和底部，或者是左边和右边的和） Pixel ClockPixel clock：像素时脉(Pixel clock)指的是用来划分进来的影像水平线里的个别画素，Pixel clock会将每一条水平线分成取样的样本，越高频率的Pixel clock，每条扫瞄线会有越多的样本画素。 1pixclock = 1/dotclock dotclock是视频硬件在显示器上绘制像素的速率 1dotclock = Htotal × Vtotal × framerate Htotal: 水平方向上的所有像素点，（Active Time + Blanking Time） Vtotal: 垂直方向上的所有像素点，（Active Time + Blanking Time） framerate: 帧数 示例中的Pixel Clock1Pixel Clock = 60 x (1600 + 200) x (900 + 100) = 108000000Hz = 108Mhz 参考 修改显示器EDID工具(源码)) http://hubpages.com/technology/how-to-reflash-a-monitors-corrupted-edid //读取和修改显示器的EDID EDID使用说明 EDID标准简介]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>edid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C程序函数调用关系]]></title>
    <url>%2Fpost%2F1655.html</url>
    <content type="text"><![CDATA[阅读源码 安装1234567sudo apt-get install cflow graphvizsudo apt-get install gawkwget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotxwget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraphsudo cp tree2dotx callgraph /usr/local/binsudo chmod +x /usr/local/bin/&#123;tree2dotx,callgraph&#125; 使用1callgraph -f main 参考 源码分析：静态分析 C 程序函数调用关系图 看开源代码利器—用Graphviz + CodeViz生成C/C++函数调用图(call graph)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Callgraph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H264 ES PS TS流之间的联系]]></title>
    <url>%2Fpost%2F51817.html</url>
    <content type="text"><![CDATA[ES流(Elementary Stream): 也叫基本码流,包含视频、音频或数据的连续码流. PES流(Packet Elementary Stream): 也叫打包的基本码流, 是将基本的码流ES流根据需要分成长度不等的数据包, 并加上包头就形成了打包的基本码流PES流. TS流(Transport Stream): 也叫传输流, 是由固定长度为188字节的包组成, 含有独立时基的一个或多个program, 一个program又可以包含多个视频、音频、和文字信息的ES流; 基本概念ESES是只包含一种内容的数据流，如只含视频或只含音频等，打包之后的PES也是只含一种性质的ES,如只含视频ES的PES,只含音频ES的PES等。每个ES都由若干个存取单元（AU）组成，每个视频AU或音频AU都是由头部和编码数据两部分组成，个AU相当于编码的1幅视频图像或1个音频帧，也可以说，每个AU实际上是编码数据流的显示单元，即相当于解码的1幅视频图像或1个音频帧的取样。 PESPES–Packetized Elementary Streams (分组的ES)，ES形成的分组称为PES分组，是用来传递ES的一种数据结构。PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。PES包由包头和payload组成。 PSPS–Program Stream(节目流)PS流由PS包组成，而一个PS包又由若干个PES包组成（到这里，ES经过了两层的封装）。PS包的包头中包含了同步信息与时钟恢复信息。一个PS包最多可包含具有同一时钟基准的16个视频PES包和32个音频PES包。 TSTS–Transport Stream（传输流）由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES也经过了两层的封装）。PES包的包头信息依然存在于TS包中。 PS和TS区别：TS流与PS流的区别在于TS流的包结构是固定长度的,而PS流的包结构是可变长度的。PS包由于长度是变化的,一旦丢失某一PS包的同步信息,接收机就会进入失步状态,从而导致严重的信息丢失事件。而TS码流由于采用了固定长度的包结构,当传输误码破坏了某一TS包的同步信息时,接收机可在固定的位置检测它后面包中的同步信息,从而恢复同步,避免了信息丢失。因此在信道环境较为恶劣、传输误码较高时一般采用TS码流,而在信环境较好、传输误码较低时一般采用PS码流。 PTS、DTSPTS–PresentationTime Stamp（显示时间标记）表示显示单元出现在系统目标解码器（H.264、MJPEG等）的时间。 DTS–Decoding Time Stamp（解码时间标记）表示将存取单元全部字节从解码缓存器移走的时间。 PTS/DTS是打在PES包的包头里面的，这两个参数是解决音视频同步显示，防止解码器输入缓存上溢或下溢的关键。每一个I（关键帧）、P（预测帧）、B（双向预测 帧）帧的包头都有一个PTS和DTS，但PTS与DTS对于B帧不一样，无需标出B帧的DTS，对于I帧和P帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，所以一定要分别标明PTS和DTS。]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>H264</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】网络库libevent、libev、libuv对比]]></title>
    <url>%2Fpost%2F12060.html</url>
    <content type="text"><![CDATA[地址：https://blog.csdn.net/lijinqi1987/article/details/71214974 三者都是*异步事件库（Asynchronous event library）。 异步事件库 异步事件通知 可移植 异步事件库本质上是提供异步事件通知（Asynchronous Event Notification，AEN）的。可移植（Portable）、可扩展（Scalable）这些特性只是为了使库更通用、易用，并非必须。 异步事件通知异步事件通知机制就是根据发生的事件，调用相应的回调函数进行处理。 事件（Event）：事件是异步事件通知机制的核心，比如fd事件、超时事件、信号事件、定时器事件。有时候也称事件为事件处理器（Event Handler），这个名称更形象，因为Handler本身表示了包含处理所需数据（或数据的地址）和处理的方法（回调函数），更像是面向对象思想中的称谓。 数据（Data）：提供给回调函数的输入数据，可以是实际的数据，也可以指针，为了提供统一的API，一般为 void * 指针。 回调函数（Callback Function）：事件发生时调用的方法。注意回调只是一种机制，跟异步没有太大关系，同步也可以采用回调机制（API）。 事件循环（Event Loop）：等待并分发事件。事件循环用于管理事件。 对于应用程序来说，这些只是异步事件库提供的API，封装了异步事件库跟操作系统的交互，异步事件库会选择一种操作系统提供的机制来实现某一种事件，比如利用Unix/Linux平台的epoll机制实现网络IO事件，在同时存在多种机制可以利用时，异步事件库会采用最优机制。 事件事件种类 type libevent libev libuv IO fd io fs_event 计时器（mono clock） timer timer timter 计时器（wall clock） – periodic – 信号 signal signal signal 进程控制 – child process 文件stat – stat fs_poll 每次循环都会执行的Idle事件 – idle idle 循环block之前执行 – prepare prepare 循环blcck之后执行 – check check 嵌套loop – embed – fork – fork – loop销毁之前的清理工作 – cleanup – 操作另一个线程中的loop – async async 双向通信 – – stream ( tcp, pipe, tty ) 这个对比对于libev和libuv更有意义，对于libevent，很多都是跟其设计思想有关的。libev中的embed很少用，libuv没有也没关系；cleanup完全可以用libuv中的async_exit来替代；libuv没有fork事件。 优先级在libevent中，激活的事件是组织在优先级队列中的，各类事件默认的优先级是相同的，可以通过设置事件的优先级使其优先被处理。 libev也通过优先级队列来管理激活的时间，也可以设置事件的优先级。 libuv没有优先级的概念，而是按照固定的顺序访问各类事件。 事件循环略有不同对于事件循环，libev和libuv是相同的，即管理事件（等待并分发事件）。 但是在libevent里还有一个概念是event_base，是用于管理事件的，而lievent中的loop只是一个执行过程（仅仅是函数），并非一个实体（数据和函数）。 Before you can use any interesting Libevent function, you need to allocate one or more event_base structures. Each event_base structure holds a set of events and can poll to determine which events are active. If an event_base is set up to use locking, it is safe to access it between multiple threads. Its loop can only be run in a single thread, however. If you want to have multiple threads polling for IO, you need to have an event_base for each thread. Tip [A future version of Libevent may have support for event_bases that run events across multiple threads.] 根据官网的介绍（不考虑其中提到的特殊版本），并对照源码中event_base_loop的实现 1234567891011121314151617181920212223242526intevent_base_loop(struct event_base *base, int flags)&#123; ... /* Grab the lock. We will release it inside evsel.dispatch, and again * as we invoke user callbacks. */ EVBASE_ACQUIRE_LOCK(base, th_base_lock); if (base-&gt;running_loop) &#123; event_warnx("%s: reentrant invocation. Only one event_base_loop" " can run on each event_base at once.", __func__); EVBASE_RELEASE_LOCK(base, th_base_lock); return -1; &#125; ... done: clear_time_cache(base); base-&gt;running_loop = 0; EVBASE_RELEASE_LOCK(base, th_base_lock); ...&#125; 在loop执行过程中，传入的base已被加锁，是不能用于其他执行过程的。 所以基本上libev和libuv里的loop相当于libevent中的loop函数和event_base的结合。 下文中提到的loop仅指libev和libuv中的loop。 线程安全libevent、libev、libuv里的event_base和loop都不是线程安全的，也就是说一个event_base或loop实例只能在用户的一个线程内访问（一般是主线程），注册到event_base或loop的event都是串行访问的，即每个执行过程中，会按照优先级顺序访问已经激活的事件，执行其回调函数。所以在仅使用一个event_base或loop的情况下，回调函数的执行不存在并行关系。 如果应用程序除了主loop外，没有自己启动任何线程，那么不用担心回调里的“临界区”。 如果使用了多个event_base或loop（一般每个线程一个event_base或loop），需要考虑共享数据的同步问题。 可移植支持的操作系统三个库都支持Linux, *BSD, Mac OS X, Solaris, Windows type libevent libev libuv dev/poll (Solaris) y y y event ports y y y kqueue (*BSD) y y y POSIX select y y y Windows select y y y Windows IOCP y N y poll y y y epoll y y y 对于Unix/Linux平台，没有什么大不同，优先选择epoll，对于windows，libevent、libev都使用select检测和分发事件（不I/O），libuv在windows下使用IOCP。libevent有一个socket handle, 在windows上使用IOCP进行读写。libev没有类似的。但是libevent的IOCP支持也不是很好（性能不高）。所以如果是在windows平台下，使用原生的IOCP进行I/O，或者使用libuv。 异步架构程序设计原则 回调函数不可以执行过长时间，因为一个loop中可能包含其他事件，尤其是会影响一些准确度要求比较高的timer。 尽量采用库中所缓存的时间，有时候需要根据时间差来执行timeout之类的操作。当然能够利用库中的timer最好。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smoke Testing（冒烟测试）]]></title>
    <url>%2Fpost%2F27818.html</url>
    <content type="text"><![CDATA[最近接到测试组的测试报告，写的冒烟测试。由于第一次遇到，便百度搜索一番，在这里进行简单记录。 Smoke Testing 的概念最早源于制造业，用于测试管道。测试时，用鼓风机往管道里灌烟，看管壁外面是否有烟冒出来，以便检验管道是否有缝隙。这一测试显然比较初级，更深层一点的测试至少要进行渗油测试、带压测试等等。Smoke Testing 只是一种初级、直观的测试。 Smoke Testing 在软件测试中的意义，应该说取的是其原始概念中的目的而非手段。通过 Smoke Testing，在软件代码正式编译并交付测试之前，先尽量消除其“表面的”错误，减少后期测试的负担。因此可以说，Smoke Testing 是预测试。 冒烟测试的执行对象一般是程序的开发者，可以建议在开发人员的 自测报告中加入冒烟测试的情况反馈，因为只有通过冒烟测试才能进行更深入的系统测试，如果连冒烟测试都没有通过的版本，交给测试人员，很有可能因为环境、部署等问题回退。 参考 详细介绍一下 Smoke Testing（冒烟测试） 冒烟测试浅谈]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组播--IGMPv2]]></title>
    <url>%2Fpost%2F39626.html</url>
    <content type="text"><![CDATA[IGMP 是Internet Group Management Protocol（互联网组管理协议）的简称。它是TCP/IP 协议族中负责IP 组播成员管理的协议，用来在IP 主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。 IGMPv1（由RFC 1112 定义） IGMPv2（由RFC 2236 定义） IGMPv3（由RFC 3376 定义） 所有版本的IGMP都支持ASM（Any-Source Multicast，任意信源组播）模型；IGMPv3可以直接应用于SSM（Source-Specific Multicast，指定信源组播）模型，而IGMPv1和IGMPv2则需要在IGMP SSM Mapping技术的支持下才能应用于SSM模型。 IGMP工作原理 第一阶段： 当某个主机加入新的组播时，该主机应向多播租的多播地址发送一个IGMP报文，声明自己要成为该租的成员。本地的多播路由器收到IGMP报文后，还要利用多播路由选择协议把这种组成员关系转发给因特网上的其他多播路由器。 第二阶段： 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。 特性IGMP snooping 和 IGMP proxyIGMP snooping 是运行在二层设备上的组播约束的机制，用于管理和控制组播组。 IGMP proxy 是靠拦截用户和路由器之间的IGMP报文建立组播表，Proxy设备的上联端口执行主机的角色，下联端口执行路由器的角色。 IGMPv1IGMPv1 主要基于查询和响应机制来完成对组播组成员的管理。 当一个网段内有多台组播路由器时，由于它们都能从主机那里收到IGMP 成员关系报告报文（Membership Report Message），因此只需要其中一台路由器发送IGMP 查询报文（Query Message）就足够了。这就需要有一个查询器（Querier）的选举机制来确定由哪台路由器作为IGMP查询器。 对于IGMPv1 来说，由组播路由协议（如PIM）选举出唯一的组播信息转发者DR（Designated Router，指定路由器）作为IGMP 查询器 IGMPv1 没有专门定义离开组播组的报文。当运行IGMPv1 的主机离开某组播组时，将不会向其要离开的组播组发送报告报文。当网段中不再存在该组播组的成员后，IGMP 路由器将收不到任何发往该组播组的报告报文，于是IGMP 路由器在一段时间之后便删&gt;除该组播组所对应的组播转发项。 IGMPv2与IGMPv1 相比，IGMPv2 增加了查询器选举机制和离开组机制。 查询器选举机制在IGMPv1 中，当某共享网段上存在多个组播路由器时，由组播路由协议（如PIM）选举的指定路由器充当查询器。 在IGMPv2 中，增加了独立的查询器选举机制，其选举过程如下： 所有IGMPv2路由器在初始时都认为自己是查询器，并向本地网段内的所有主机和路由器发送IGMP普遍组查询（General Query）报文（目的地址为224.0.0.1）； 本地网段中的其它IGMPv2路由器在收到该报文后，将报文的源IP地址与自己的接口地址作比较。通过比较， IP地址最小的路由器将成为查询器，其它路由器成为非查询器（Non-Querier）； 所有非查询器上都会启动一个定时器（即其它查询器存在时间定时器Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的IGMP 查询报文，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。 离开组机制在IGMPv1 中，主机离开组播组时不会向组播路由器发出任何通知，导致组播路由器只能依靠组播组成员查询的响应超时来获知组播组成员的离开。 而在IGMPv2中，当一个主机离开某组播组时： 该主机向本地网段内的所有组播路由器（目的地址为224.0.0.2）发送离开组（Leave Group）报文； 当查询器收到该报文后， 向该主机所声明要离开的那个组播组发送特定组查询（Group-Specific Query）报文（目的地址字段和组地址字段均填充为所要查询的组播组地址）； 如果该网段内还有该组播组的其它成员，则这些成员在收到特定组查询报文后，会在该报文中所设定的最大响应时间（Max Response Time）内发送成员关系报告报文； 如果在最大响应时间内收到了该组播组其它成员发送的成员关系报告报文，查询器就会继续维护该组播组的成员关系；否则，查询器将认为该网段内已无该组播组的成员，于是不再维护这个组播组的成员关系。 IGMPv2报文格式1234560 7 8 1516 31+--------------+---------------+-------------------------------+-++| Type | max_resp_time | CheckSum | |+--------------+---------------+-------------------------------+ 8Byte| Group Address | |+--------------------------------------------------------------+-++ Type : Type 0x11 Membership Query(成员查询) 0X12 Version 1 Membership Report(版本1成员报告) 0X16 Version 2 Membership Report(版本2成员报告) 0X17 Leave Group(离开组) max_resp_time: 在发出响应报告前的以1/10秒为单位的最长时间，缺省值为10秒。新的最大响应时间（以1/10秒为单位）字段允许查询用路由器为它的查询报文指定准确的查询间隔响应时间。IGMP版本2主机在随机选择它们的应时间值时以此作为上限。 从路由器接收到一条查询消息后，主机会为其所属的每个组播组都配置一个计时器。计时器的值在 0 到最大响应时间之间随机选定。当其中任何一个计时器的值减为 0时，主机就会发送该组播组的成员报告消息。合理配置最大响应时间，可以使主机快速响应查询信息，路由器也就能快速地掌握组播组成员的存在状况。 Group Address: 组地址 1234567Internet Group Management Protocol [IGMP Version: 2] Type: Membership Report (0x16) Max Resp Time: 0.0 sec (0x00) Checksum: 0xfaf3 [correct] [Checksum Status: Good] Multicast Address: 239.0.0.11 设置max_resp_time1ip igmp snooping query-max-response-time seconds IGMPv3IGMPv3 在兼容和继承IGMPv1 和IGMPv2 的基础上，进一步增强了主机的控制能力，并增强了查询和报告报文的功能。 IGMP snooping查询器在运行了IGMP的组播网络中，会有一台三层组播设备充当IGMP查询器，负责发送IGMP查询报文，使三层组播设备能够在网络层建立并维护组播转发表项，从而在网络层正常转发组播数据。 参考 IGMP技术总结 IGMPv3协议报文格式参考 IGMP Snooping概念和配置方法—交换 IGMPV2基本原理 IGMP Snooping技术学习笔记 H3C F1000-S防火墙基础配置及telnet登录！ IGMP Snooping技术介绍 《TCP/IP详解卷2：实现》笔记–IGMP:Internet组管理协议]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
        <tag>IGMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI七层网络模型]]></title>
    <url>%2Fpost%2F51171.html</url>
    <content type="text"><![CDATA[一张非常强大的OSI七层模型图解: Later 应用层 DHCP · DNS · FTP · Gopher · HTTP · IMAP4 · IRC · NNTP · XMPP · POP3 · SIP · SMTP · SNMP · SSH · TELNET · RPC · RTCP · RTP ·RTSP · SDP · SOAP · GTP · STUN · NTP · SSDP 表示层 HTTP/HTML · FTP · Telnet · ASN.1（具有表示层功能） 会话层 ADSP·ASP·H.245·ISO-SP·iSNS·NetBIOS·PAP·RPC·RTCP·SMPP·SCP·SSH·ZIP·SDP（具有会话层功能） 传输层 TCP · UDP · TLS · DCCP · SCTP ·RSVP · PPTP 网络层 IP (IPv4 · IPv6) · ICMP · ICMPv6 · IGMP ·IS-IS · IPsec · BGP · RIP · OSPF ·ARP · RARP 数据链路层 Wi-Fi(IEEE 802.11) · WiMAX(IEEE 802.16) ·ATM · DTM · 令牌环 · 以太网路 · FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN ·STP 物理层 以太网路卡 · 调制解调器 · 电力线通信(PLC) · SONET/SDH（光同步数字传输网） · G.709（光传输网络）· 光导纤维 · 同轴电缆 · 双绞线]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流媒体之RTSP/RTP/RTCP]]></title>
    <url>%2Fpost%2F34052.html</url>
    <content type="text"><![CDATA[用一句简单的话总结：RTSP发起/终结流媒体、RTP传输流媒体数据 、RTCP对RTP进行控制，同步。 RTP：实时传输协议（Real-time Transport Protocol） RTP/RTCP是实际传输数据的协议 RTP传输音频/视频数据，如果是PLAY，Server发送到Client端，如果是RECORD，可以由Client发送到Server 整个RTP协议由两个密切相关的部分组成：RTP数据协议和RTP控制协议（即RTCP） RTSP：实时流协议（Real Time Streaming Protocol，RTSP） RTSP的请求主要有DESCRIBE,SETUP,PLAY,PAUSE,TEARDOWN,OPTIONS等，顾名思义可以知道起对话和控制作用 RTSP的对话过程中SETUP可以确定RTP/RTCP使用的端口，PLAY/PAUSE/TEARDOWN可以开始或者停止RTP的发送，等等 RTCP：RTP 控制协议（RTP Control Protocol） RTP/RTCP是实际传输数据的协议 RTCP包括Sender Report和Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议 RTPRTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由头部（Header）和负载（Payload）两个部分组成，其中头部前12个字节的含义是固定的，而负载则可以是音频或者视频数据。RTP数据报的头部格式如图： 123456789101112 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|V=2|P|X| CC |M| PT | sequence number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| timestamp |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| synchronization source (SSRC) identifier |+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+| contributing source (CSRC) identifiers || .... |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 从RTP数据报的格式不难看出，它包含了传输媒体的类型、格式、序列号、时间戳以及是否有附加数据等信息，这些都为实时的流媒体传输提供了相应的基础。 字段解析 字段 位宽 含义 V 2 RTP协议的版本号，当前协议版本号为2。 P 1 填充标志, 如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 X 1 扩展标志，如果X=1，则在RTP报头后跟有一个扩展报头。 CC 4 CSRC计数器， 指示CSRC 标识符的个数。 M 1 标记，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。 PT 7 有效载荷类型，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。 sequence number 16 用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 timestamp 32 时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 SSRC 32 用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。 CSRC 32 每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。 实现RTP协议的目的是提供实时数据（如交互式的音频和视频）的端到端传输服务，因此在RTP中没有连接的概念，它可以建立在底层的面向连接或面向非连接的传输协议之上；RTP也不依赖于特别的网络地址格式，而仅仅只需要底层传输协议支持组帧（Framing）和分段（Segmentation）就足够了；另外RTP本身还不提供任何可靠性机制，这些都要由传输协议或者应用程序自己来保证。在典型的应用场合下，RTP一般是在传输协议之上作为应用程序的一部分加以实现的， 1234567891011+-----------------------------------------------------------------+| Application Layer |+-----------------------------------------------------------------+| RTP/RTCP |+--------------------------------+--------------------------------+| UDP | TCP |+--------------------------------+--------------------------------+| IPv4/IPv6 |+-----------------------------------------------------------------+| LAN/WAN |+-----------------------------------------------------------------+ RTSP作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。 RTSP可以对流媒体提供诸如播放、暂停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。 由RTSP控制的媒体流集合可以用表示描述（Presentation Description）来定义，所谓表示是指流媒体服务器提供给客户机的一个或者多个媒体流的集合，而表示描述则包含了一个表示中各个媒体流的相关信 息，如数据编码/解码算法、网络地址、媒体流的内容等。虽然RTSP服务器同样也使用标识符来区别每一流连接会话（Session），但RTSP连接并没有被绑定到传输层连接（如TCP等），也就是说在整个 RTSP连接期间，RTSP用户可打开或者关闭多个对RTSP服务器的可靠传输连接以发出RTSP 请求。此外，RTSP连接也可以基于面向无连接的传输协议（如UDP等）。 Real Time Streaming Protocol (RTSP) 123456789101112131415161718192021=======================================================================================================================================RTSP/Packet Counter:Topic / Item Count Average Min val Max val Rate (ms) Percent Burst rate Burst start---------------------------------------------------------------------------------------------------------------------------------------Total RTSP Packets 18 0.0005 100% 0.0700 5.792 RTSP Response Packets 0 0.0000 0.00% - - ???: broken 0 0.0000 - - 5xx: Server Error 0 0.0000 - - 4xx: Client Error 0 0.0000 - - 3xx: Redirection 0 0.0000 - - 2xx: Success 0 0.0000 - - 1xx: Informational 0 0.0000 - - RTSP Request Packets 9 0.0002 50.00% 0.0400 5.848 SET_PARAMETER 2 0.0001 22.22% 0.0200 5.859 SETUP 1 0.0000 11.11% 0.0100 5.933 PLAY 1 0.0000 11.11% 0.0100 5.986 OPTIONS 2 0.0001 22.22% 0.0200 5.751 GET_PARAMETER 3 0.0001 33.33% 0.0100 5.848 Other RTSP Packets 9 0.0002 50.00% 0.0400 5.792--------------------------------------------------------------------------------------------------------------------------------------- RTSP是一种基于文本的协议，用CRLF作为一行的结束符。使用基于文本协议的好处在于我们可以随时在使用过程中的增加自定义的参数，也可以随便将协议包抓住很直观的进行分析。 报文RTSP有两类报文：请求报文和响应报文 请求报文:指从客户端向服务器发送请求报文 响应报文:指从服务器到客户端的回答 RTSP报文由三部分组成，即开始行、首部行和实体主体。 请求报文在请求报文中，开始行就是请求行，RTSP请求报文的结构如图 RTSP请求报文的常用方法及作用： 方法 作用 OPTIONS 获得服务器提供的可用方法 DESCRIBE 得到会话描述信息 SETUP 客户端提醒服务器建立会话，并确定传输模式 TEARDOWN 客户端发起关闭请求 PLAY 客户端发送播放请求 SET_PARAMETER 给URI指定的表示或媒体流设置参数值 GET_PARAMETER 获取URI中指定的表示或流的任何指定参数或参数的值 响应报文响应报文的开始行是状态行，RTSP响应报文的结构如图： 示例-交互123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125OPTIONS * RTSP/1.0Date: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 1Require: org.wfa.wfd1.0RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 1Public: org.wfa.wfd1.0, GET_PARAMETER, SET_PARAMETEROPTIONS * RTSP/1.0Date: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 1Require: org.wfa.wfd1.0RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 1Public: org.wfa.wfd1.0, SETUP, TEARDOWN, PLAY, PAUSE, GET_PARAMETER, SET_PARAMETERGET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0Date: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 2Content-Type: text/parametersContent-Length: 90wfd_video_formatswfd_audio_codecswfd_client_rtp_portswfd_rtp_multicast: 239.0.0.11RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 2Content-Type: text/parametersContent-Length: 259wfd_video_formats: 28 00 02 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none, 01 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none nonewfd_audio_codecs: LPCM 00000002 00, AAC 00000001 00wfd_client_rtp_ports: RTP/AVP/UDP;unicast 15550 0 mode=playSET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0Date: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 3Content-Type: text/parametersContent-Length: 203wfd_video_formats: wfd_audio_codecs: LPCM 00000002 00wfd_presentation_URL: rtsp://192.168.100.2/wfd1.0/streamid=0 nonewfd_client_rtp_ports: RTP/AVP/UDP;unicast 15550 0 mode=playwfd_display_edid:RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 3SET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0Date: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 4Content-Type: text/parametersContent-Length: 27wfd_trigger_method: SETUPRTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 4SETUP rtsp://192.168.100.2/wfd1.0/streamid=0 RTSP/1.0Date: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 2Transport: RTP/AVP/UDP;unicast;client_port=15550-15551RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 2Session: 1649760492;timeout=319201969439387Transport: RTP/AVP/UDP;unicast;client_port=15550-15551;server_port=22648-22649PLAY rtsp://192.168.100.2/wfd1.0/streamid=0 RTSP/1.0Date: Thu, 01 Jan 1970 00:00:49 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 3Session: 1649760492RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:11:07 +0000Server: linuxCSeq: 3Session: 1649760492;timeout=319201969439387Range: npt=now-GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0Date: Thu, 01 Jan 1970 00:11:27 +0000Server: linuxCSeq: 5Session: 1649760492RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:01:08 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 5Content-Type: text/parametersContent-Length: 0GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0Date: Thu, 01 Jan 1970 00:11:47 +0000Server: linuxCSeq: 6Session: 1649760492RTSP/1.0 200 OKDate: Thu, 01 Jan 1970 00:01:28 +0000User-Agent: stagefright/1.1 (Linux;Android 4.1)CSeq: 6Content-Type: text/parametersContent-Length: 0 RTCPRTCP控制协议需要与RTP数据协议一起配合使用，当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用。RTP本身并不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成。通常RTCP会采用与RTP相同的分发机制，向会话中的所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进行控制或者对网络状况进行诊断。 开源代码 C++ JRTPLIB【Code】 myRtspClient 参考 RTSP/RTP 媒体传输和控制协议 RTP Payload Format for H.264 Video【html】 Real-Time Streaming Protocol (RTSP) 2.0 Parameters RTP/RTSP/RTCP的区别 RTSP协议介绍]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>RTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP调用connect的作用]]></title>
    <url>%2Fpost%2F33300.html</url>
    <content type="text"><![CDATA[问： UDP中可以使用connect系统调用吗? 答： 可以 问： 为什么使用？ 答： 提高效率 UDP中connect操作与TCP中connect操作有着本质区别？ TCP中调用connect会引起三次握手,client与server建立连结 UDP中调用connect内核仅仅把对端ip&amp;port记录下来. UDP中可以多次调用connect,TCP只能调用一次onnect UDP多次调用connect有两种用途: 指定一个新的ip&amp;port连结. 断开和之前的ip&amp;port的连结. 12345678910struct sockaddr_in remoteAddr;memset(remoteAddr.sin_zero, 0, sizeof(remoteAddr.sin_zero)); remoteAddr.sin_family = AF_INET; /* 建立新的连接 */ //remoteAddr.sin_family = AF_INET; /* 断开旧的连接 */ inet_pton(AF_INET,player-&gt;rtpUdp.rip, &amp;remoteAddr.sin_addr); remoteAddr.sin_port = htons(player-&gt;rtpUdp.rport); do &#123; ret = connect(player-&gt;rtpUdp.fd,(struct sockaddr *)&amp;remoteAddr,remoteAddrLen); &#125; while(ret == -1 &amp;&amp; errno == EINTR); UDP中使用connect可以提高效率原因 普通的UDP发送两个报文内核处理如下: 1#1:建立连结 -&gt; #2:发送报文 -&gt; #3:断开连结 -&gt; #4:建立连结 -&gt; #5:发送报文 -&gt; #6:断开连结 采用connect方式的UDP发送两个报文内核处理如下： 1#1:建立连结 -&gt; #2:发送报文 -&gt; #3:发送另外一个报文 每次发送报文内核都由可能要做路由查询 UDP中使用connect的好处： 会提升效率 高并发服务中会增加系统稳定性. 原因: ??? 假设client A 通过非connect的UDP与server B,C通信.B,C提供相同服务.为了负载均衡,我们让A与B,C交替通信.A 与 B通信IPa:PORTa —- IPb:PORTb； A 与 C通信IPa:PORTa’— IPc:PORTc 假设PORTa 与 PORTa’相同了(在大并发情况下会发生这种情况),那么就有可能出现A等待B的报文,却收到了C的报文.导致收报错误.解决方法内就是采用connect的UDP通信方式.在A中创建两个udp,然后分别connect到B,C. 参考 UDP 调用 connect]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络调试--tcpdump]]></title>
    <url>%2Fpost%2F18035.html</url>
    <content type="text"><![CDATA[网络调试的手段工具：tcpdump、wireshark 抓包–tcpdump下载：http://www.tcpdump.org 1tcpdump -i wlan0 -p -w file.pcap 常用参数： arg -p 将网卡设置为非混杂模式 -n 对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。 -nn 除了-n的作用外，还把端口显示为数值，否则显示端口服务名。 -c 指定要抓取的包数量 -v 当分析和打印的时候，产生详细的输出 -vv 产生比-v更详细的输出 -w 将抓包数据输出到文件中而不是标准输出。可以同时配合-G time选项使得输出文件每time秒就自动切换到另一个文件 Install for arm123456789101112131415161718192021222324252627282930313233343536#!/bin/bash# host# for libpcap error: configure: error: Neither flex nor lex was found.#sudo apt install flex bisonPWD=$(pwd)TCPDUMP="tcpdump-4.9.2"LIBPCAP="libpcap-1.9.0"export CC=arm-linux-gnueabihf-gcc# http://www.tcpdump.orgfor software in $&#123;TCPDUMP&#125; $&#123;LIBPCAP&#125;do echo "Download $software ..." echo "wget http://www.tcpdump.org/release/$&#123;software&#125;.tar.gz" wget http://www.tcpdump.org/release/$&#123;software&#125;.tar.gz echo "tar xvf $&#123;software&#125;.tar.gz" tar xvf $&#123;software&#125;.tar.gzdonecd $&#123;LIBPCAP&#125;./configure --host=arm-linux --with-pcap=linux --prefix=$&#123;PWD&#125;/outmake; make installcd -cd $&#123;TCPDUMP&#125;./configure --host=arm-linux --with-system-libpcap=$&#123;PWD&#125;/../$&#123;LIBPCAP&#125;/out/lib --prefix=$&#123;PWD&#125;/outmake; make installcd -cp $&#123;PWD&#125;/$&#123;TCPDUMP&#125;/out/sbin/tcpdump . 示例 -n：直接打印，-w：保存文件 抓取wlan0中的所有数据包 1# tcpdump -i wlan0 -v -n 抓取wlan0中的udp包 1# tcpdump -i wlan0 -v -n udp 抓取wlan中的5个udp包 1# tcpdump -i wlan0 -v -n udp -c 5 指定端口号 1tcpdump -i wlan0 tcp port 7236 -w rrrr.pcap 分析–wiresharknetstat123456# netstat -nActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 192.168.100.3:40964 192.168.100.2:7236 ESTABLISHEDudp 0 0 239.0.0.11:15550 192.168.100.2:* ESTABLISHEDudp 0 0 239.0.0.11:15551 192.168.100.2:1 ESTABLISHED]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组播（多播）]]></title>
    <url>%2Fpost%2F18736.html</url>
    <content type="text"><![CDATA[组播是指在IP网络中将数据包以尽力传送的形式发送到某个确定的节点集合（即组播组），其基本思想是：源主机（即组播源）只发送一份数据，其目的地址为组播组地址；组播组中的所有接收者都可收到同样的数据拷贝，并且只有组播组内的主机可以接收该数据，而其它主机则不能收到。 组播技术有效地解决了单点发送、多点接收的问题，实现了IP网络中点到多点的高效数据传送，能够大量节约网络带宽、降低网络负载。作为一种与单播和广播并列的通信方式，组播的意义不仅在于此。更重要的是，可以利用网络的组播特性方便地提供一些新的增值业务，包括在线直播、网络电视、远程教育、远程医疗、网络电台、实时视频会议等互联网的信息服务领域 组播技术实现组播技术的实现需要解决以下几方面问题： 组播源向一组确定的接收者发送信息，而如何来标识这组确定的接收者？——这需要用到组播地址机制； 接收者通过加入组播组来实现对组播信息的接收，而接收者是如何动态地加入或离开组播组的？——即如何进行组成员关系管理； 组播报文在网络中是如何被转发并最终到达接收者的？——即组播报文转发的过程； 组播报文的转发路径（即组播转发树）是如何构建的？——这是由各组播路由协议来完成的。 组播地址机制IP组播地址 IP组播地址前四位均为“1110” IP组播地址用于标识一个IP组播组。IANA把D类地址空间分配给组播使用，范围从224.0.0.0到239.255.255.255。 组播地址划分: 224.0.0.0到224.0.0.255被IANA预留，地址224.0.0.0保留不做分配，其它地址供路由协议及拓扑查找和维护协议使用。该范围内的地址属于局部范畴，不论TTL为多少，都不会被路由器转发； 224.0.1.0到238.255.255.255为用户可用的组播地址，在全网范围内有效。其中232.0.0.0/8为SSM组地址，而其余则属于ASM组地址。有关ASM和SSM的详细介绍，请参见“2.5 组播模型分类”一节； 239.0.0.0到239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效，也属于ASM组地址。使用本地管理组地址可以灵活定义组播域的范围，以实现不同组播域之间的地址隔离，从而有助于在不同组播域内重复使用相同组播地址而不会引起冲突。 说明： 224.0.1.0/24网段内的一些组播地址也被IANA预留给了某些组播应用。譬如，224.0.1.1被预留给NTP（Network Time Protocol，网络时间协议）所使用。 组成员关系管理组成员关系管理是指在路由器/交换机上建立直联网段内的组成员关系信息，具体说，就是各接口/端口下有哪些组播组的成员。 IGMPIGMP运行于主机和与主机直连的路由器之间，其实现的功能是双向的： 一方面，主机通过IGMP通知路由器希望接收某个特定组播组的信息； 另一方面，路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护。 通过IGMP，在路由器中记录的信息是某个组播组是否在本地有组成员，而不是组播组与主机之间的对应关系。 目前IGMP有以下三个版本： IGMPv1（RFC 1112）中定义了基本的组成员查询和报告过程； IGMPv2（RFC 2236）在IGMPv1的基础上添加了组成员快速离开的机制等； IGMPv3（RFC 3376）中增加的主要功能是成员可以指定接收或拒绝来自某些组播源的报文，以实现对SSM模型的支持。 IGMPv2的工作原理 当同一个网段内有多个IGMP路由器时，IGMPv2通过查询器选举机制从中选举出唯一的查询器。查询器周期性地发送普遍组查询消息进行成员关系查询，主机通过发送报告消息来响应查询。而作为组成员的路由器，其行为也与普通主机一样，响应其它路由器的查询。 当主机要加入组播组时，不必等待查询消息，而是主动发送报告消息；当主机要离开组播组时，也会主动发送离开组消息，查询器收到离开组消息后，会发送特定组查询消息来确定该组的所有组成员是否都已离开。 通过上述机制，在路由器里建立起一张表，其中记录了路由器各接口所对应子网上都有哪些组的成员。当路由器收到发往组G的组播数据后，只向那些有G的成员的接口转发该数据。至于组播数据在路由器之间如何转发则由组播路由协议决定，而不是IGMP的功能。 抓包信息 IGMPv2 destination address Message Type Multicast Address General Query All hosts (224.0.0.1) Group-Specific Query The group being queried Membership Report The group being reported Leave Group All routers (224.0.0.2) 组播相关的含义： IGMPv2: Membership Query, general 发给所有主机 IGMPv2: Membership Report group 239.0.0.11 收到后，回应组播地址 IGMP SnoopingIGMP是针对IP层设计的，只能记录路由器上的三层接口与IP组播地址的对应关系。但在很多情况下，组播报文不可避免地要经过一些交换机，如果没有一种机制将二层端口与组播MAC地址对应起来，组播报文就会转发给交换机的所有端口，这显然会浪费大量的系统资源。 IGMP Snooping的出现就可以解决这个问题，其工作原理为：主机发往IGMP查询器的报告消息经过交换机时，交换机对这个消息进行监听并记录下来，为端口和组播MAC地址建立起映射关系；当交换机收到组播数据时，根据这样的映射关系，只向连有组成员的端口转发组播数据。 组播编程多播的程序设计使用setsockopt()函数和getsockopt()函数来实现，组播的选项是IP层的，其选项值和含义 getsockopt()/setsockopt()的选项 含 义 IP_MULTICAST_TTL 设置多播组数据的TTL值 IP_ADD_MEMBERSHIP 在指定接口上加入组播组 IP_DROP_MEMBERSHIP 退出组播组 IP_MULTICAST_IF 获取默认接口或设置接口 IP_MULTICAST_LOOP 禁止组播数据回送 实例–视频会议 路由器新建两个AP（AP-S和AP-R），其中均开启组播功能，为什么建两个，作用，关系 R1和R2两个加入组播（239.0.0.1） S 建立socket 1fd = socket(AF_INET, SOCK_DGRAM, 0); 绑定 123456struct sockaddr_in localAddrmemset(localAddr.sin_zero, 0, sizeof(localAddr.sin_zero));localAddr.sin_family = AF_INET;localAddr.sin_addr.s_addr = htonl(INADDR_ANY);localAddr.sin_port = htons(netParam-&gt;local_port); //port(Random): Pick an even integer in range [1024, 65534)bind(fd, (const struct sockaddr *)&amp;localAddr, sizeof(localAddr)); 连接 1234567struct sockaddr_in remoteAddr;memset(remoteAddr.sin_zero, 0, sizeof(remoteAddr.sin_zero));remoteAddr.sin_family = AF_INET;remoteAddr.sin_addr.s_addr = htonl(INADDR_ANY);remoteAddr.sin_port = htons(netParam-&gt;remote_port); //port: 15550ret = inet_pton(AF_INET, netParam-&gt;remoteip, &amp;remoteAddr.sin_addr); //remoteip: 239.0.0.1ret = connect(fd, (const struct sockaddr *)&amp;remoteAddr, sizeof(remoteAddr)); 通过connect指定了连接的IP和端口后，可以通过netstat命令查看1234567&gt;# netstat -n&gt; Active Internet connections (w/o servers)&gt; Proto Recv-Q Send-Q Local Address Foreign Address State&gt; tcp 0 0 192.168.100.2:7236 192.168.100.3:37536 ESTABLISHED&gt; udp 0 0 192.168.100.2:55226 239.0.0.11:15550 ESTABLISHED&gt; udp 0 0 192.168.100.2:55227 239.0.0.11:15551 ESTABLISHED&gt; 路由器 为啥建立两个AP？ R 测试代码实现 在绑定后使用connect进行指定ip和port连接 12345678910struct sockaddr_in remoteAddr;memset(remoteAddr.sin_zero, 0, sizeof(remoteAddr.sin_zero)); remoteAddr.sin_family = AF_INET; /* 建立新的连接 */ //remoteAddr.sin_family = AF_INET; /* 断开旧的连接 */ inet_pton(AF_INET,player-&gt;rtpUdp.rip, &amp;remoteAddr.sin_addr); remoteAddr.sin_port = htons(player-&gt;rtpUdp.rport); //port: 0 do &#123; ret = connect(player-&gt;rtpUdp.fd,(struct sockaddr *)&amp;remoteAddr,remoteAddrLen); &#125; while(ret == -1 &amp;&amp; errno == EINTR); 123456# netstat -nActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 192.168.100.3:40964 192.168.100.2:7236 ESTABLISHEDudp 0 0 239.0.0.11:15550 192.168.100.2:* ESTABLISHED #Foreign port: 0udp 0 0 239.0.0.11:15551 192.168.100.2:1 ESTABLISHED 注意–无法得到数据原因 select一直出现timeout 接收组播的网络端口（也就是R端），必须设置该组播的IP，负责接收不到组播数据 数据包被操作系统过滤掉了，所以系统调用socket无法看到数据包。 调试ifconfig – 判断是支持组播12345678# ifconfigwlan0 Link encap:Ethernet HWaddr 04:E6:76:C3:63:DC inet addr:192.168.100.2 Bcast:192.168.100.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:1413 errors:0 dropped:0 overruns:0 frame:0 TX packets:316 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:88628 (86.5 KiB) TX bytes:40942 (39.9 KiB) UP: 代表网卡开启状态 BROADCAST: 支持广播 RUNNING: 代表网卡的网线被接上 MULTICAST: 支持组播 RX packets和TX packets: 表示网卡接收和发送的数据包个数，但是由于端口的错误等，可能导致select或recv超时或者接收不到数据 RX bytes和TX bytes: 表示接收和发送的数据大小 测试代码R端加入组播的实现： Client Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define BUFLEN 255#if 0#define VX_RTP_MUL_IP "239.0.0.11"#define VX_RTP_LOCAL_PORT 15550#else#define VX_RTP_MUL_IP "225.0.0.37"#define VX_RTP_LOCAL_PORT 12345#endifstatic int socket_set_nonblock(int s)&#123; int flags, res; flags = fcntl(s, F_GETFL, 0); if (flags &lt; 0) &#123; flags = 0; &#125; res = fcntl(s, F_SETFL, flags | O_NONBLOCK); if (res &lt; 0) &#123; printf( "fcntl return err:%d!\n", res); return -1; &#125; return 0;&#125;int main (int argc, char **argv)&#123; int fd = -1; int ret = -1, n = 0, sock_len = 0; char recmsg[BUFLEN + 1]; fd_set rfds; struct sockaddr_in addr; struct timeval tv; struct ip_mreq mreq; int yes=1; int loop = 0; /*UDP*/ fd = socket(AF_INET, SOCK_DGRAM, 0); if(fd == -1) &#123; printf("create udp socket error %d", -errno); return -1; &#125; socket_set_nonblock(fd); /* 允许多个应用绑定同一个本地端口接收数据包 */ ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,sizeof(yes)); if (ret &lt; 0) &#123; printf("setsockopt: SO_REUSEADDR error, ret=%d\n", ret); goto failed; &#125; /* 禁止组播数据回环 */ if( setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&amp;loop, sizeof(loop)) &lt; 0 )&#123; printf("setsockopt: IP_MULTICAST_LOOP error, ret=%d\n", ret); goto failed; &#125; /* 加入组播 */ mreq.imr_multiaddr.s_addr=inet_addr(VX_RTP_MUL_IP); mreq.imr_interface.s_addr=htonl(INADDR_ANY); ret = setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&amp;mreq,sizeof(mreq)); if (ret &lt; 0) &#123; printf("setsockopt: IP_ADD_MEMBERSHIP error, ret=%d\n", ret); goto failed; &#125; memset(addr.sin_zero, 0, sizeof(addr.sin_zero)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = htonl(INADDR_ANY); addr.sin_port = htons(VX_RTP_LOCAL_PORT); /* 设置网卡的组播IP !!! */ ret = inet_pton(AF_INET, VX_RTP_MUL_IP, &amp;addr.sin_addr); if (ret &lt;= 0) &#123; printf("Set network card multicast ip error, ret=%d\n", ret); goto failed; &#125; /* 绑定网卡 */ ret = bind(fd, (const struct sockaddr *)&amp;addr, sizeof(addr)); if (ret &lt; 0) &#123; printf("Bind socket error, ret=%d\n", ret); goto failed; &#125; printf("create rtp udp socket %d ok\n",fd); sock_len = sizeof(addr); /* 循环接收网络上来的组播消息 */ for (;;) &#123; tv.tv_sec = 1; tv.tv_usec = 0; FD_ZERO(&amp;rfds); FD_SET(fd, &amp;rfds); ret = select(fd + 1, &amp;rfds, NULL, NULL, &amp;tv); if (-1 == ret) &#123; printf("===&gt; func: %s, line: %d, Socket select error\n", __func__, __LINE__); return -1; &#125; else if (0 == ret) &#123; printf("===&gt; func: %s, line: %d, select timeout\n", __func__, __LINE__); continue; &#125; //struct sockaddr_in tmp_addr; //socklen_t addr_len = sizeof(tmp_addr); //bzero (recmsg, BUFLEN + 1);eagain: //n = recvfrom(fd, recmsg, BUFLEN, 0, (struct sockaddr*) &amp;addr, (socklen_t*)&amp;sock_len); //n = recvfrom(fd, recmsg, BUFLEN, 0, (struct sockaddr*) &amp;tmp_addr, &amp;addr_len); n = recv(fd, recmsg, BUFLEN, 0); if (n &lt; 0) &#123; printf("recvfrom err in udptalk!, n: %d, errno: %d\n", n, -errno); if (EAGAIN == errno) goto eagain; else return -1; &#125; else if (n == 0) &#123; printf("recv data siez: %d\n", n); &#125; else &#123; /* 成功接收到数据报 */ unsigned int * tmp = (unsigned int*)recmsg; printf ("s: %d, peer: 0x%08x\n", n, tmp[0]); &#125; &#125; return 0;failed: if(fd &gt; 0) close(fd); return -1;&#125; Server： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define HELLO_PORT 12345#define HELLO_GROUP "225.0.0.37"int main(int argc, char *argv[])&#123; struct sockaddr_in addr; int fd; char *message="Hello, World!"; /* create what looks like an ordinary UDP socket */ if ((fd=socket(AF_INET,SOCK_DGRAM,0)) &lt; 0) &#123; perror("socket"); exit(1); &#125; /* set up destination address */ memset(&amp;addr,0,sizeof(addr)); addr.sin_family=AF_INET; addr.sin_addr.s_addr=inet_addr(HELLO_GROUP); addr.sin_port=htons(HELLO_PORT); printf("message: %s, (HEX: 0x%08x)\n", message, *(unsigned int*)message); /* now just sendto() our destination! */ while (1) &#123; if (sendto(fd,message, strlen(message), 0, (struct sockaddr *) &amp;addr, sizeof(addr)) &lt; 0) &#123; perror("sendto"); exit(1); &#125; sleep(1); //会影响接受端select的超时时间，延时越大，select的超时越大 &#125;&#125; 参考 组播技术 组播学习笔记 单播，组播(多播)，广播以及任播 组播（Multicast）传输 多播,IP_MULTICAST_TTL,IP_ADD_MEMBERSHIP,IP_MULTICAST_IF,IP_DROP_MEMBERSHIP]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>组播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C代码片段]]></title>
    <url>%2Fpost%2F16839.html</url>
    <content type="text"><![CDATA[记录一些遇到代码片段： 去掉字符串末尾多余字符：回车 空格12345678910111213141516171819202122232425static void clean_string(char * const str)&#123; char *start = str; char *end = str; char *p = str; while(*p) &#123; switch(*p) &#123; case ' ': case '\r': case '\n': if(str != start) &#123; *start = *p; start++; &#125; break; default: *start = *p; start++; end = start; &#125; p++; &#125; *end = '\0';&#125; 生成随机数： 异或123456789101112static void seedrand_val2()&#123; struct timeval tv; unsigned int rand_val = 0; gettimeofday(&amp;tv, NULL); //秒(tv.tv_sec)和微秒(tv.tv_usec)和进程ID的位进行异或操作生成随机数 rand_val = tv.tv_sec^tv.tv_usec^getpid(); printf("%s: rand_val=%d\n", __func__, rand_val);&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NTP服务]]></title>
    <url>%2Fpost%2F12403.html</url>
    <content type="text"><![CDATA[NTP是网络时间协议(Network Time Protocol)，它是用来同步网络中各个计算机的时间的协议。通俗：Ntp是一种授时的软件用途是把计算机的时钟同步到世界协调时UTC，其精度在局域网内可达0.1ms，在互联网上绝大多数的地方其精度可以达到1-50ms。 搭建NTP Serverubuntu/deepin平台安装1sudo apt-get install ntp 配置NTP修改/etc/ntp.conf文件。 12345678910111213sudo vim /etc/ntp.confdriftfile /var/lib/ntp/ntp.driftstatistics loopstats peerstats clockstatsfilegen loopstats file loopstats type day enablefilegen peerstats file peerstats type day enablefilegen clockstats file clockstats type day enableserver ntp.ubuntu.comrestrict -4 default kod notrap nomodify nopeer noqueryrestrict -6 default kod notrap nomodify nopeer noqueryrestrict 192.168.1.0 mask 255.255.255.0 nomodify #&lt;+++++主要是允许能同步的服务器所在的内部网段restrict 127.0.0.1restrict ::1V 权限设定部分权限设定主要以restrict这个参数来设定，主要的语法为：1restrict IP mask netmask_IP parameter 其中IP可以是软体位址，也可以是 default ，default 就类似0.0.0.0如果 paramter完全没有设定，那就表示该 IP (或网域) 『没有任何限制！』 paramter: ignore：关闭所有的NTP 连线服务 nomodify：表示Client 端不能更改 Server 端的时间参数，不过Client端仍然可以透过Server 端來进行网络较时。 notrust：该 Client 除非通过认证，否则该 Client 来源将被视为不信任网域 noquery：不提供 Client 端的时间查询 重启NTP服务1sudo /etc/init.d/ntp restart 使用-对时1ntpdate cn.pool.ntp.org 移植NTP服务移植其中包括客户端和服务端 123456789101112#!/bin/bashwget https://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p11.tar.gztar zxvf ntp-4.2.8p11.tar.gzcd ntp-4.2.8p11PWD=`pwd`echo "xxxxxxxxxxxx$PWD"rm $PWD/install -rfmkdir $PWD/installecho "./configure --host=arm-linux CC=arm-gcc49-linux-gnueabi-gcc --prefix=$PWD/install/ --with-yielding-select=yes"./configure --host=arm-linux CC=arm-gcc49-linux-gnueabi-gcc --prefix=$PWD/install/ --with-yielding-select=yesmakemake install 同步1ntpdate 192.168.1.11 修改时区 注意：用date命令查看之后显示的是UTC时间（世界标准时间），比北京时间（CST=UTC+8）相差8个小时，所以需要设置时区 设置时区为CST时间, 把redhat或者ubuntu系统目录/usr/share/zoneinfo/Asia中的文件Shanghai拷贝到开发板目录/etc中并且改名为localtime之后，用命令reboot重启即可 busybox–ntpdbusybox:ntpd 123456789101112131415BusyBox v1.25.1 (2018-05-24 14:59:56 CST) multi-call binary.Usage: ntpd [-dnqNwl -I IFACE] [-S PROG] [-p PEER]...NTP client/server -d Verbose -n Do not daemonize -q Quit after clock is set -N Run at high priority -w Do not set time (only query peers), implies -n -S PROG Run PROG after stepping time, stratum change, and every 11 mins -p PEER Obtain time from PEER (may be repeated) -l Also run as server on port 123 -I IFACE Bind server to IFACE, implies -l clinet1ntpd -p 192.168.1.11 -qNn Server1ntpd -ddnNl 应用–RTP网络延时场景有A和B两个开发板并且通过WIFI直连（P2P）使用TCP协议搭建了RTP，使用RTP进行视频传输，计算其中的网络延时 A — 服务器 — 接收端 — RB — 客户端 — 发射端 — S 时间戳打时间戳gettimeofday获取的时间存放在unsigned long long中需要64bit的空间 12345struct timeval now;unsigned long long rtp_time_r = 0;gettimeofday(&amp;now, NULL);rtp_time_r = 1000000 * now.tv_sec + now.tv_usec; long long和char转换12345678910111213141516171819202122232425262728int main(int argc, const char *argv[])&#123; char dst[30]; unsigned long long rtpTime = 0x1234567898765; unsigned long long rtp_time_s = 0; int i = 0, j = 56; memset(dst, 0, sizeof(char) * 30); for (i = 0; i &lt; sizeof(rtpTime); i++) &#123; dst[19 - i] = （unsigned char）((rtpTime &gt;&gt; j) &amp; 0xFF); //printf("===&gt; func: %s, line: %d, rtpTime: %016llx, %d, dst[%d]=%02x\n", __func__, __LINE__, (rtpTime &gt;&gt; j) &amp; 0xFF, j, 19 - i, dst[19 - i]); j -= 8; &#125; //printf("===&gt; func: %s, line: %d\n", __func__, __LINE__); j = 56; for (i = 0; i &lt; sizeof(rtp_time_s); i++) &#123; rtp_time_s |= (unsigned long long)dst[19 - i] &lt;&lt; j; j -= 8; &#125; printf("===&gt; func: %s, line: %d, old: %016llx\n", __func__, __LINE__, rtpTime); printf("===&gt; func: %s, line: %d, new: %016llx\n", __func__, __LINE__, rtp_time_s); return 0;&#125; 不同的gcc编译器，编译完的运行结果不一样，测试gcc version 6.4.0 20170724 (Debian 6.4.0-2)编译运行结果错误 在嵌入式交叉编译中，测试结果正常： ===&gt; func: main, line: 38, old: 0001234567898765===&gt; func: main, line: 39, new: 0001234567898765 测试方法 一帧数据将会被拆分成多个RTP包进行传输 在S端对每一帧数据中的RTP打入相同的时间戳Ts 在R端将接收到的S端头中的时间戳解析Ts，并且此时获取R端的时间戳Tr 判断一帧的数据，并计算R和S的网络延时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static unsigned long long t_count_t = 0;static unsigned long long t_count_r = 0;static unsigned long long t_count_s = 0;static unsigned long long time_sum_r = 0;static unsigned long long time_sum_s = 0;static unsigned long long rtp_time_s_t = 0;static unsigned long long rtp_time_r_t = 0;static unsigned long long rtp_time_diff = 0;static unsigned long long rtp_time_max = 0;static unsigned long long rtp_time_min = 0xffffff;void parse_rtp_head_time(unsigned char *data, int line)&#123; struct timeval now; unsigned long long rtp_time_r = 0; unsigned long long rtp_time_s = 0; //1. 获取Ｓ端的时间戳 int i = 0, j = 56; for (i = 0; i &lt; sizeof(rtp_time_s); i++) &#123; rtp_time_s |= (unsigned long long)data[19 - i] &lt;&lt; j; j -= 8; &#125; //2. 获取Ｒ端的时间戳 memset(&amp;now, 0, sizeof(now)); gettimeofday(&amp;now, NULL); rtp_time_r = 1000000 * now.tv_sec + now.tv_usec; //3. 判断并计算一帧数据的时间 if (rtp_time_s_t != rtp_time_s) &#123; t_count_t++; if (t_count_t &gt; 3000) &#123; if (rtp_time_r_t &gt;= rtp_time_s_t) &#123; t_count_r++; rtp_time_diff = rtp_time_r_t - rtp_time_s_t; time_sum_r += rtp_time_diff; rtp_time_max = (rtp_time_max &gt; rtp_time_diff) ? rtp_time_max : rtp_time_diff; rtp_time_min = (rtp_time_min &lt; rtp_time_diff) ? rtp_time_min : rtp_time_diff; &#125; else &#123; t_count_s++; time_sum_s += (rtp_time_s_t - rtp_time_r_t); &#125; &#125; rtp_time_s_t = rtp_time_s; &#125; rtp_time_r_t = rtp_time_r; //4. 判断一万帧数据后打印结果 if (!(t_count_t % 10000)) &#123; printf("%llu, t_count_r=%llu, time_sum_r=%llu, v=%llu, max:%llu, min:%llu\n", t_count_t, t_count_r, time_sum_r, (t_count_r != 0) ? (time_sum_r / t_count_r):111111, rtp_time_max, rtp_time_min); printf("%llu, t_count_s=%llu, time_sum_s=%llu, v=%llu\n", t_count_t, t_count_s, time_sum_s, (t_count_s != 0) ? (time_sum_s / t_count_s):111111); &#125;&#125; 操作流程 先启动Ｒ，并进行授时 启动Ｓ端，并进行授时 视频传输，等待计算结果 注意事项 R端必须先启动授时，然后启动S端进行授时，方可进行正常的测试 如果S端先进行授时，而R端后进行授时，那么在R端解析到的S端时间有可能比R端的时间小，导致计算出现负数（越界），最后的结果偏差离谱 参考 移植ntp服务到arm-linux平台 So Easy-Ntp嵌入式软件移植 ubuntu搭建NTP服务器]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>NTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[udev的使用]]></title>
    <url>%2Fpost%2F3820.html</url>
    <content type="text"><![CDATA[udev版本：udev-167 udev 是 Linux2.6 内核里的一个功能，它替代了原来的 devfs，成为当前 Linux 默认的设备管理工具。udev 以守护进程的形式运行，通过侦听内核发出来的 uevent 来管理 /dev目录下的设备文件。不像之前的设备管理工具，udev 在用户空间 (user space) 运行，而不在内核空间 (kernel space) 运行。 udev下载：http://www.kernel.org/pub/linux/utils/kernel/hotplug/ 好处我们都知道，所有的设备在 Linux 里都是以设备文件的形式存在。在早期的 Linux 版本中，/dev目录包含了所有可能出现的设备的设备文件。很难想象 Linux 用户如何在这些大量的设备文件中找到匹配条件的设备文件。现在 udev 只为那些连接到 Linux 操作系统的设备产生设备文件。并且 udev 能通过定义一个 udev 规则 (rule) 来产生匹配设备属性的设备文件，这些设备属性可以是内核设备名称、总线路径、厂商名称、型号、序列号或者磁盘大小等等。 动态管理：当设备添加 / 删除时，udev 的守护进程侦听来自内核的 uevent，以此添加或者删除 /dev下的设备文件，所以 udev 只为已经连接的设备产生设备文件，而不会在 /dev下产生大量虚无的设备文件, 同时根据udev的规则可以在添加/删除时，执行脚本。 自定义命名规则：通过 Linux 默认的规则文件，udev 在 /dev/ 里为所有的设备定义了内核设备名称，比如 /dev/sda、/dev/hda、/dev/fd等等。由于 udev 是在用户空间 (user space) 运行，Linux 用户可以通过自定义的规则文件，灵活地产生标识性强的设备文件名，比如 /dev/boot_disk、/dev/root_disk、/dev/color_printer等等。 设定设备的权限和所有者/组：udev 可以按一定的条件来设置设备文件的权限和设备文件所有者 / 组。在不同的 udev 版本中，实现的方法不同，在“如何配置和使用 udev”中会详解。 工作流程 配置udevudev需要内核sysfs和tmpfs的支持，sysfs为udev提供设备入口和uevent通道，tmpfs为udev设备文件提供存放空间. 使用启动udev的守护进程123mkdir -p /dev/.udevudevd --daemonudevadm trigger 配置文件及规则 目录结构 123456cd /etc/udev├── rules.d │ ├── 22-xxx.rules │ └── 99-fuse.rules └── udev.conf 在规则文件里，除了以“#”开头的行（注释），所有的非空行都被视为一条规则，但是一条规则不能扩展到多行。规则都是由多个 键值对（key-value pairs）组成，并由逗号隔开，键值对可以分为 条件匹配键值对( 以下简称“匹配键 ”) 和 赋值键值对( 以下简称“赋值键 ”)，一条规则可以有多条匹配键和多条赋值键。匹配键是匹配一个设备属性的所有条件，当一个设备的属性匹配了该规则里所有的匹配键，就认为这条规则生效，然后按照赋值键的内容，执行该规则的赋值。下面是一个简单的规则：1KERNEL==&quot;sda&quot;, NAME=&quot;my_root_disk&quot;, MODE=&quot;0660&quot; KERNEL是匹配键，NAME和MODE是赋值键。这条规则的意思是：如果有一个设备的内核设备名称为 sda，则该条件生效，执行后面的赋值：在 /dev下产生一个名为 my_root_disk的设备文件，并把设备文件的权限设为 0660。 添加规则时，多从官方文档（Writing udev rules）获取信息 规则操作符 “==”：比较键、值，若等于，则该条件满足； “!=”： 比较键、值，若不等于，则该条件满足； “=”： 对一个键赋值； “+=”：为一个表示多个条目的键赋值。 “:=”：对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。 规则匹配键 ACTION： 事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。 KERNEL： 内核设备名称，例如：sda, cdrom。 DEVPATH：设备的 devpath 路径。 SUBSYSTEM： 设备的子系统名称，例如：sda 的子系统为 block。 BUS： 设备在 devpath 里的总线名称，例如：usb。 DRIVER： 设备在 devpath 里的设备驱动名称，例如：ide-cdrom。 ID： 设备在 devpath 里的识别号。 SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。 规则赋值键 NAME：在 /dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。 SYMLINK：为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。 OWNER, GROUP, MODE：为设备设定权限。 ENV{key}：导入一个环境变量。 值可调用的替换操作符在键值对中的键和操作符都介绍完了，最后是值 (value)。Linux 用户可以随意地定制 udev 规则文件的值。例如：my_root_disk, my_printer。同时也可以引用下面的替换操作符： $kernel, %k：设备的内核设备名称，例如：sda、cdrom。 $number, %n：设备的内核号码，例如：sda3 的内核号码是 3。 $devpath, %p：设备的 devpath路径。 $id, %b：设备在 devpath里的 ID 号。 $sysfs{file}, %s{file}：设备的 sysfs里 file 的内容。其实就是设备的属性值。 实例hidraw123ACTION!=&quot;add&quot;, GOTO=&quot;uibc_exit&quot;KERNEL==&quot;hidraw2&quot;, SUBSYSTEM==&quot;hidraw&quot;, RUN+=&quot;/etc/udev/xxx.sh&quot;LABEL=&quot;uibc_exit&quot; file: /etc/udev/rules.d/22-xxx.rules SD123action!=&quot;add&quot;,goto=&quot;farsight&quot;kernel==&quot;mmcblk[0-9]p[0-9]&quot;,run+=&quot;/sbin/mount-sd.sh %k&quot;label=&quot;farsight&quot; 注意 在每条规则中，赋值的字符串必须使用双引号括起来。 设备添加/删除后，触发uevent执行RUN+的脚本时，在该脚本中不能直接使用echo输出打印信息，应该导入终端的串口节点。1echo &quot;print debug info ...&quot; &gt; /dev/ttyS000 制定 udev 规则和查询设备信息 如何查找设备的信息 ( 属性 ) 来制定 udev 规则： 查询sysfs文件系统：例如：设备 sda 的 SYSFS{size} 可以通过 cat /sys/block/sda/size得到；SYSFS{model} 信息可以通过 cat /sys/block/sda/device/model得到。 udevadm info1udevadm info --query=all --name=/dev/hidraw2 设备信息：1234567891011# udevadm info --query=all --name=/dev/hidraw2P: /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.2/0003:1C4D:0503.0003/hidraw/hidraw2N: hidraw2S: usb/by-devid/_/hidraw2E: UDEV_LOG=3E: DEVPATH=/devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.2/0003:1C4D:0503.0003/hidraw/hidraw2E: MAJOR=251E: MINOR=2E: DEVNAME=/dev/hidraw2E: SUBSYSTEM=hidrawE: DEVLINKS=/dev/usb/by-devid/_/hidraw2 调试查看udev是否处理内核的uevent事件1udevadm monitor 例如：U盘的插入/拔出123456789101112131415161718192021222324252627282930313233343536# udevadm monitormonitor will print the received events for:UDEV - the event which udev sends out after rule processingKERNEL - the kernel ueventusb 1-1: new high-speed USB device number 4 using ehci-platformKERNEL[209.826989] add usb-storage 1-1:1.0: USB Mass Storage device detected /devices/platform/soscsi host0: usb-storage 1-1:1.0c/f9890000.ehci/usb1/1-1 (usb)KERNEL[209.827627] add /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0 (usb)UDEV [209.834354] add /devices/platform/soc/f9890000.ehci/usb1/1-1 (usb)...UDEV [209.841660] add /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/scsi_host/host0 (scsi_host)scsi 0:0:0:0: Direct-Access General UDisk 5.00 PQ: 0 ANSI: 2KERNEL[210.848174] add /devsd 0:0:0:0: [sda] 15728640 512-byte logical blocks: (8.05 GB/7.50 GiB)ices/platform/soc/f98900sd 0:0:0:0: [sda] Write Protect is off00.ehci/usb1/1-1/1-1:1.0sd 0:0:0:0: [sda] No Caching mode page found/host0/target0:0sd 0:0:0:0: [sda] Assuming drive cache: write through:0 (scsi)KERNEL[210.848626] add /devices/platform/soc/f9890000.ehci/usb1/ sda: sda1 sda21-1/1-1:1.0/host0/target0:0:0/0:0:0:0 (scsi)KERNEL[210.848995]sd 0:0:0:0: [sda] Attached SCSI removable disk add /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_disk/0:0:0:0 (scsi_disk)KERNEL[210.849804] add /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)UDEV [210.858522] add /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)...dudisk1110 -&gt; /dev/sdaudisk1110p1 -&gt; /dev/sda1usb usb1-port1: disabled by hub (EMI?), re-enabling...usb 1-1: USB disconnect, device number 4KERNEL[213.650748] remove /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)...UDEV [213.652991] remove /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)KERNEL[213.653175] remove /devices/virtual/bdi/8:0 (bdi)UDEV [213.774157] remove /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0 (usb) 重启udev1udevadm trigger --type=devices --action=change Q&amp;Audev 和 devfs 是什么关系udev 完全在用户态 (userspace) 工作，利用设备加入或移除时内核所发送的hotplug 事件 (event) 来工作。关于设备的详细信息是由内核输出 (export) 到位于 /sys 的 sysfs 文件系统的。所有的设备命名策略、权限控制和事件处理都是在用户态下完成的。与此相反，devfs 是作为内核的一部分工作的。 参考 Writing udev rules 使用 udev 高效、动态地管理 Linux 设备文件 udev使用方法（附实例）]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>udev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB HID Report描述符]]></title>
    <url>%2Fpost%2F40274.html</url>
    <content type="text"><![CDATA[在USB的枚举后，即交互完 设备描述符(device descriptor),配置描述符(configure descriptor),接口描述符(interface descriptor)和终端描述符(endpointer desciptor)。如果是HID设备，即class值为3设备交互还会发送一系统的特殊包来描述HID设备的特性。 这一些描述HID的特性称为Report Descriptor,报告描述符，可以理解它们是HID设备的上传的包，或者接收的包的格式。设备能包含多个report(测试出错) 主要参考官网文档：HID Information 对于每种HID动作的编码，HID有一个专用术语usage (用法），USB协议中支持所有编码表称为usage tables.这里有全部编码表HID Usage Tables 1.12 Report Descriptor在usb.org网站有HID decriptor tools工具下载 可以用创建和解析report descriptor包格式http://www.usb.org/developers/hidpage/dt2_4.zip 一个完整的report 分为二部分，一部分定长的头，另一部分就是变长的定义, 每个collection由若干个usage组成. 在Collection中，每一个组成部分以称为item,item就是usage.A1 01 与 C0之间表示Application Collection的. usage 说明 input 输入数据格式 output 输出数据格式 Logical Minimum 取值范围 logical_maximum 取值范围 physical_minimum 取值范围 physical_maximum 取值范围 report size report输入字节宽度 report count report总数 获取描述符 工具： USBlyzer （Bus Hound同样也可以抓取，但是需要自己解析） 实例分析（鼠标）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748HID DescriptorOffset Field Size Value Description0 bLength 1 09h 1 bDescriptorType 1 21h HID2 bcdHID 2 0111h 1.114 bCountryCode 1 00h 5 bNumDescriptors 1 01h 6 bDescriptorType 1 22h Report7 wDescriptorLength 2 002Eh 46 bytes &lt;-------描述符大小Endpoint Descriptor 81 1 In, Interrupt, 10 msOffset Field Size Value Description0 bLength 1 07h 1 bDescriptorType 1 05h Endpoint2 bEndpointAddress 1 81h 1 In3 bmAttributes 1 03h Interrupt 1..0: Transfer Type ......11 Interrupt 7..2: Reserved 000000.. 4 wMaxPacketSize 2 0004h 4 bytes &lt;-----------包数据宽度6 bInterval 1 0Ah 10 msInterface 0 HID Report Descriptor MouseItem Tag (Value) Raw DataUsage Page (Generic Desktop) 05 01 Usage (Mouse) 09 02 Collection (Application) A1 01 Usage (Pointer) 09 01 Collection (Physical) A1 00 Usage Page (Button) 05 09 Usage Minimum (Button 1) 19 01 Usage Maximum (Button 3) 29 03 Logical Minimum (0) 15 00 Logical Maximum (1) 25 01 Report Count (8) 95 08 Report Size (1) 75 01 Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 81 02 Usage Page (Generic Desktop) 05 01 Usage (X) 09 30 Usage (Y) 09 31 Usage (Wheel) 09 38 Logical Minimum (-127) 15 81 Logical Maximum (127) 25 7F Report Size (8) 75 08 Report Count (3) 95 03 Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06 End Collection C0 End Collection C0 获取数据格式–Input从Report描述符可以获取信息，鼠标输入的数据可以分两部分： 序号 设备类型 格式 宽度 大小 取值范围 1 Usage Page (Button) Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) Report Size (1) Report Count (8) Logical Minimum (0) ~ Logical Maximum (1) 2 Usage Page (Generic Desktop) Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) Report Size (8) Report Count (3) Logical Minimum (-127) ~ Logical Maximum (127) 数据格式：1234567+---------------+---------------+--------------------------------+| Usage (Wheel) | Usage (Y) | Usage (X) |7|6|5|4|3|2|1||0|+---------------+---------------+--------------------------+-+--++ | | v | v Usage Page (Button) v Usage Minimum (Button 1) Usage Maximum (Button 3) 第一部分：一个字节（Byte），其中每个bit代表一种含义, Usage Page (Button),Usage Minimum (Button 1),Usage Maximum (Button 3) 第二部分：三个字节（Byte），其中一个字节代表一种含义，Usage (X),Usage (Y),Usage (Wheel) 相关文件 Device Class Definition for HID 1.11 HID Usage Tables 1.12 USB HID to PS2 Scan Code Translation Table.pdf USB HID usage table 总结在设备识别阶段多使用bus hound抓取数据包进行分析，在开发板作device时，host可能会获取部分数据（比如触摸屏，需要得到支持几点的触摸操作，默认单点），此时可能会获取失败。 参考 Linux HID 驱动开发(2) USB HID Report 描述及usage 概念 USB HID报告及报告描述符简介 浅析linux下usb鼠标和usb键盘usbhid驱动hid_parse_report报告描述符]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>HID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下常用工具]]></title>
    <url>%2Fpost%2F36295.html</url>
    <content type="text"><![CDATA[Linux下常用工具： ubuntu 18.04 wpshttp://community.wps.cn/download/ 字体：http://wps-community.org/download.html?vl=fonts#download 12sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.debsudo apt -f install wps-office 依赖于 libpng12-0；然而：未安装软件包 libpng12-0。 1234567wget http://ftp.cn.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.49-1+deb7u2_amd64.debsudo dpkg -i libpng12-0_1.2.49-1+deb7u2_amd64.debsudo dpkg -i wps-office_10.1.0.5672~a21_amd64.debsudo dpkg -i wps-office-fonts_1.0_all.deb 缺失字体https://pan.baidu.com/s/1eS6xIzo wps_symbol_fonts.zip 12unzip wps_symbol_fonts.zipsudo cp mtextra.ttf symbol.ttf WEBDINGS.TTF wingding.ttf WINGDNG2.ttf WINGDNG3.ttf /usr/share/fonts 福昕阅读https://www.foxitsoftware.cn/downloads/ 搜狗输入法https://pinyin.sogou.com/linux/?r=pinyin 微信[https://github.com/geeeeeeeeek/electronic-wechat/releases/download/V2.0/linux-x64.tar.gz)[https://github.com/geeeeeeeeek/electronic-wechat/releases/download/V2.0/linux-x64.tar.gz] 钉钉 for Linux 钉钉Linux版 Teamviewer 下载 安装：12sudo dpkg -i teamviewer_13.1.3026_amd64.debsudo apt-get remove teamviewer 如果安装失败，可以更新ubuntu的源，参考：Ubuntu 16.04 安装 TeamViewer 13 主题1sudo apt install gnome-tweak-tool 邮件Evolution 画图1sudo apt-get install kolourpaint4 虚拟机VirtualBox 音视频文件分析工具 – MediaInfo1sudo apt-get install mediainfo mediainfo-gui 词典stardict(星际译王) 1sudo apt install stardict 词典的词库网站下载词库：下载 linux下StarDict和词典的安装 画图–结构图流程图亿图：http://www.edrawsoft.cn/download-edrawmax.php vooyavooya – Raw YUV/RGB Video Player http://www.offminor.de/downloads.html dia流程图 1sudo apt install dia 实时显示上下行网速、CPU及内存使用率12sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt-get install indicator-sysmonitor gedit汉字乱码1gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&apos;GB18030&apos;, &apos;GB2312&apos;, &apos;GBK&apos;, &apos;UTF-8&apos;, &apos;BIG5&apos;, &apos;CURRENT&apos;, &apos;UTF-16&apos;]&quot; ubntu 18.04 Albert全局搜索软件 数据库:sqlitebrowser 官网地址：http://sqlitebrowser.org/ 开源地址：https://github.com/sqlitebrowser/sqlitebrowser DB Browser for SQLite (DB4S) 是一款面向开发者的高质量的，可视化的开源的工具，他可以创建，设计，以及修改SQlite数据库。 1sudo apt-get install sqlitebrowser PyCharm python编辑器 http://www.jetbrains.com/pycharm/ 7yuv查看yuv格式的文件 官网：http://datahammer.de]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows常用工具]]></title>
    <url>%2Fpost%2F14436.html</url>
    <content type="text"><![CDATA[Windows下的常用工具，提高使用效率 简单记录，方便以后重装系统后安装使用。 快速搜素–Listary官网：http://www.listary.com/下载：here 使用：快速启动： Ctrl+Ctrl 读取Ext4分区–ext2explore在Windows和Linux的双系统中，方便在Windows系统下获取Linux中的数据。 ext2explore只能读取文件，无法写入，使用时需要管理员权限运行。（Window10可以使用） Ext2fsd据说最好用(Windows10无法使用) Paragon ExtFS for Windows需要注册对个人免费。 使用：在 Windows 下访问 Ext 分区 系统镜像下载网站：https://msdn.itellyou.cn/ Windows 10 下清理 WinSxS图形界面操作http://www.chuyu.me/zh-Hans/index.html 1Dism.exe /online /Cleanup-Image /StartComponentCleanup /ResetBase 磁盘文件目录大小可视化布局SpaceSniffer SpaceSniffer_1.1.4.0.1399531007 同步软件–FreeFileSyncFreeFileSync 硬盘和U盘的同步 esEye – Elecard StreamEye ToolsesEye 分析264的码流结构 edid_manageredid_managerv1x0 EDID查询]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HID设备--开发板模拟鼠标]]></title>
    <url>%2Fpost%2F5098.html</url>
    <content type="text"><![CDATA[HID HID鼠标裸数据驱动：1234567Symbol: HIDRAW [=y] Type : boolean Prompt: /dev/hidraw raw HID device support Location: -&gt; Device Drivers -&gt; HID support -&gt; HID bus support (HID [=y]) 读取数据1read(uibc-&gt;hid_fd, buf, sizeof(buf)); 鼠标数据格式鼠标的通信格式：4个字节 1BYTE3 BYTE2 BYTE1 BYTE0 Byte BIT7 BIT6 BIT5 BIT4 BIT3 BIT2 BIT1 BIT0 0 1 表示Y坐标的变化量超出－256~255的范围, 0表示没有溢出 1表示X坐标的变化量超出－256~255的范围，0表示没有溢出 Y坐标变化的符号位，1表示负数，即鼠标向下移动 X 坐标变化的符号位，1表示负数，即鼠标向左移动 恒为1 1表示中键按下 1表示右键按下 1表示左键按下 1 X坐标变化量， 与byte的 bit4组成 9位符号数, 负数表示向左移， 正数表右移。 用补码 表示变化量 2 Y坐标变化量， 与byte的 bit5组成 9位符号数， 负数表示向下移， 正数表上移。 用补码 表示变化量 3 滚轮变化。 - - - - - - - 鼠标的一次点击，包含按下和抬起两个动作，这两个动作均会上报事件，抬起时上报的全部为0x0 1234uibc read device raw data[len: 6]: BIT5~BIT0 //按下左键 00 00 00 00 00 01uibc read device raw data[len: 6]: BIT5~BIT0 //抬起左键 00 00 00 00 00 00 开发板模拟鼠标以开发板作为device端,由于鼠标为HID设备，在HID驱动中添加鼠标的device 参考文档：Documentation/usb/gadget_hid.txt, 其中主要时驱动的添加和测试 Device驱动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*hid descriptor for a mouse*/ static struct hidg_func_descriptor vx_device_mouse_data = &#123; .subclass = 0, /*NO SubClass*/ .protocol = 2, /*Mouse*/ .report_length = 6, .report_desc_length = 79, .report_desc=&#123; 0x05,0x01, /*Usage Page (Generic Desktop Controls)*/ 0x09,0x02, /*Usage (Mouse)*/ 0xa1,0x01, /*Collction (Application)*/ 0x09,0x01, /*Usage (pointer)*/ 0xa1,0x00, /*Collction (Physical)*/ 0x05,0x09, /*Usage Page (Button)*/ 0x19,0x01, /*Usage Minimum(1)*/ 0x29,0x05, /*Usage Maximum(3) */ 0x15,0x00, /*Logical Minimum(1)*/ 0x25,0x01, /*Logical Maximum(1)*/ 0x95,0x05, /*Report Count(5) */ 0x75,0x01, /*Report Size(1)*/ 0x81,0x02, /*Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit)*/ 0x95,0x01, /*Report Count(1)*/ 0x75,0x03, /*Report Size(3) */ 0x81,0x01, /*Input (Cnst,Ary,Abs) */ 0x05,0x01, /*Usage Page (Generic Desktop Controls)*/ 0x09,0x30, /*Usage(x)*/ 0x09,0x31, /*Usage(y)*/ 0x16,0x00,0xF8, /*Logical Minimum (-2048)*/ 0x26,0xFF,0x07, /*Logical Maximum (2047)*/ 0x75,0x0C, /*Report Size(12)*/ 0x95,0x02, /*Report Count(2) */ 0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)*/ 0x09,0x38, /*Usage(Wheel)*/ 0x15,0x81, /*Logical Minimum(-127)*/ 0x25,0x7f, /*Logical Maximum(127)*/ 0x75,0x08, /*Report Size(8)*/ 0x95,0x01, /*Report Count(1) */ 0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)*/ 0x05,0x0C, /*Usage Page (Consumer Devices) */ 0x0A,0x38,0x02, /*Usage (AC Pan)*/ 0x95,0x01, /*Report Count (1) */ 0x75,0x08, /*Report Size (8)*/ 0x15,0x81, /*Logical Minimum (-127) */ 0x25,0x7F, /*Logical Maximum (127)*/ 0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) */ 0xc0, /*End Collection*/ 0xc0 /*End Collection*/ &#125; &#125;; static struct platform_device vx_device_hid_mouse = &#123; .name = &quot;hidg&quot;, .id = 1, .num_resources = 0, .resource = 0, .dev.platform_data = &amp;vx_device_mouse_data, &#125;; static int __init hidg_init(void) &#123; int status; status = platform_device_register(&amp;vx_device_hid_mouse); if (status &lt; 0) &#123; printk(&quot;f:%s, l:%d, platform_driver hid mouse error\n&quot;, __func__, __LINE__); return status; &#125; &#125; module_init(hidg_init); kernel: linux3.4.35, file:drivers/usb/gadget/hid.c hidg_func_descriptor1234567struct hidg_func_descriptor &#123; unsigned char subclass; unsigned char protocol; unsigned short report_length; unsigned short report_desc_length; unsigned char report_desc[]; &#125;; file: include/linux/usb/g_hid.h 主要是一个设备如何填充struct hidg_func_descriptor数据结构。 You can add as many HID functions as you want, only limited by the amount of interrupt endpoints your gadget driver supports. 添加hidg设备的个数，受USB的endpoint的限制，如果endpoint只有一对，只能添加一个hidg0设备。 获取USB鼠标HID Descriptor 工具：USBlyzer 官网下载地址：http://www.usblyzer.com/download.htm 下载：http://bbs.armfly.com/job.php?action=download&amp;aid=9919 Device Descriptor12345678910111213141516Device Descriptor USB OPTICAL MOUSEOffset Field Size Value Description0 bLength 1 12h 1 bDescriptorType 1 01h Device2 bcdUSB 2 0110h USB Spec 1.14 bDeviceClass 1 00h Class info in Ifc Descriptors`5 bDeviceSubClass 1 00h` 6 bDeviceProtocol 1 00h 7 bMaxPacketSize0 1 08h 8 bytes8 idVendor 2 0101h 10 idProduct 2 0007h 12 bcdDevice 2 0100h 1.0014 iManufacturer 1 00h 15 iProduct 1 01h &quot;USB OPTICAL MOUSE &quot;16 iSerialNumber 1 00h 17 bNumConfigurations 1 01h Interface Descriptor1234567891011Interface Descriptor 0/0 HID, 1 EndpointOffset Field Size Value Description0 bLength 1 09h 1 bDescriptorType 1 04h Interface2 bInterfaceNumber 1 00h 3 bAlternateSetting 1 00h 4 bNumEndpoints 1 01h 5 bInterfaceClass 1 03h HID6 bInterfaceSubClass 1 01h Boot Interface`7 bInterfaceProtocol 1 02h Mouse`8 iInterface 1 00h HID Descriptor1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162HID DescriptorOffset Field Size Value Description0 bLength 1 09h 1 bDescriptorType 1 21h HID2 bcdHID 2 0111h 1.114 bCountryCode 1 00h 5 bNumDescriptors 1 01h 6 bDescriptorType 1 22h Report`7 wDescriptorLength 2 004Fh 79 bytes`Endpoint Descriptor 81 1 In, Interrupt, 10 msOffset Field Size Value Description0 bLength 1 07h 1 bDescriptorType 1 05h Endpoint2 bEndpointAddress 1 81h 1 In3 bmAttributes 1 03h Interrupt 1..0: Transfer Type ......11 Interrupt 7..2: Reserved 000000.. `4 wMaxPacketSize 2 0006h 6 bytes`6 bInterval 1 0Ah 10 msInterface 0 HID Report Descriptor Mouse`Item Tag (Value) Raw Data`Usage Page (Generic Desktop) 05 01 Usage (Mouse) 09 02 Collection (Application) A1 01 Usage (Pointer) 09 01 Collection (Physical) A1 00 Usage Page (Button) 05 09 Usage Minimum (Button 1) 19 01 Usage Maximum (Button 5) 29 05 Logical Minimum (0) 15 00 Logical Maximum (1) 25 01 Report Count (5) 95 05 Report Size (1) 75 01 Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 81 02 Report Count (1) 95 01 Report Size (3) 75 03 Input (Cnst,Ary,Abs) 81 01 Usage Page (Generic Desktop) 05 01 Usage (X) 09 30 Usage (Y) 09 31 Logical Minimum (-2048) 16 00 F8 Logical Maximum (2047) 26 FF 07 Report Size (12) 75 0C Report Count (2) 95 02 Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06 Usage (Wheel) 09 38 Logical Minimum (-127) 15 81 Logical Maximum (127) 25 7F Report Size (8) 75 08 Report Count (1) 95 01 Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06 Usage Page (Consumer Devices) 05 0C Usage (AC Pan) 0A 38 02 Report Count (1) 95 01 Report Size (8) 75 08 Logical Minimum (-127) 15 81 Logical Maximum (127) 25 7F Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06 End Collection C0 End Collection C0 hidg_func_descriptor 与 HID Descriptor hidg_func_descriptor HID Descriptor subclass bDeviceSubClass protocol bInterfaceProtocol report_length wMaxPacketSize report_desc_length wDescriptorLength report_desc[] Item Tag (Value) Raw Data 调试Bus Hound是一个超级软件总线协议分析器,用于捕捉来自设备的协议包和输入输出操作 参考 s3c6410 linux gadget hid驱动 DM816X 实现 USB HID Gadget 鼠标键盘功能 linux 读取 USB HID鼠标坐标和点击 在 LCD上显示 Linux之访问/dev/hidraw USB与BT HID reports描述符实践与抓包分析 usb hid gadget模拟鼠标键盘 USB/HID设备报告描述符详解]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>HID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tftp]]></title>
    <url>%2Fpost%2F3037.html</url>
    <content type="text"><![CDATA[tftp: 安装软件包：tftpd（服务端），tftp（客户端），xinetd 1sudo apt-get install tftpd tftp xinetd 建立配置文件：12345678910111213vi /etc/xinetd.d/tftpservice tftp&#123; protocol = udp port = 69 socket_type = dgram wait = yes user = nobody server = /usr/sbin/in.tftpd server_args = /home/xxx/tftprootfs disable = no&#125; 重启服务1sudo /etc/init.d/xinetd restart window工具–tftpd服务下载：tftpd32 本地测试123$tftp localhosttftp&gt; get aaaReceived 8 bytes in 0.0 seconds 开发板使用下载： 1tftp –gr 源文件名 服务器地址 上传： 1tftp –pr 目标文件名 服务器地址]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN的基础使用]]></title>
    <url>%2Fpost%2F56583.html</url>
    <content type="text"><![CDATA[svn的基础使用命令： 安装1sudo apt-get install subversion 命令行使用下载代码1svn checkout svn_path local_path 添加新文件 将新的文件添加到代码仓库中,如果一个文件不在版本则需要使用add添加1svn add files --no-ignore: disregard default and svn:ignore and svn:global-ignores property ignores(忽略默认值和 svn:ignore 属性) --force: 强制添加 递归添加1svn add . --no-ignore --force 更新1svn update 修改提交1svn commit -m path-to-commit，其中path-to-commit可以为空 查看log1svn log -v : 显示修改目录 回退到某一个（r123）log1svn up -r r123 创建分支1svn copy -m &quot;create branch&quot; http://svn_server/xxx_repository http://svn_server/xxx_repository/br_feature001 分支名： br_feature001 切换分支1svn switch http://svn_server/xxx_repository/br_feature001 删除分支1svn rm http://svn_server/xxx_repository/br_feature001 恢复本地修改1revert PATH... 提交代码 将代码更新到与目前版本库里一致（svn up），如果存在冲突解决冲突 使用(svn st)查看所有文件状态，判断使用有新添加的文件，如果有新添加的文件，使用(svn add)将新文件添加到版本库 在确定提交前，使用（svn st）查看是否有多余的修改，如果有将其退回（svn revert） 提交代码1svn commit -m &quot;备注修改的目的&quot; 补丁-patch制作补丁1svn diff &gt; patch.diff 打补丁1patch &lt; to-file.patch 取消补丁1patch -RE &lt; to-file.patch -R: 取消打过的补丁-E: 选项说明如果发现了空文件，那么就删除它 示例–创建分支提交12345svn upsvn copy http://172.16.180.100/svn/Hi3798MV200 http://172.16.180.100/svn/Hi3798MV200/Hi3798MV200_M -m &quot;single S multi R code branch&quot;svn 图形界面使用RapidSVN]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vanxum]]></title>
    <url>%2Fpost%2F4813.html</url>
    <content type="text"></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mips指令集]]></title>
    <url>%2Fpost%2F25760.html</url>
    <content type="text"><![CDATA[注意使用jr.hb、jal.hb等硬件屏障指令。(hardware barrier)]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>指令</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nbench]]></title>
    <url>%2Fpost%2F18855.html</url>
    <content type="text"><![CDATA[nbench是一个简单的用于测试处理器，存储器性能的基准测试程序。即著名的BYTE Magazine杂志的BYTEmark benchmark program。nbench在系统中运行并将结果和一台运行Linux的AMD K6-233电脑比较，得到的比值作为性能指数。由于是完全开源的，爱好者可以在各种平台和操作系统上运行nbench，并进行优化和测试，是一个简单有效的性能测试工具。nbench的结果主要分为MEM、INT和FP，其中MEM指数主要体现处理器总线、CACHE和存储器性能，INT当然是整数处理性能，FP则体现双精度浮点性能 下载&amp;编译123$git clone https://github.com/Winddoing/nbench.git$git checkout arch-mips-test$make 测试运行./nbench mips]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nbench</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核DMA机制]]></title>
    <url>%2Fpost%2F59370.html</url>
    <content type="text"><![CDATA[DMA的映射机制 DMA的数据处理 DMA物理通道和逻辑通道 DMA地址空间的排布 一致性和流式DMA的定义和区别 参考 Linux 内核DMA机制 内核文档 Kernel Korner - Using DMA LDD3-ch15 DMAR 与 IOMMU]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>DMA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ext4文件系统变为只读]]></title>
    <url>%2Fpost%2F31493.html</url>
    <content type="text"><![CDATA[123[ 7965.955384] EXT4-fs error (device mmcblk0p7): ext4_mb_generate_buddy:758: group 3, block bitmap and bg descriptor inconsistent: 1901 vs 1900 free clusters[ 7965.963826] EXT4-fs (mmcblk0p7): Remounting filesystem read-only[ 7965.975652] EXT4-fs (mmcblk0p7): ext4_writepages: jbd2_start: 2147483644 pages, ino 6032; err -30 ext4文件系统bug，在linux4.6.7中以修复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657commit d123a55f85f5116d686dac80c768ee5c34ec8e06Author: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;Date: Thu Jul 14 23:21:35 2016 -0400 ext4: short-cut orphan cleanup on error commit c65d5c6c81a1f27dec5f627f67840726fcd146de upstream. If we encounter a filesystem error during orphan cleanup, we should stop. Otherwise, we may end up in an infinite loop where the same inode is processed again and again. EXT4-fs (loop0): warning: checktime reached, running e2fsck is recommended EXT4-fs error (device loop0): ext4_mb_generate_buddy:758: group 2, block bitmap and bg descriptor inconsistent: 6117 vs 0 free clusters Aborting journal on device loop0-8. EXT4-fs (loop0): Remounting filesystem read-only EXT4-fs error (device loop0) in ext4_free_blocks:4895: Journal has aborted EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted EXT4-fs error (device loop0) in ext4_ext_remove_space:3068: IO failure EXT4-fs error (device loop0) in ext4_ext_truncate:4667: Journal has aborted EXT4-fs error (device loop0) in ext4_orphan_del:2927: Journal has aborted EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted EXT4-fs (loop0): Inode 16 (00000000618192a0): orphan list check failed! [...] EXT4-fs (loop0): Inode 16 (0000000061819748): orphan list check failed! [...] EXT4-fs (loop0): Inode 16 (0000000061819bf0): orphan list check failed! [...] See-also: c9eb13a9105 (&quot;ext4: fix hang when processing corrupted orphaned inode list&quot;) Cc: Jan Kara &lt;jack@suse.cz&gt; Signed-off-by: Vegard Nossum &lt;vegard.nossum@oracle.com&gt; Signed-off-by: Theodore Ts&apos;o &lt;tytso@mit.edu&gt; Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;diff --git a/fs/ext4/super.c b/fs/ext4/super.cindex 089821b..7fca76b 100644--- a/fs/ext4/super.c+++ b/fs/ext4/super.c@@ -2277,6 +2277,16 @@ static void ext4_orphan_cleanup(struct super_block *sb, while (es-&gt;s_last_orphan) &#123; struct inode *inode;+ /*+ * We may have encountered an error during cleanup; if+ * so, skip the rest.+ */+ if (EXT4_SB(sb)-&gt;s_mount_state &amp; EXT4_ERROR_FS) &#123;+ jbd_debug(1, &quot;Skipping orphan recovery on fs with errors.\n&quot;);+ es-&gt;s_last_orphan = 0;+ break;+ &#125;+ inode = ext4_orphan_get(sb, le32_to_cpu(es-&gt;s_last_orphan)); if (IS_ERR(inode)) &#123; es-&gt;s_last_orphan = 0; linux v4.x ChangeLog-4.6.7 产生的原因：]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC内嵌汇编(mips)]]></title>
    <url>%2Fpost%2F55412.html</url>
    <content type="text"><![CDATA[以MIPS架构的汇编为主进行说明 12345678__asm__ __volatile__( &quot;1: ll %1, %2 # arch_read_lock \n&quot; &quot; bltz %1, 1b \n&quot; &quot; addu %1, 1 \n&quot; &quot;2: sc %1, %0 \n&quot; : &quot;=m&quot; (rw-&gt;lock), &quot;=&amp;r&quot; (tmp) : &quot;m&quot; (rw-&gt;lock) : &quot;memory&quot;); 基本形式： __asm__ __volatile__(&quot;ssnop\n\t&quot;); ssnop: 空指令 汇编扩展以__asm__开头表示后面部分为汇编,__volatile__严禁将此处的汇编语句和其他语句进行重组优化，就是希望gcc不要修改我们这个部分。 构成主要由四部分构成,之间以:分隔： instruction指令:每条指令之后最好使用&quot;\n\t&quot;结尾,这样在gcc产生汇编格式比较好. output operand输出:每个输出部分使用,分隔.”=”作为修饰符,”m”表示存放位置/约束符,()里面表示对应C程序值. input operand输入:这个部分和输出是一样的. clobber(装备):这个部分是告诉gcc在这条指令里面我们会修改什么值. 约束符束符影响的内容包括: whether an operand may be in a registerwhich kinds of registerwhether the operand can be a memory referencewhich kinds of addresswhether the operand may be an immediate constantwhich possible values it may have 约束符包括: p 内存地址 m 内存变量 o 内存变量,但是寻址方式必须是偏移量的,就是基址寻址或者是基址变址寻址. V 内存变量,但是寻址方式是非偏移量的. r general寄存器操作数 i 立即操作数,内容在编译器可以确定. n 立即操作数.有些系统不支持字(双字节)以外的立即操作数,这些操作数以n非i来表示. E/F 浮点常数 g 内存操作数,整数常数,非genernal寄存器操作数 X 任何操作数 0,1,2…9 和编号指定操作数匹配的操作数束符影响的内容包括 修饰符修饰符包括: = 操作数是write only的 + 操作数是可读可写的 &amp; 常用于输出限定符,表示某个寄存器不会被输入所使用. 12345678__asm__ __volatile__(&quot; .set mips3 \n&quot;&quot; ll %0, %1 # atomic_sub \n&quot;&quot; subu %0, %2 \n&quot;&quot; sc %0, %1 \n&quot;&quot; .set mips0 \n&quot;: &quot;=&amp;r&quot; (temp), &quot;+m&quot; (v-&gt;counter): &quot;Ir&quot; (i)); 实例读取CP0 25号硬件计数寄存器的值1234567891011int get_counter()&#123; int rst; __asm__ __volatile__( /* mfc0 为取cp0 寄存器值的指令 */ &quot;mfc0 %0, $25\n\t&quot; /* %0 表示列表开始的第一个寄存器 */ : &quot;=r&quot; (rst) /* 告诉gcc 让rst对应一个通用寄存器 */ ); return rst;&#125; “=r” 中，’=’ 为修饰符，表示该操作对象只写，一般用于修饰输出参数列表中。’r’ 表示任意一个通用寄存器 设置CP0 24号硬件计数寄存器的值1234567unsigned int op = 0x80f;__asm__ __volatile__(&quot;mtc0 %0, $24\n\t&quot;: /* 没有输出，列表为空 */:&quot;r&quot;(op) /* 输入参数，告诉gcc 让op对应一个通用寄存器 */); 重设后，读取CP0 24号寄存器的值123456789unsigned int rst;unsigned int op = 0x80f;__asm__ __volatile__(&quot;mtc0 %1, $24\n\t&quot; /* %1 表示 op 对应的寄存器 */&quot;mfc0 %0, $25\n\t&quot; /* %0 表示 rst 对应的寄存器 */: &quot;=r&quot; (rst): &quot;r&quot; (op)); 输入输出参数列表，按先后顺序，从0开始编号, %0, %1。 解读开头汇编代码读写锁中读锁上锁的汇编实现： 12345678__asm__ __volatile__( &quot;1: ll %1, %2 # arch_read_lock \n&quot; &quot; bltz %1, 1b \n&quot; &quot; addu %1, 1 \n&quot; &quot;2: sc %1, %0 \n&quot; : &quot;=m&quot; (rw-&gt;lock), &quot;=&amp;r&quot; (tmp) : &quot;m&quot; (rw-&gt;lock) : &quot;memory&quot;); &quot;=m&quot; (rw-&gt;lock): 只写内存操作&quot;=&amp;r&quot; (tmp) : 只写的输出变量，使用一个通用寄存器&quot;memory&quot;: 告诉gcc编译，该指令会修改内存中的值 通过原子操作ll,将rw-&gt;lock读到tmp 加一：tmp = tmp + 1 通过原子操作sc,将tmp写入rw-&gt;lock barrier内存屏障：保证前后指令的执行顺序 1#define barrier() __asm__ __volatile__("": : :"memory") file: include/linux/compiler-gcc.h &quot;memory&quot;作为clobber部分另外一个作用是可以让在这条指令之后的指令,告诉gcc应该刷新内存状态.内存的状态可能发生修改,如果需要操作的话,需要重新把内存内容载入寄存器 参考 MIPS GCC 嵌入式汇编 GCC内嵌汇编]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>mips</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制【rwlock】]]></title>
    <url>%2Fpost%2F42371.html</url>
    <content type="text"><![CDATA[读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。 数据结构rwlock_t12345678910111213typedef struct &#123; arch_rwlock_t raw_lock;#ifdef CONFIG_GENERIC_LOCKBREAK unsigned int break_lock;#endif#ifdef CONFIG_DEBUG_SPINLOCK unsigned int magic, owner_cpu; void *owner;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map dep_map;#endif&#125; rwlock_t; file: include/linux/rwlock_types.h arch_rwlock_tMIPS123typedef struct &#123; volatile unsigned int lock;&#125; arch_rwlock_t; file: arch/mips/include/asm/spinlock_types.h 通用接口API rwlock_init 123456789#define __ARCH_RW_LOCK_UNLOCKED &#123; 0 &#125;#define __RW_LOCK_UNLOCKED(lockname) \ (rwlock_t) &#123; .raw_lock = __ARCH_RW_LOCK_UNLOCKED, \ RW_DEP_MAP_INIT(lockname) &#125;# define rwlock_init(lock) \ do &#123; *(lock) = __RW_LOCK_UNLOCKED(lock); &#125; while (0) 初始化rwlock_t-&gt;raw_lock-&gt;lock=0 R/W lock 12#define write_lock(lock) _raw_write_lock(lock)#define read_lock(lock) _raw_read_lock(lock) file: include/linux/rwlock.h 实现读写锁包括读取锁和写入锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁； 也就是说读写锁要确保的是如下互斥关系：可以同时读，但是读-写，写-写都是互斥的； 读锁 123456read_lock |-&gt;_raw_read_lock |-&gt;__raw_read_lock |-&gt;preempt_disable(); |-&gt;rwlock_acquire_read(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_); |-&gt;LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock); 在读锁上锁时与spinlock的流程基本相同，都会关闭内核抢占，因此读写锁中也不能睡眠 12# define do_raw_read_trylock(rwlock) arch_read_trylock(&amp;(rwlock)-&gt;raw_lock)# define do_raw_read_lock(rwlock) do &#123;__acquire(lock); arch_read_lock(&amp;(rwlock)-&gt;raw_lock); &#125; while (0) file: include/linux/rwlock.h MIPS不同架构的实现： arch_read_lock1234567891011121314151617static inline void arch_read_lock(arch_rwlock_t *rw)&#123; unsigned int tmp; do &#123; __asm__ __volatile__( "1: ll %1, %2 # arch_read_lock \n" " bltz %1, 1b \n" " addu %1, 1 \n" "2: sc %1, %0 \n" : "=m" (rw-&gt;lock), "=&amp;r" (tmp) : "m" (rw-&gt;lock) : "memory"); &#125; while (unlikely(!tmp)); smp_llsc_mb();&#125; bltz $s,offset &lt;==&gt; if($s&lt; 0) jump(offset « 2); 小于0，跳转 内嵌汇编源码：123456c2020000 ll v0,0(s0)0440fffe bltz v0,8021c8f8 &lt;do_raw_read_lock+0x38&gt;00000000 nop24420001 addiu v0,v0,1e2020000 sc v0,0(s0)1040fffa beqz v0,8021c8f8 &lt;do_raw_read_lock+0x38&gt; 上读锁是通过原子操作对rwlock_t-&gt;raw_lock-&gt;lock += 1 arch_read_unlock12345678910111213141516static inline void arch_read_unlock(arch_rwlock_t *rw)&#123; unsigned int tmp; smp_mb__before_llsc(); do &#123; __asm__ __volatile__( "1: ll %1, %2 # arch_read_unlock \n" " sub %1, 1 \n" " sc %1, %0 \n" : "=m" (rw-&gt;lock), "=&amp;r" (tmp) : "m" (rw-&gt;lock) : "memory"); &#125; while (unlikely(!tmp));&#125; 解读锁是通过原子操作对rwlock_t-&gt;raw_lock-&gt;lock -= 1 arch_write_lock1234567891011121314151617static inline void arch_write_lock(arch_rwlock_t *rw)&#123; unsigned int tmp; do &#123; __asm__ __volatile__( "1: ll %1, %2 # arch_write_lock \n" " bnez %1, 1b \n" " lui %1, 0x8000 \n" "2: sc %1, %0 \n" : "=m" (rw-&gt;lock), "=&amp;r" (tmp) : "m" (rw-&gt;lock) : "memory"); &#125; while (unlikely(!tmp)); smp_llsc_mb();&#125; lui $t,imm &lt;==&gt; $t=(imm « 16)将立即数左移16位，低16位补零 内嵌汇编反汇编源码：123456c2020000 ll v0,0(s0)1440fffe bnez v0,8021ca08 &lt;do_raw_write_lock+0x70&gt;00000000 nop3c028000 lui v0,0x8000e2020000 sc v0,0(s0)1040fffa beqz v0,8021ca08 &lt;do_raw_write_lock+0x70&gt; arch_write_unlock1234567891011static inline void arch_write_unlock(arch_rwlock_t *rw)&#123; smp_mb(); __asm__ __volatile__( " # arch_write_unlock \n" " sw $0, %0 \n" : "=m" (rw-&gt;lock) : "m" (rw-&gt;lock) : "memory");&#125; Q&amp;A 读锁怎么实现可以存在多个读者进行处理？？ 读写锁与SMP多核之间的线程处理关系？？ 参考 Linux下写者优先的读写锁的设计 读/写自旋锁]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC编译器的优化： fprefetch-loop-arrays]]></title>
    <url>%2Fpost%2F14105.html</url>
    <content type="text"><![CDATA[以MIPS架构为基础进行分析预取指令：pref 指令预取，是指提前将所需要的数据取出来，在使用时可用 for loop1234567891011121314151617volatile unsigned char aa[4096];int func()&#123; int i; __asm__ __volatile__("ssnop\n\t"); __asm__ __volatile__("ssnop\n\t"); for(i = 0; i &lt; 4096; i++) &#123; aa[i] = i; &#125; __asm__ __volatile__("ssnop\n\t"); __asm__ __volatile__("ssnop\n\t"); return 0;&#125; 编译： 12&gt;mips-linux-gnu-gcc -c for_loop.c -o for_loop.o&gt; 反汇编：1mips-linux-gnu-objdump -d for_loop.o &gt; for_loop.s 123456789101112131415161718192021222324252627282930313200000000 &lt;func&gt;: 0: 27bdffe8 addiu sp,sp,-24 4: afbe0014 sw s8,20(sp) 8: 03a0f025 move s8,sp c: 00000040 ssnop 10: 00000040 ssnop 14: afc00008 sw zero,8(s8) 18: 1000000b b 48 &lt;func+0x48&gt; 1c: 00000000 nop 20: 8fc20008 lw v0,8(s8) 24: 304300ff andi v1,v0,0xff 28: 3c020000 lui v0,0x0 2c: 24440000 addiu a0,v0,0 30: 8fc20008 lw v0,8(s8) 34: 00821021 addu v0,a0,v0 38: a0430000 sb v1,0(v0) 3c: 8fc20008 lw v0,8(s8) 40: 24420001 addiu v0,v0,1 44: afc20008 sw v0,8(s8) 48: 8fc20008 lw v0,8(s8) 4c: 28421000 slti v0,v0,4096 50: 1440fff3 bnez v0,20 &lt;func+0x20&gt; 54: 00000000 nop 58: 00000040 ssnop 5c: 00000040 ssnop 60: 00001025 move v0,zero 64: 03c0e825 move sp,s8 68: 8fbe0014 lw s8,20(sp) 6c: 27bd0018 addiu sp,sp,24 70: 03e00008 jr ra 74: 00000000 nop ... 优化for循环的优化，对大数组的赋值 -fprefetch-loop-arrays 生成数组预读取指令，对于使用巨大数组的程序可以加快代码执行速度，适合数据库相关的大型软件等 gcc默认没有开预取指令的优化，需要通过-O3 编译： 12&gt;mips-linux-gnu-gcc -c for_loop.c -o for_loop.o -O3 -fprefetch-loop-arrays&gt; 反汇编：123456789101112131415161718192021222324252627282930313233343536373839404142434445464700000000 &lt;func&gt;: 0: 27bdff00 addiu sp,sp,-256 4: afbe00fc sw s8,252(sp) ... 24: afb000dc sw s0,220(sp) 28: 00000040 ssnop 2c: 00000040 ssnop 30: 3c020000 lui v0,0x0 34: 00002025 move a0,zero 38: 00001825 move v1,zero 3c: 24460000 addiu a2,v0,0 40: 306200ff andi v0,v1,0xff 44: afa20008 sw v0,8(sp) ... a0: afbe0054 sw s8,84(sp) a4: 24960019 addiu s6,a0,25 a8: 00d7f021 addu s8,a2,s7 ac: 93b70010 lbu s7,16(sp) b0: 24820004 addiu v0,a0,4 ... 424: a0b40000 sb s4,0(a1) 428: 8fa500a8 lw a1,168(sp) 42c: 93b40010 lbu s4,16(sp) 430: a0b40000 sb s4,0(a1) 434: 8fa500ac lw a1,172(sp) ... 474: a12a0000 sb t2,0(t1) 478: a0e80000 sb t0,0(a3) 47c: a0450000 sb a1,0(v0) 480: 24020fe0 li v0,4064 484: 1462feee bne v1,v0,40 &lt;func+0x40&gt; 488: 24051000 li a1,4096 48c: 304400ff andi a0,v0,0xff 490: 00c21821 addu v1,a2,v0 494: 24420001 addiu v0,v0,1 498: 1445fffc bne v0,a1,48c &lt;func+0x48c&gt; 49c: a0640000 sb a0,0(v1) 4a0: 00000040 ssnop 4a4: 00000040 ssnop 4a8: 00001025 move v0,zero 4ac: 8fbe00fc lw s8,252(sp) 4b0: 8fb700f8 lw s7,248(sp) ... 4cc: 8fb000dc lw s0,220(sp) 4d0: 03e00008 jr ra 4d4: 27bd0100 addiu sp,sp,256 ... for语句汇编12345678910void func()&#123; int i, a; __asm__ __volatile__("ssnop\n\t"); for (i = 0; i &lt; 88; i++) a = i; __asm__ __volatile__("ssnop\n\t");&#125; 1234567891011121314151617181920212223242500000000 &lt;func&gt;: 0: 27bdffe8 addiu sp,sp,-24 4: afbe0014 sw s8,20(sp) 8: 03a0f025 move s8,sp c: 00000040 ssnop 10: afc00008 sw zero,8(s8) //1. i = 0; 14: 10000006 b 30 &lt;func+0x30&gt; //2. 跳转到0x30，判断i,如果小于88进行（4）循环 18: 00000000 nop 1c: 8fc20008 lw v0,8(s8) 20: afc2000c sw v0,12(s8) 24: 8fc20008 lw v0,8(s8) 28: 24420001 addiu v0,v0,1 //3. i++ 2c: afc20008 sw v0,8(s8) 30: 8fc20008 lw v0,8(s8) 34: 28420058 slti v0,v0,88 38: 1440fff8 bnez v0,1c &lt;func+0x1c&gt; //4. 如果i小于88,跳转到0x1c进行循环 3c: 00000000 nop 40: 00000040 ssnop 44: 00000000 nop 48: 03c0e825 move sp,s8 4c: 8fbe0014 lw s8,20(sp) 50: 27bd0018 addiu sp,sp,24 54: 03e00008 jr ra 58: 00000000 nop 5c: 00000000 nop]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cgroup框架的实现]]></title>
    <url>%2Fpost%2F3438.html</url>
    <content type="text"><![CDATA[CGoup核心主要创建一系列sysfs文件，用户空间可以通过这些节点控制CGroup各子系统行为，以及各子系统模块根据参数。在执行过程中或调度进程到不同CPU上，或控制CPU占用时间，或控制IO带宽等等。另外，在每个系统的proc文件系统中都有一个cgroup，显示该进程对应的CGroup各子系统信息。 内核配置123456789101112Symbol: CGROUPS [=y]Type : booleanPrompt: Control Group support Location: -&gt; General setupSymbol: CGROUP_SCHED [=y]Type : booleanPrompt: Group CPU scheduler Location: -&gt; General setup -&gt; Control Group support (CGROUPS [=y]) 通过CONFIG_CGROUPS配置cgroup框架的实现,CONFIG_CGROUP_SCHED控制CPU子系统。 基本应用123# mount -t cgroup -o cpu cgroup /mnt/# mkdir tst_cgroup# rmdir tst_cgroup 在文件系统中cgroup的挂载目录,也就是cgroup虚拟文件系统的根目录用数据结构struct cgroupfs_root表示.而cgroup用struct cgroup表示. 数据结构主要用于对进程不同资源的管理和配置，以及进程和cgroup之间的关系。 task_struct12345678910struct task_struct &#123; ...#ifdef CONFIG_CGROUPS /* Control Group info protected by css_set_lock */ struct css_set __rcu *cgroups; /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */ struct list_head cg_list;#endif ...&#125;; struct task_struct中并没有一个直接的成员指向cgroup,而是指向了struct css_set的结构, css_set存储路与进程相关的cgroup信息。 cg_list: 是一个链表结构，用于将连到同一个css_set的进程组织成一个链表。 css_set123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * A css_set is a structure holding pointers to a set of * cgroup_subsys_state objects. This saves space in the task struct * object and speeds up fork()/exit(), since a single inc/dec and a * list_add()/del() can bump the reference count on the entire cgroup * set for a task. */struct css_set &#123; /* Reference count */ atomic_t refcount; //引用计数，因为一个css_set可以被多个进程共用，这些进程的cgroup信息相同 /* * List running through all cgroup groups in the same hash * slot. Protected by css_set_lock */ struct hlist_node hlist; /* * List running through all tasks using this cgroup * group. Protected by css_set_lock */ struct list_head tasks; /* * List of cg_cgroup_link objects on link chains from * cgroups referenced from this css_set. Protected by * css_set_lock */ //由cg_cgroup_link组成的链表，链表上每一项cg_cgroup_link都指向和css_set关联的cgroup. struct list_head cg_links; /* * Set of subsystem states, one for each subsystem. This array * is immutable after creation apart from the init_css_set * during subsystem registration (at boot time) and modular subsystem * loading/unloading. */ /* *css_set关联的css.每一个subsystem对应数组中相应id的项。 *subsys应当包括所有子系统的css.如果此css_set没有制定某个subsystem的css或者subsystem没有mount，则默认初始化为根css. */ struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT]; //是进程与一个特定子系统相关的信息 /* For RCU-protected deletion */ struct rcu_head rcu_head;&#125;; file: include/linux/cgroup.h 主要用来描述一个个子系统，通过cgroup_subsys_state定义不同子系统的相关控制信息，hlist将同一个子系统下的所有css_set组织成一个hash表，方便内核查找特定的css_set.tasks指向所有连到此css_set的进程连成的链表。 那从struct css_set怎么转换到cgroup呢? 再来看一个辅助的数据结构struct cg_cgroup_link cgroup_subsys_state123456789101112131415161718192021222324/* Per-subsystem/per-cgroup state maintained by the system. */struct cgroup_subsys_state &#123; /* * The cgroup that this subsystem is attached to. Useful * for subsystems that want to know about the cgroup * hierarchy structure */ struct cgroup *cgroup; /* * State maintained by the cgroup system to allow subsystems * to be "busy". Should be accessed via css_get(), * css_tryget() and css_put(). */ atomic_t refcnt; unsigned long flags; /* ID for this css, if possible */ struct css_id __rcu *id; /* Used to put @cgroup-&gt;dentry on the last css_put() */ struct work_struct dput_work;&#125;; file: include/linux/cgroup.h cgroup指针指向了一个cgroup结构，也就是进程属于的cgroup. 进程受到子系统的控制，实际上是通过加入到特定的cgroup实现的，因为cgroup在特定的层级上，而子系统又是附加到曾经上的 。通过以上三个结构，进程就可以和cgroup关联起来了 ： task_struct-&gt;css_set-&gt;cgroup_subsys_state-&gt;cgroup。 cgroup123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475struct cgroup &#123; unsigned long flags; /* "unsigned long" so bitops work */ /* * count users of this cgroup. &gt;0 means busy, but doesn't * necessarily indicate the number of tasks in the cgroup */ atomic_t count; int id; /* ida allocated in-hierarchy ID */ /* * We link our 'sibling' struct into our parent's 'children'. * Our children link their 'sibling' into our 'children'. */ struct list_head sibling; /* my parent's children */ struct list_head children; /* my children */ struct list_head files; /* my files */ struct cgroup *parent; /* my parent */ struct dentry *dentry; /* cgroup fs entry, RCU protected */ /* * This is a copy of dentry-&gt;d_name, and it's needed because * we can't use dentry-&gt;d_name in cgroup_path(). * * You must acquire rcu_read_lock() to access cgrp-&gt;name, and * the only place that can change it is rename(), which is * protected by parent dir's i_mutex. * * Normally you should use cgroup_name() wrapper rather than * access it directly. */ struct cgroup_name __rcu *name; /* Private pointers for each registered subsystem */ //此cgroup关联subsystem的css结构，每个subsystem的css在数组中对应subsys[subsystem-&gt;subsys_id]. struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT]; struct cgroupfs_root *root; /* * List of cg_cgroup_links pointing at css_sets with * tasks in this cgroup. Protected by css_set_lock */ struct list_head css_sets; //通过cs_cgroup_link指向此cgroup关联的css_set struct list_head allcg_node; /* cgroupfs_root-&gt;allcg_list */ struct list_head cft_q_node; /* used during cftype add/rm */ /* * Linked list running through all cgroups that can * potentially be reaped by the release agent. Protected by * release_list_lock */ struct list_head release_list; /* * list of pidlists, up to two for each namespace (one for procs, one * for tasks); created on demand. */ struct list_head pidlists; struct mutex pidlist_mutex; /* For RCU-protected deletion */ struct rcu_head rcu_head; struct work_struct free_work; /* List of events which userspace want to receive */ struct list_head event_list; spinlock_t event_list_lock; /* directory xattrs */ struct simple_xattrs xattrs;&#125;; sibling,children和parent三个list_head负责将同一层级的cgroup连接成一颗cgroup树。 subsys是一个指针数组，存储一组指向cgroup_subsys_state的指针。这组指针指向了此cgroup跟各个子系统相关的信息 root指向了一个cgroupfs_root的结构，就是cgroup所在的层级对应的结构体 cgroup和css_set是多对多的关系，既：一个css_set可以对应多个cgroup,同时一个cgroup也可以被多个css_set所包含。这种多对多的映射关系，是通过cg_cgroup_link这个中间结构来关联的。 cg_cgroup_link123456789101112131415/* Link structure for associating css_set objects with cgroups */struct cg_cgroup_link &#123; /* * List running through cg_cgroup_links associated with a * cgroup, anchored on cgroup-&gt;css_sets */ struct list_head cgrp_link_list; struct cgroup *cgrp; /* * List running through cg_cgroup_links pointing at a * single css_set object, anchored on css_set-&gt;cg_links */ struct list_head cg_link_list; struct css_set *cg;&#125;; 一个cg_cgroup_link需要包含两类信息，即关联的cgroup和css_set信息，一个cg_cgroup_link可以让一个cgroup和一个css_set相关联。但是正如我们前面所说，css_set和cgroup是多对多的对应关系，所以，一个css_set需要保存多个cg_cgroup_link，一个cgroup也需要保存多个cg_cgroup_link信息。具体来说，css_set中的cg_links维护了一个链表，链表中的元素为cg_cgroup_link中的cg_link_list.cgroup中的css_set也维护了一个cg_cgroup_link链表，链表中元素为cgrp_link_list. cgrp_link_list连入到cgroup-&gt;css_set指向的链表，cgrp则指向此cg_cgroup_link相关的cgroup。 cg_link_list则连入到css_set-&gt;cg_links指向的链表,cg则指向此cg_cgroup_link相关的css_set。 cgroupfs_root1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * A cgroupfs_root represents the root of a cgroup hierarchy, and may be * associated with a superblock to form an active hierarchy. This is * internal to cgroup core. Don't access directly from controllers. */struct cgroupfs_root &#123; struct super_block *sb; //cgroup文件系统的超级块 /* * The bitmask of subsystems intended to be attached to this * hierarchy */ unsigned long subsys_mask; //hierarchy相关联的subsys 位图 /* Unique id for this hierarchy. */ int hierarchy_id; /* The bitmask of subsystems currently attached to this hierarchy */ unsigned long actual_subsys_mask; /* A list running through the attached subsystems */ struct list_head subsys_list; //hierarchy中的subsys链表 /* The root cgroup for this hierarchy */ struct cgroup top_cgroup; /* Tracks how many cgroups are currently defined in hierarchy.*/ int number_of_cgroups; /* A list running through the active hierarchies */ struct list_head root_list; /* All cgroups on this root, cgroup_mutex protected */ struct list_head allcg_list; /* Hierarchy-specific flags */ unsigned long flags; /* IDs for cgroups in this hierarchy */ struct ida cgroup_ida; /* The path to use for release notifications. */ char release_agent_path[PATH_MAX]; /* The name for this hierarchy - may be empty */ char name[MAX_CGROUP_ROOT_NAMELEN];&#125;; top_cgroup指向了所在层级的根cgroup，也就是创建层级时自动创建的那个cgroup。 cgroup_subsys1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * Control Group subsystem type. * See Documentation/cgroups/cgroups.txt for details */struct cgroup_subsys &#123; struct cgroup_subsys_state *(*css_alloc)(struct cgroup *cgrp); int (*css_online)(struct cgroup *cgrp); void (*css_offline)(struct cgroup *cgrp); void (*css_free)(struct cgroup *cgrp); int (*allow_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset); int (*can_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset); void (*cancel_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset); void (*attach)(struct cgroup *cgrp, struct cgroup_taskset *tset); void (*fork)(struct task_struct *task); void (*exit)(struct cgroup *cgrp, struct cgroup *old_cgrp, struct task_struct *task); void (*bind)(struct cgroup *root); int subsys_id; int disabled; int early_init; /* * True if this subsys uses ID. ID is not available before cgroup_init() * (not available in early_init time.) */ bool use_id; /* * If %false, this subsystem is properly hierarchical - * configuration, resource accounting and restriction on a parent * cgroup cover those of its children. If %true, hierarchy support * is broken in some ways - some subsystems ignore hierarchy * completely while others are only implemented half-way. * * It's now disallowed to create nested cgroups if the subsystem is * broken and cgroup core will emit a warning message on such * cases. Eventually, all subsystems will be made properly * hierarchical and this will go away. */ bool broken_hierarchy; bool warned_broken_hierarchy;#define MAX_CGROUP_TYPE_NAMELEN 32 const char *name; /* * Link to parent, and list entry in parent's children. * Protected by cgroup_lock() */ struct cgroupfs_root *root; struct list_head sibling; /* used when use_id == true */ struct idr idr; spinlock_t id_lock; /* list of cftype_sets */ struct list_head cftsets; /* base cftypes, automatically [de]registered with subsys itself */ struct cftype *base_cftypes; struct cftype_set base_cftset; /* should be defined only by modular subsystems */ struct module *module; &#125;; Cgroup_subsys定义了一组操作，让各个子系统根据各自的需要去实现。这个相当于C++中抽象基类，然后各个特定的子系统对应cgroup_subsys则是实现了相应操作的子类。类似的思想还被用在了cgroup_subsys_state中，cgroup_subsys_state并未定义控制信息，而只是定义了各个子系统都需要的共同信息，比如该cgroup_subsys_state从属的cgroup。然后各个子系统再根据各自的需要去定义自己的进程控制信息结构体，最后在各自的结构体中将cgroup_subsys_state包含进去，这样通过Linux内核的container_of等宏就可以通过cgroup_subsys_state来获取相应的结构体。 联系 数据结构 划分 cgroupfs_root 层级（hierarchy） css_set 子系统（subsystem） cgroup 进程控制组 cgroup初始化12345678start_kernel \-&gt;cgroup_init_early(); \-&gt;init_cgroup_root \-&gt;cgroup_init_subsys \-&gt;cgroup_init(); \-&gt;cgroup_init_subsys \-&gt;kobject_create_and_add \-&gt;register_filesystem cgroup_init_early第一阶段：主要进行数据结构的初始化和链表之间关系的绑定 123456789101112131415161718192021222324252627282930int __init cgroup_init_early(void)&#123; atomic_set(&amp;init_css_set.refcount, 1); INIT_LIST_HEAD(&amp;init_css_set.cg_links); //初始化全局结构体struct css_set init INIT_LIST_HEAD(&amp;init_css_set.tasks); INIT_HLIST_NODE(&amp;init_css_set.hlist); css_set_count = 1; //系统中struct css_set计数 init_cgroup_root(&amp;rootnode); //初始化全局结构体struct cgroupfs_root root_count = 1; //系统中的层级计数 init_task.cgroups = &amp;init_css_set; //使系统的初始化进程cgroup指向init_css_set init_css_set_link.cg = &amp;init_css_set; /* dummytop is a shorthand for the dummy hierarchy's top cgroup */ init_css_set_link.cgrp = dummytop; list_add(&amp;init_css_set_link.cgrp_link_list, &amp;rootnode.top_cgroup.css_sets); list_add(&amp;init_css_set_link.cg_link_list, &amp;init_css_set.cg_links); //对一些需要在系统启动时初始化的subsys进行初始化 for (i = 0; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123; struct cgroup_subsys *ss = subsys[i]; ... if (ss-&gt;early_init) cgroup_init_subsys(ss); &#125; return 0;&#125; cgroup_init第二阶段： 主要生成cgroup虚拟文件系统 12345678910111213141516171819202122232425262728293031323334353637/** * cgroup_init - cgroup initialization * * Register cgroup filesystem and /proc file, and initialize * any subsystems that didn't request early init. */int __init cgroup_init(void)&#123; ... err = bdi_init(&amp;cgroup_backing_dev_info); for (i = 0; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123; struct cgroup_subsys *ss = subsys[i]; /* at bootup time, we don't worry about modular subsystems */ if (!ss || ss-&gt;module) continue; if (!ss-&gt;early_init) cgroup_init_subsys(ss); if (ss-&gt;use_id) cgroup_init_idr(ss, init_css_set.subsys[ss-&gt;subsys_id]); &#125; /* Add init_css_set to the hash table */ key = css_set_hash(init_css_set.subsys); hash_add(css_set_table, &amp;init_css_set.hlist, key); BUG_ON(!init_root_id(&amp;rootnode)); ... cgroup_kobj = kobject_create_and_add("cgroup", fs_kobj); err = register_filesystem(&amp;cgroup_fs_type); proc_create("cgroups", 0, NULL, &amp;proc_cgroupstats_operations); ... return err;&#125; 1.bdi_init用于初始化后备存储器的一些字段，这些字段包括回写链表、回写锁等，关系到读写策略，和挂载关系并不大 subsys12345678#define SUBSYS(_x) [_x ## _subsys_id] = &amp;_x ## _subsys,#define IS_SUBSYS_ENABLED(option) IS_BUILTIN(option)static struct cgroup_subsys *subsys[CGROUP_SUBSYS_COUNT] = &#123;#include &lt;linux/cgroup_subsys.h&gt;#if IS_SUBSYS_ENABLED(CONFIG_CGROUP_DEBUG)SUBSYS(debug)#endif&#125;; file: kernel/cgroup.c cgroup文件系统的挂载 mount -t cgroup -o cpu cgroup /mnt/ 注册：12345static struct file_system_type cgroup_fs_type = &#123; .name = "cgroup", .mount = cgroup_mount, .kill_sb = cgroup_kill_sb,&#125;; 调用关系：123456SyS_mount \-&gt;do_mount \-&gt;vfs_kern_mount \-&gt;mount_fs \-&gt;cgroup_mount \-&gt;cgroup_populate_dir //生成基础的文件属性 cgoup基础的文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*for hysterical raisins, we can't put this on the older files*/#define CGROUP_FILE_GENERIC_PREFIX "cgroup."static struct cftype files[] = &#123; &#123; .name = "tasks", .open = cgroup_tasks_open, .write_u64 = cgroup_tasks_write, .release = cgroup_pidlist_release, .mode = S_IRUGO | S_IWUSR, &#125;, &#123; .name = CGROUP_FILE_GENERIC_PREFIX "procs", .open = cgroup_procs_open, .write_u64 = cgroup_procs_write, .release = cgroup_pidlist_release, .mode = S_IRUGO | S_IWUSR, &#125;, &#123; .name = "notify_on_release", .read_u64 = cgroup_read_notify_on_release, .write_u64 = cgroup_write_notify_on_release, &#125;, &#123; .name = CGROUP_FILE_GENERIC_PREFIX "event_control", .write_string = cgroup_write_event_control, .mode = S_IWUGO, &#125;, &#123; .name = "cgroup.clone_children", .flags = CFTYPE_INSANE, .read_u64 = cgroup_clone_children_read, .write_u64 = cgroup_clone_children_write, &#125;, &#123; .name = "cgroup.sane_behavior", .flags = CFTYPE_ONLY_ON_ROOT, .read_seq_string = cgroup_sane_behavior_show, &#125;, &#123; .name = "release_agent", .flags = CFTYPE_ONLY_ON_ROOT, .read_seq_string = cgroup_release_agent_show, .write_string = cgroup_release_agent_write, .max_write_len = PATH_MAX, &#125;, &#123; &#125; /* terminate */&#125;; 创建子cgroup123SyS_mkdirat \-&gt;cgroup_mkdir \-&gt;cgroup_create task echo $$ &gt; task 将当前进程迁移到一个cgroup中： Open:1234567do_sys_open |-&gt;do_filp_open |-&gt; path_openat.isra.13 |-&gt;do_last.isra.12 |-&gt;finish_open |-&gt;do_dentry_open.isra.2 |-&gt;cgroup_pidlist_open Write:12345SyS_write |-&gt;vfs_write |-&gt;cgroup_file_write |-&gt;cgroup_tasks_write |-&gt;attach_task_by_pid DEBUG子系统实现1234567struct cgroup_subsys debug_subsys = &#123; .name = "debug", .css_alloc = debug_css_alloc, .css_free = debug_css_free, .subsys_id = debug_subsys_id, .base_cftypes = debug_files,&#125;; SS 参考 Linux Cgroups 详解 Cgroup框架分析 Linux cgroup机制分析之框架分析 Android/Linux下CGroup框架分析及其使用]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制【spin lock】]]></title>
    <url>%2Fpost%2F62201.html</url>
    <content type="text"><![CDATA[spinlock的使用场景，为什么使用？ 在spinlock控制临界区中，为什么不能睡眠？如果睡眠会产生什么结果？ spinlock的实现和数据结构，在x86、ARM64、MIPS中的实现方式，不同吗？存在什么差异？ 在发生抢锁时，spinlock和信号量处理的区别？ 内核版本：linux 4.4.93 spin lock特点 spin lock是一种死等的锁机制。当前的执行thread会不断的重新尝试直到获取锁进入临界区。 当发生访问资源冲突的时候，可以有两个选择：一个是死等，一个是挂起当前进程，调度其他进程执行。 只允许一个thread进入。semaphore可以允许多个thread进入，spin lock不行，一次只能有一个thread获取锁并进入临界区，其他的thread都是在门口不断的尝试。 执行时间短。 由于spin lock死等这种特性，因此它使用在那些代码不是非常复杂的临界区（当然也不能太简单，否则使用原子操作或者其他适用简单场景的同步机制就OK了），如果临界区执行时间太长，那么不断在临界区门口“死等”的那些thread是多么的浪费CPU啊（当然，现代CPU的设计都会考虑同步原语的实现，例如ARM提供了WFE和SEV这样的类似指令，避免CPU进入busy loop的悲惨境地） 可以在中断上下文执行。由于不睡眠，因此spin lock可以在中断上下文中适用。 场景spin lock，其保护的资源可能来自多个CPU CORE上的进程上下文和中断上下文的中的访问 进程上下文包括：用户进程通过系统调用访问，内核线程直接访问，来自workqueue中work function的访问（本质上也是内核线程）。 中断上下文包括：HW interrupt context（中断handler）、软中断上下文（softirq，当然由于各种原因，该softirq被推迟到softirqd的内核线程中执行的时候就不属于这个场景了，属于进程上下文那个分类了）、timer的callback函数（本质上也是softirq）、tasklet（本质上也是softirq）。 先看最简单的单CPU上的进程上下文的访问。如果一个全局的资源被多个进程上下文访问，这时候，内核如何交错执行呢？对于那些没有打开preemptive选项的内核，所有的系统调用都是串行化执行的，因此不存在资源争抢的问题。 如果内核线程也访问这个全局资源呢？本质上内核线程也是进程，类似普通进程，只不过普通进程时而在用户态运行、时而通过系统调用陷入内核执行，而内核线程永远都是在内核态运行，但是，结果是一样的，对于non-preemptive的linux kernel，只要在内核态，就不会发生进程调度因此，这种场景下，共享数据根本不需要保护（没有并发，谈何保护呢）。 单核CPU中， 如果系统默认关闭抢占时，spin lock不起任何作用，因为不存在真正并发的条件，不需要进行同步。如果打开内核抢占，其同步机制主要时通过关闭抢占实现 进程上下文当打开premptive选项后，事情变得复杂了，我们考虑下面的场景： 进程A在某个系统调用过程中访问了共享资源R 进程B在某个系统调用过程中也访问了共享资源R 1.会不会造成冲突呢？ 假设在A访问共享资源R的过程中发生了中断，中断唤醒了沉睡中的，优先级更高的B，在中断返回现场的时候，发生进程切换，B启动执行，并通过系统调用访问了R，如果没有锁保护，则会出现两个thread进入临界区，导致程序执行不正确。 2.使用spin lock： A在进入临界区之前获取了spin lock，同样的，在A访问共享资源R的过程中发生了中断，中断唤醒了沉睡中的，优先级更高的B，B在访问临界区之前仍然会试图获取spin lock，这时候由于A进程持有spin lock而导致B进程进入了永久的spin……怎么破？linux的kernel很简单，在A进程获取spin lock的时候，禁止本CPU上的抢占（上面的永久spin的场合仅仅在本CPU的进程抢占本CPU的当前进程这样的场景中发生）。 如果是多核CPU，A和B运行在不同的CPU上，那么情况会简单一些：A进程虽然持有spin lock而导致B进程进入spin状态，不过由于运行在不同的CPU上，A进程会持续执行并会很快释放spin lock，解除B进程的spin状态。 中断上下文 运行在CPU0上的进程A在某个系统调用过程中访问了共享资源R 运行在CPU1上的进程B在某个系统调用过程中也访问了共享资源R 外设P的中断handler中也会访问共享资源R 在这样的场景下，使用spin lock可以保护访问共享资源R的临界区吗？我们假设CPU0上的进程A持有spin lock进入临界区，这时候，外设P发生了中断事件，并且调度到了CPU1上执行，看起来没有什么问题，执行在CPU1上的handler会稍微等待一会CPU0上的进程A，等它立刻临界区就会释放spin lock的. 但是，如果外设P的中断事件被调度到了CPU0上执行会怎么样？CPU0上的进程A在持有spin lock的状态下被中断上下文抢占，而抢占它的CPU0上的handler在进入临界区之前仍然会试图获取spin lock，悲剧发生了，CPU0上的P外设的中断handler永远的进入spin状态，这时候，CPU1上的进程B也不可避免在试图持有spin lock的时候失败而导致进入spin状态。为了解决这样的问题，linux kernel采用了这样的办法：如果涉及到中断上下文的访问，spin lock需要和禁止本CPU上的中断联合使用。 linux kernel中提供了丰富的bottom half的机制，虽然同属中断上下文，不过还是稍有不同。我们可以把上面的场景简单修改一下：外设P不是中断handler中访问共享资源R，而是在的bottom half中访问。使用spin lock+禁止本地中断当然是可以达到保护共享资源的效果，但是使用牛刀来杀鸡似乎有点小题大做，这时候disable bottom half就OK了。 最后，我们讨论一下中断上下文之间的竞争。同一种中断handler之间在uni core和multi core上都不会并行执行，这是linux kernel的特性。如果不同中断handler需要使用spin lock保护共享资源，对于新的内核（不区分fast handler和slow handler），所有handler都是关闭中断的，因此使用spin lock不需要关闭中断的配合。bottom half又分成softirq和tasklet，同一种softirq会在不同的CPU上并发执行，因此如果某个驱动中的sofirq的handler中会访问某个全局变量，对该全局变量是需要使用spin lock保护的，不用配合disable CPU中断或者bottom half。tasklet更简单，因为同一种tasklet不会多个CPU上并发，具体我就不分析了，大家自行思考吧。 通用代码结构数据结构123456789typedef struct spinlock &#123; union &#123; struct raw_spinlock rlock; &#125;;&#125; spinlock_t;typedef struct raw_spinlock &#123; arch_spinlock_t raw_lock;&#125; raw_spinlock_t; file: include/linux/spinlock_types.h 通过arch_spinlock_t结构体定义不同arch下spin lock的实现结构。 接口API 接口类型 spinlock定义 raw_spinlock的定义 定义spin lock并初始化 DEFINE_SPINLOCK DEFINE_RAW_SPINLOCK 动态初始化spin lock spin_lock_init raw_spin_lock_init 获取指定的spin lock spin_lock raw_spin_lock 获取指定的spin lock同时disable本CPU中断 spin_lock_irq raw_spin_lock_irq 保存本CPU当前的irq状态, disable本CPU中断并获取指定的spin lock spin_lock_irqsave raw_spin_lock_irqsave 获取指定的spin lock同时disable本CPU的bottom half spin_lock_bh raw_spin_lock_bh 释放指定的spin lock spin_unlock raw_spin_unlock 释放指定的spin lock同时enable本CPU中断 spin_unlock_irq raw_spin_unock_irq 释放指定的spin lock同时恢复本CPU的中断状态 spin_unlock_irqstore raw_spin_unlock_irqstore 获取指定的spin lock同时enable本CPU的bottom half spin_unlock_bh raw_spin_unlock_bh 尝试去获取spin lock，如果失败，不会spin，而是返回非零值 spin_trylock raw_spin_trylock 判断spin lock是否是locked, 如果其他的thread已经获取了该lock, 那么返回非零值，否则返回0 spin_is_locked raw_spin_is_locked 调用流程spin lock:1234567891011spin_lock() \-&gt;raw_spin_lock() \-&gt;__raw_spin_lock &#123; preempt_disable(); //关闭内核抢占 spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_); //获取锁 LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);//上锁 &#125; ----------------------------- arch -&gt; arch_spin_lock() -&gt; arch_spin_trylock() MIPS架构的实现arch_spinlock_t12345678910111213141516typedef union &#123; /* * bits 0..15 : serving_now * bits 16..31 : ticket */ u32 lock; struct &#123;#ifdef __BIG_ENDIAN u16 ticket; u16 serving_now;#else u16 serving_now; u16 ticket;#endif &#125; h;&#125; arch_spinlock_t; file: arch/mips/include/asm/spinlock_types.h 实现arch_spin_lock1234567891011121314151617181920212223242526272829303132333435363738394041static inline void arch_spin_lock(arch_spinlock_t *lock)&#123; int my_ticket; int tmp; int inc = 0x10000; __asm__ __volatile__ ( " .set push # arch_spin_lock \n" " .set noreorder \n" " \n" "1: ll %[ticket], %[ticket_ptr] \n" " addu %[my_ticket], %[ticket], %[inc] \n" " sc %[my_ticket], %[ticket_ptr] \n" " beqz %[my_ticket], 1b \n" " srl %[my_ticket], %[ticket], 16 \n" " andi %[ticket], %[ticket], 0xffff \n" " bne %[ticket], %[my_ticket], 4f \n" " subu %[ticket], %[my_ticket], %[ticket] \n" "2: .insn \n" " .subsection 2 \n" "4: andi %[ticket], %[ticket], 0xffff \n" " sll %[ticket], 5 \n" " \n" "6: bnez %[ticket], 6b \n" " subu %[ticket], 1 \n" " \n" " lhu %[ticket], %[serving_now_ptr] \n" " beq %[ticket], %[my_ticket], 2b \n" " subu %[ticket], %[my_ticket], %[ticket] \n" " b 4b \n" " subu %[ticket], %[ticket], 1 \n" " .previous \n" " .set pop \n" : [ticket_ptr] "+" GCC_OFF_SMALL_ASM() (lock-&gt;lock), [serving_now_ptr] "+m" (lock-&gt;h.serving_now), [ticket] "=&amp;r" (tmp), [my_ticket] "=&amp;r" (my_ticket) : [inc] "r" (inc)); smp_llsc_mb();&#125; file: arch/mips/include/asm/spinlock.h 算法：Ticket lock: A fair lock arch_spin_trylock123456789101112131415161718192021222324252627282930313233static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)&#123; int tmp, tmp2, tmp3; int inc = 0x10000; __asm__ __volatile__ ( " .set push # arch_spin_trylock \n" " .set noreorder \n" " \n" "1: ll %[ticket], %[ticket_ptr] \n" " srl %[my_ticket], %[ticket], 16 \n" " andi %[now_serving], %[ticket], 0xffff \n" " bne %[my_ticket], %[now_serving], 3f \n" " addu %[ticket], %[ticket], %[inc] \n" " sc %[ticket], %[ticket_ptr] \n" " beqz %[ticket], 1b \n" " li %[ticket], 1 \n" "2: .insn \n" " .subsection 2 \n" "3: b 2b \n" " li %[ticket], 0 \n" " .previous \n" " .set pop \n" : [ticket_ptr] "+" GCC_OFF_SMALL_ASM() (lock-&gt;lock), [ticket] "=&amp;r" (tmp), [my_ticket] "=&amp;r" (tmp2), [now_serving] "=&amp;r" (tmp3) : [inc] "r" (inc)); smp_llsc_mb(); return tmp; &#125; file: arch/mips/include/asm/spinlock.h 反汇编arch_spin_lock1234567891011121314&lt;lg_local_lock&gt;: ... 3c030001 lui v1,0x1 c0440000 ll a0,0(v0) 00832821 addu a1,a0,v1 e0450000 sc a1,0(v0) 10a0fffc beqz a1,80071228 &lt;lg_local_lock+0x40&gt; 00042c02 srl a1,a0,0x10 14850120 bne a0,a1,800716c4 &lt;lg_double_unlock+0x88&gt; 00a42023 subu a0,a1,a0 0000000f sync //smp_llsc_mb(); ... 指令：ll和sc ll: 指令的功能是从内存中读取一个字，以实现接下来的 RMW（Read-Modify-Write） 操作 sc: 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作 Q&amp;A为什么要关闭抢占？如果不禁止内核抢断(或者不禁止中断)，可能会有以下的情况发生（假设进程B比进程A具有更高的优先级）： 进程A获得spinlock lock 进程B运行(抢占进程A) 进程B获取spinlock lock 由于进程B比进程A优先级高，所以进程B在进程A之前运行，而进程B需要进程A释放lock之后才能运行，于是，死锁 为什么不能睡眠？spinlock中的代码不能有睡眠（schedule()之类的放弃CPU的代码），因为此时内核抢占已经关闭，如果让出CPU正好调度到的另一个进程也需要这个锁，整个系统将形成死锁。 spinlock阶段，来中断？ 进程A获取spinlcok锁，访问资源R 中断响应后，在中断处理程序中，也去获取spinlock锁，并访问资源R 如果在进程A没有释放spinlock锁时，如果触发中断后，进程A和中断怎么处理？？ 此时不能使用spin_lock,应该使用spin_lock_irq 参考 Linux内核同步机制之（四）：spin lock Linux 的 Spinlock 在 MIPS 多核处理器中的设计与实现]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I2C驱动]]></title>
    <url>%2Fpost%2F28337.html</url>
    <content type="text"><![CDATA[1234567891011 +---------++----------+ | || CPU | | codec1 || | +-+-----+-+| +---+ | | +------+| |I2C| | | | || | &lt;----------------------------------------------+ codec|| | &lt;----------------------v-----------------------+ || +---+ | || | +------++----------+ I2C: 以1根串行数据线（SDA）和1根串行时钟线（SCL）实 现了双工的同步数据传输。具有接口线少，控制方式简化，器件封装形式小，通信速率较高等优点。在主从通信中，可以有多个I2C总线器件同时接到I2C总线上，通过地址来识别通信对象, 应答来互通数据及命令。 速度模式： 标准模式下可达到100Kbps 快速模式下可达到400Kbps 高速模式下达到4Mbps 协议时序设备定义（DTS）1234567891011121314151617&amp;i2c4 &#123; status = &quot;okay&quot;; clock-frequency = &lt;100000&gt;; timeout = &lt;1000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;i2c4_pd&gt;; ak4458: dac@0x10 &#123; compatible = &quot;asahi-kasei,ak4458&quot;; status = &quot;okay&quot;; reg = &lt;0x10&gt;; reset-gpios = &lt;&amp;gpd 7 GPIO_ACTIVE_HIGH INGENIC_GPIO_NOBIAS&gt;; xxmute-gpios = &lt;&amp;gpc 4 GPIO_ACTIVE_HIGH INGENIC_GPIO_NOBIAS&gt;; &#125;; ...&#125; acpi参考 Linux I2C framework(3)_I2C consumer 示波器分析I2C时序波形图 I2C设备调试及波形分析]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2Fpost%2F42863.html</url>
    <content type="text"><![CDATA[小米 MMC整体框架 emmc协议的初始化流程（sd，sdio），之间的不同区别差异 I2C协议，时序图（示波器的抓取） 驱动框架以及使用，device tree的使用 alsa整体结构图，工作流程 数据传输，环形buffer，实现，xrun，overrun和underrun OOMOOM产生的原因：内存没了 OOM的处理流程，杀死进程，是内核态还是用户态？被杀死的进程依据是什么？ 内存管理 伙伴系统大块内存的申请，算法原理 Buddy system slab小块内存（小于1page）申请Linux slab 分配器剖析 页表linux内核支持几级页表，mips cpu使用几级页表，其中寻址的原理 cache 中断 request_irq() request_thread_irq() 中断为什么要线程化？ 提高实时性。 不能睡眠，为啥？如果睡眠会发生什么？ 同步 信号量实现，与信号的区别 spinlock实现，arm64，x86，mips的关键结构体，实现的原理spinlock中不能睡眠，如果存在sleep会怎么样？中断上下文，进程上下文之前的切换区别？ mutex实现，作用的范围？与spinlock的区别？ 读写锁 用处，实现，应用场景？ 内核抢占 抢占与spinlock之间的关系？ 关闭抢占后，让出CPU的方法？ schedule Android的启动android启动进入桌面 系统的整体启动bootram-&gt;spl-&gt;uboot-&gt;kernel-&gt;fs 文件系统实现 ext4文件系统的掉电保护]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Namespace]]></title>
    <url>%2Fpost%2F31401.html</url>
    <content type="text"><![CDATA[容器，cgroup，namespace之间的关系：12345678910111213141516171819 +-------------------------------------+ | | | 容器 | 用户空间 +-------------------------------------++-------------------------------------------------------+ +--------------+ +-------------------+ | cgroup fs | | syscall（clone） | +------+-------+ +---------+---------+ ^ ^ +------+------+ +---------+---------+ | cgroup | | namespace | 内核空间 +-------------+ +-------------------+ +-------------+ +-------------------+ | | | | | CPU | | PID，IPC， | | 内存资源 | | 网络等资源 | | | | | | | | | +-------------+ +-------------------+ CgroupNamespaceNamespace又称为命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象，并将其封装在一起提供给一个容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就可以做到访问隔离。可以让每一个进程具有独立的PID，IPC和网络空间。 通过执行clone系统调用可以划分命名空间，主要是根据clone的第3个参数flags标志进行设置 系统调用 clone(): 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。 unshare(): 使某进程脱离某个namespace setns(): 把某进程加入到某个namespace 资源划分 名 称 说明 CLONE_NEWIPC 划分IPC（进程间通信）命名空间，信号量，共享内存，消息队列，等进程间通信的资源 CLONE_NEWNET 划分网络命令空间，分配网络接口 CLONE_NEWNS 划分挂载命名空间。与chroot同样分配新的根文件系统 CLONE_NEWPID 划分PID命名空间。分配新的进程ID空间 CLONE_NEWUTS 划分UTS(主机名)命名空间。分配新的UTS空间 clone创建一个子进程，后续的命名空间的划分在此基础上操作。 12345678910111213141516171819202122232425262728293031#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define STACK_SIZE (1024*1024)static char child_stack[STACK_SIZE];char *const child_args[] = &#123; "/bin/bash", NULL&#125;;int child_main(void *args)&#123; printf("in child process \n"); execv(child_args[0], child_args); return 1;&#125;int main()&#123; printf("process start: \n"); int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, NULL); waitpid(child_pid, NULL, 0); printf("end \n"); return 0;&#125; UTS命名空间（CLONE_NEWUTS）UTS命名空间，提供了主机名和域名的隔离。 123456789101112131415161718192021222324252627282930313233#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define STACK_SIZE (1024*1024)static char child_stack[STACK_SIZE];char *const child_args[] = &#123; "/bin/bash", NULL&#125;;int child_main(void *args)&#123; printf("in child process \n"); sethostname("NewNameSpace", 20); //设置新的主机名 execv(child_args[0], child_args); return 1;&#125;int main()&#123; printf("process start: \n"); int child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS|SIGCHLD, NULL); waitpid(child_pid, NULL, 0); printf("end \n"); return 0;&#125; 结果： 123456789&gt;user@ingenic-xxx:~/namespace$ sudo ./a.out&gt;process start:&gt;in child process&gt;root@NewNameSpace:~/namespace# echo $HOSTNAME&gt;NewNameSpace&gt;root@NewNameSpace:~/namespace# exit&gt;exit&gt;end&gt; IPC命名空间（CLONE_NEWIPC）IPC Namespace 是用来隔离 System V IPC 和POSIX message queues.每一个IPC Namespace都有他们自己的System V IPC 和POSIX message queue。 验证：消息队列 ipcs查看队列 1$ ipcs -q ipcmk创建队列 1$ ipcmk -Q ipcrm删除队列 1$ ipcrm -q 0 PID命名空间（CLONE_NEWPID）PID namespace是用来隔离进程 id。同样的一个进程在不同的 PID Namespace 里面可以拥有不同的 PID。空间内的PID 是独立分配的，意思就是命名空间内的虚拟 PID 可能会与命名空间外的 PID 相冲突，于是命名空间内的 PID 映射到命名空间外时会使用另外一个 PID。比如说，命名空间内第一个 PID 为1，而在命名空间外就是该 PID 已被 init 进程所使用。 验证： echo $$ 在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。 mount命名空间（CLONE_NEWNS）进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能进程运行时可以将挂载点与系统分离，使用这个功能时，可以达到 chroot 的功能 在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。 小应用参考 网络虚拟化基础一：linux名称空间Namespaces]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>namespace</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIPS架构下的中断处理]]></title>
    <url>%2Fpost%2F61535.html</url>
    <content type="text"><![CDATA[内核版本: 3.10.14 linux内核出入文件:arch/mips/kernel/traps.c 函数调用关系123set_except_vector(0, using_rollback_handler() ? rollback_handle_int: handle_int) -&gt; handle_int -&gt; plat_irq_dispatch trap_init在Linux内核启动时注册，main.c 1234567void __init trap_init(void)&#123; ... set_except_vector(0, using_rollback_handler() ? rollback_handle_int : handle_int); ...&#125; file: arch/mips/kernel/traps.c handle_int1234567891011NESTED(handle_int, PT_SIZE, sp) SAVE_ALL CLI TRACE_IRQS_OFF LONG_L s0, TI_REGS($28) LONG_S sp, TI_REGS($28) PTR_LA ra, ret_from_irq PTR_LA v0, plat_irq_dispatch jr v0END(handle_int) file: arch/mips/kernel/genex.S plat_irq_dispatch12345asmlinkage void plat_irq_dispatch(void)&#123; unsigned long r = (read_c0_status() &amp; read_c0_cause()) &gt;&gt; 8; do_IRQ(MIPS_CPU_IRQ_BASE + __ffs(r &amp; 0xff));&#125; file: arch/mips/xburst2/soc-x2000/common/irq.c ret_from_irq代码跳转(反汇编)1234567891011121314151617181980014780 &lt;handle_int&gt;:80014780: 401a6000 mfc0 k0,c0_status80014784: 335a0001 andi k0,k0,0x180014788: 17400002 bnez k0,80014794 &lt;handle_int+0x14&gt;8001478c: 00000000 nop . .80014898: 27ff43e0 addiu ra,ra,173768001489c: 3c028001 lui v0,0x8001800148a0: 24421404 addiu v0,v0,5124800148a4: 00400008 jr v0 #jr -&gt; 0x80011404800148a8: 00000000 nop80011404 &lt;plat_irq_dispatch&gt;:80011404: 40076000 mfc0 a3,c0_status80011408: 40066800 mfc0 a2,c0_cause8001140c: 00e61024 and v0,a3,a280011410: 00021202 srl v0,v0,0x8 jr v0handle_int中jr跳转的函数地址v0的计算: 12lui v0 0x8001addiu v0,v0,5124 #0x80011404 lui &amp; addiu具体的指令码,可参考MIPS手册.这两个指令码的低十六位为立即数的十六进制数. handle_int函数的组合]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile基础语法]]></title>
    <url>%2Fpost%2F21058.html</url>
    <content type="text"><![CDATA[Makefile语法 = := ?= += = 是最基本的赋值 := 是覆盖之前的值 ?= 是如果没有被赋值过就赋予等号后面的值 += 是添加等号后面的值 =make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。 123456x = fooy = $(x) barx = xyzall: echo &quot;==: $y&quot; 结果==: xyz bar :=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。 123456x := fooy := $(x) barx := xyzall: echo &quot;==: $y&quot; 结果==: foo bar]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux]]></title>
    <url>%2Fpost%2F40876.html</url>
    <content type="text"><![CDATA[tmux是一个优秀的终端复用软件，split窗口。可以在一个terminal下打开多个终端。即使非正常掉线，也能保证当前的任务运行，这一点对于远程SSH访问特别有用，网络不好的情况下仍然能保证工作现场不丢失。SSH重新连接以后，就可以直接回到原来的工作环境，不但提高了工作效率，还降低了风险，增加了安全性。 tmux完全使用键盘控制窗口，实现窗口的切换功能 1sudo apt-get install tmux 快捷键配置 my tmux.conf tmux的系统级配置文件为/etc/tmux.conf，用户级配置文件为~/.tmux.conf。配置文件实际上就是tmux的命令集合，也就是说每行配置均可在进入命令行模式后输入生效。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASOC之DPCM]]></title>
    <url>%2Fpost%2F14697.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>DPCM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uboot]]></title>
    <url>%2Fpost%2F47503.html</url>
    <content type="text"><![CDATA[Bootloader 是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。 uboot引导系统启动, UBoot包含两个阶段的启动，一个是SPL启动，一个是正常的启动我们称为第二阶段Uboot。当然，我们也可以选择使用SPL和不使用，主要根据CPU中的SRAM（或者cache，bootram阶段需要初始化完成）的大小，如果不能放下uboot大小，则必须先使用SPL启动，进行DDR的初始化，以获取更大的可以空间。 Version: u-boot-201307 12345+----------------+-----------------------------------+| | || spl | uboot || | |+----------------+-----------------------------------+ 在编译的过程中,这两个阶段通过CONFIG_SPL_BUILD宏将编译分离。拥有不同的配置，所以许多地方的宏是和SPL的不一样。而且链接的文件也不一致。 SPL： 1./arch/mips/cpu/xburst/x1000/u-boot-spl.lds uboot： 1/arch/mips/cpu/u-boot.lds 目的 流程: SPL1234u-boot-spl.ldsENTRY: _start (start.S) \-&gt;board_init_f (soc.c) -&gt;board_init_r (spl.c) u-boot-spl.lds12#define CONFIG_SPL_TEXT_BASE 0xf4001000#define CONFIG_SPL_MAX_SIZE (12 * 1024) 1234567891011121314151617181920212223242526MEMORY &#123; .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\ LENGTH = CONFIG_SPL_MAX_SIZE &#125;OUTPUT_ARCH(mips)ENTRY(_start)SECTIONS&#123; .text : &#123; __start = .; *(.start_section*) *(.text*) &#125; &gt;.sram ... .bss : &#123; . = ALIGN(4); __bss_start = .; *(.sbss.*) *(.bss.*) *(COMMON) . = ALIGN(4); __bss_end = .; &#125; &gt;.sram ...&#125; u-boot-spl.lds 在bootram将SPL搬到静态ram中后，执行SPL的代码将从_start开始。 start.S123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define RESERVED_FOR_SC(x) .space 1536, x .set noreorder .globl _start .section .start_section_start: /* magic value (&quot;MSPL&quot;) */ .word 0x4d53504c .space 508, 0 RESERVED_FOR_SC(0)#ifdef CONFIG_SPL_VERSION .word (0x00000000 | CONFIG_SPL_VERSION) .space (512-20),0#else .space (512-16),0#endif /* Invalidate BTB */ mfc0 v0, CP0_CONFIG, 7 nop ori v0, v0, 2 /* MMU类型：BAT类型*/ mtc0 v0, CP0_CONFIG, 7 nop /* * CU0=UM=EXL=IE=0, BEV=ERL=1, IP2~7=1 */ li t0, 0x0040FC04 mtc0 t0, CP0_STATUS /* CAUSE register */ /* IV=1, use the specical interrupt vector (0x200) */ li t1, 0x00800000 mtc0 t1, CP0_CAUSE .set push .set mips32init_caches: li t0, CONF_CM_CACHABLE_NONCOHERENT mtc0 t0, CP0_CONFIG nop /* enable idx-store-data cache insn */ li t0, 0x20000000 mtc0 t0, CP0_ECC li t1, KSEG0 /* Start address */#define CACHE_ALLOC_END (CONFIG_SYS_DCACHE_SIZE) ori t2, t1, CACHE_ALLOC_END /* End address */ mtc0 zero, CP0_TAGLO, 0 mtc0 zero, CP0_TAGLO, 1cache_clear_a_line: cache INDEX_STORE_TAG_I, 0(t1) cache INDEX_STORE_TAG_D, 0(t1) addiu t1, t1, CONFIG_SYS_CACHELINE_SIZE bne t1, t2, cache_clear_a_line nop .set pop /* Set up stack */#ifdef CONFIG_SPL_STACK li sp, CONFIG_SPL_STACK#endif j board_init_f nop start.S 设置spl的空间布局,加载识别区域，SC填充区域等 选择MMU类型 通过SR，使能异常向量和配置中断屏蔽位 配置一个特殊的中断异常入口（0x200） 初始化cache 跳转board_init_f soc.c数据结构bd_t 保存板子参数 12345678910typedef struct bd_info &#123; unsigned int bi_baudrate; /*serial console baudrate*/ unsigned long bi_arch_number; /*unique id for this board*/ unsigned long bi_boot_params; /*where this board expects params*/ unsigned long bi_memstart; /*start of DRAM memory*/ phys_size_t bi_memsize; /*size of DRAM memory in bytes*/ unsigned long bi_flashstart; /*start of FLASH memory*/ unsigned long bi_flashsize; /*size of FLASH memory*/ unsigned long bi_flashoffset; /*reserved area for startup monitor*/&#125; bd_t; file: arch/mips/include/asm/u-boot.h gd_t 全局的系统初始化参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct global_data &#123; bd_t *bd; unsigned long flags; unsigned int baudrate; unsigned long cpu_clk; /* CPU clock in Hz! */ unsigned long bus_clk; /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */ unsigned long pci_clk; unsigned long mem_clk;#if defined(CONFIG_LCD) || defined(CONFIG_VIDEO) unsigned long fb_base; /* Base address of framebuffer mem */#endif ...#ifdef CONFIG_BOARD_TYPES unsigned long board_type;#endif unsigned long have_console; /* serial_init() was called */#ifdef CONFIG_PRE_CONSOLE_BUFFER unsigned long precon_buf_idx; /* Pre-Console buffer index */#endif#ifdef CONFIG_MODEM_SUPPORT unsigned long do_mdm_init; unsigned long be_quiet;#endif unsigned long env_addr; /* Address of Environment struct */ unsigned long env_valid; /* Checksum of Environment valid? */ unsigned long ram_top; /* Top address of RAM used by U-Boot */ unsigned long relocaddr; /* Start address of U-Boot in RAM */ phys_size_t ram_size; /* RAM size */ unsigned long mon_len; /* monitor len */ unsigned long irq_sp; /* irq stack pointer */ unsigned long start_addr_sp; /* start_addr_stackpointer */ unsigned long reloc_off; struct global_data *new_gd; /* relocated global data */ const void *fdt_blob; /* Our device tree, NULL if none */ void *new_fdt; /* Relocated FDT */ unsigned long fdt_size; /* Space reserved for relocated FDT */ void **jt; /* jump table */ char env_buf[32]; /* buffer for getenv() before reloc. */#ifdef CONFIG_TRACE void *trace_buff; /* The trace buffer */#endif struct arch_global_data arch; /* architecture-specific data */&#125; gd_t; file: include/asm-generic/global_data.h board_init_f1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void board_init_f(ulong dummy)&#123; /*Set global data pointer*/ gd = &amp;gdata; /*Setup global info*/ gd-&gt;arch.gi = &amp;ginfo; gpio_init(); /*Init uart first*/ enable_uart_clk();#ifdef CONFIG_SPL_SERIAL_SUPPORT preloader_console_init();#endif printf("ERROR EPC %x\n", read_c0_errorepc()); debug("Timer init\n"); timer_init();#ifdef CONFIG_SPL_CORE_VOLTAGE debug("Set core voltage:%dmv\n", CONFIG_SPL_CORE_VOLTAGE); spl_regulator_set_voltage(REGULATOR_CORE, CONFIG_SPL_CORE_VOLTAGE);#endif#ifdef CONFIG_SPL_MEM_VOLTAGE debug("Set mem voltage:%dmv\n", CONFIG_SPL_MEM_VOLTAGE); spl_regulator_set_voltage(REGULATOR_MEM, CONFIG_SPL_MEM_VOLTAGE);#endif debug("CLK stop\n"); clk_prepare(); debug("PLL init\n"); pll_init(); debug("CLK init\n"); clk_init();#ifdef CONFIG_HW_WATCHDOG debug("WATCHDOG init\n"); hw_watchdog_init();#endif debug("SDRAM init\n"); sdram_init();#ifdef CONFIG_DDR_TEST ddr_basic_tests();#endif /*Clear the BSS*/ memset(__bss_start, 0, (char *)&amp;__bss_end - __bss_start); debug("board_init_r\n"); board_init_r(NULL, 0);&#125; file: arch/mips/cpu/xburst/x1000/soc.c 初始化GPIO 使能串口时钟，初始化串口 初始化timer 初始化时钟,配置CPU，DDR和外设的时钟大小 初始化看门狗 初始化DDR 清除BSS段 ginfo1234567891011121314#include &lt;asm-generic/global_data.h&gt;#define DECLARE_GLOBAL_DATA_PTR register volatile gd_t *gd asm ("k0")DECLARE_GLOBAL_DATA_PTR;gd_t gdata __attribute__ ((section(".data")));struct global_info ginfo __attribute__ ((section(".data"))) = &#123; .extal = CONFIG_SYS_EXTAL, .cpufreq = CONFIG_SYS_CPU_FREQ, .ddrfreq = CONFIG_SYS_MEM_FREQ, .uart_idx = CONFIG_SYS_UART_INDEX, .baud_rate = CONFIG_BAUDRATE, ...&#125; 系统信息的结构体 (gd 是指 Global Data, bd 是指 Board info Data) 应该存放于在 DRAM 控制器未初始化之前就能使用的空间中，比如TCSM中。 为什么要清除BSS段？12/* Clear the BSS */memset(__bss_start, 0, (char *)&amp;__bss_end - __bss_start); 可执行程序包括BSS段、代码段、数据段。BSS（Block Started by Symbol）通常指用来存放程序中未初始化的全局变量和静态变量的一块内存区域，特点是可读可写，在程序执行之前BSS段会自动清0。所以，未初始化的全局变量在程序执行之前已经成0 bss段起源于unix中。变量分两种，全局变量和局部变量。局部变量是保留在栈中的，根据C语言规定，如果对局部变量不进行初始化，初始值是不确定的，在栈中位置也不固定。全局变量有专门的数据段存储，且初始化值为0，且位置是固定的。综上，数据分为俩种，位置固定（全局，数据段），位置不固定（局部-栈里）。 其实，数据段里的这么多全局变量都初始化为0存在目标文件中是没有必要的，增大了存储空间使用。所以就把数据段里边数据，也即未初始化全局变量存放到了BSS段里边. 并未占有真正的空间。当有目标文件被载入的时候，清除bss段，将全局变量清0, 其实也是在为bss段分配空间. board_init_r123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void board_init_r(gd_t *dummy1, ulong dummy2)&#123; u32 boot_device; char *cmdargs = NULL; debug("&gt;&gt;spl:board_init_r()\n");#ifdef CONFIG_SYS_SPL_MALLOC_START mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START, CONFIG_SYS_SPL_MALLOC_SIZE);#endif#ifndef CONFIG_PPC /* * timer_init() does not exist on PPC systems. The timer is initialized * and enabled (decrementer) in interrupt_init() here. */ timer_init();#endif#ifdef CONFIG_SPL_BOARD_INIT spl_board_init();#endif boot_device = spl_boot_device(); debug("boot device - %d\n", boot_device);#ifdef CONFIG_PALLADIUM spl_board_prepare_for_linux();#endif switch (boot_device) &#123; case BOOT_DEVICE_MMC1: case BOOT_DEVICE_MMC2: case BOOT_DEVICE_MMC2_2: spl_mmc_load_image(); break; ... default: debug("SPL: Un-supported Boot Device\n"); hang(); &#125; switch (spl_image.os) &#123; case IH_OS_U_BOOT: debug("Jumping to U-Boot\n"); break;#ifdef CONFIG_SPL_OS_BOOT case IH_OS_LINUX: debug("Jumping to Linux\n"); spl_board_prepare_for_linux(); cmdargs = cmdargs ? cmdargs : CONFIG_SYS_SPL_ARGS_ADDR; cmdargs = spl_board_process_bootargs(cmdargs); debug("get cmdargs: %s.\n", cmdargs); jump_to_image_linux((void *)cmdargs);#endif default: debug("Unsupported OS image.. Jumping nevertheless..\n"); &#125; jump_to_image_no_args(&amp;spl_image);&#125; file: common/spl/spl.c 从存储介质（sd/emmc）读取uboot，并跳转到uboot执行 在SPL运行完后，已可以直接加载kernel或相应的BIN文件执行 执行C代码所必需的条件或者环境？123la sp, STACK_TOP // spj mainnop 禁止看门狗，防止CPU不断的重启 设置堆栈 SPL执行阶段其栈空间的位置？123456789101112131415 TCSM+-------------+ &lt;-+ 0xb2400000| .data .bss | 4K+----------+--+ &lt;-+ 0xb2401000| stack | | 4K+----------v--+ &lt;-+ 0xb2402000| || || || load spl | 24KB| || || || |+-------------+ &lt;-+ 0xb2408000 CPU上电后，在bootrom中执行时，由于其是固化的代码段（只读）。因此在上电初期将Data段，BSS段以及栈指定到TCSM中（一个静态RAM，CPU上电即可以使用）。bootrom中一些外围设备如sd boot的SD控制器等初始化完成后，在SD卡中将SPL加载到TCSM中，bootrom的PC跳入SPL进行执行，此时依然使用bootrom的栈空间。 uboot12345u-boot.lds__start （start.S） -&gt;board_init_f (arch/mips/lib/board.c) -&gt;relocate_code (start.S) -&gt;board_init_r (arch/mips/lib/board.c) u-boot.lds1234567891011121314151617181920OUTPUT_ARCH(mips)ENTRY(_start)SECTIONS&#123; . = 0x00000000; . = ALIGN(4); .text : &#123; *(.text*) &#125; ... . = ALIGN(4); .data : &#123; *(.data*) &#125; . = .; _gp = ALIGN(16) + 0x7ff0; /*32KB*/ ... u-boot.lds start.S12#define CONFIG_SYS_SDRAM_BASE 0x80000000 /* cached (KSEG0) address */#define CONFIG_SYS_INIT_SP_OFFSET 0x400000 123456789101112131415161718.set noreorder.globl _start.text_start:/* Initialize $gp */bal 1f nop.word _gp1:lw gp, 0(ra)/* Set up temporary stack */li sp, CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_INIT_SP_OFFSETla t9, board_init_fjr t9 nop start.S 重新设置栈指针0x80400000, 跳转board_init_f CONFIG_SYS_SDRAM_BASE ＝ 0x8000 0000 ，是 MIPS 虚拟寻址空间中kseg0段的起始地址（参考《 See MIPS Run 》），它经过 CPU TLB 翻译后是 DRAM 内存的起始物理地址。 为什么不直接跳转，而使用jr这样就可以知道代码的位置,而不是标号值。 board.cuboot内存布局：12345678#define CONFIG_SYS_SDRAM_BASE 0x80000000 /* cached (KSEG0) address */#define CONFIG_SYS_SDRAM_MAX_TOP 0x90000000 /* don't run into IO space */#define CONFIG_SYS_INIT_SP_OFFSET 0x400000#define CONFIG_SYS_LOAD_ADDR 0x88000000#define CONFIG_SYS_MEMTEST_START 0x80000000#define CONFIG_SYS_MEMTEST_END 0x88000000#define CONFIG_SYS_TEXT_BASE 0x80100000#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE 123456789101112131415161718192021+-------------------+ &lt;-+ 0x9000 0000| || || || LOAD_ADDR || || |+-------------------+ &lt;-+ 0x8800 0000| || || || || || |+-------------------+ &lt;-+ 0x8040 0000| || STACK || |+-------------------+ &lt;-+ 0x8010 0000| TEXT BASE |+-------------------+ &lt;-+ 0x8000 0000 board_init_f123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113void board_init_f(ulong bootflag)&#123; gd_t gd_data, *id; bd_t *bd; init_fnc_t **init_fnc_ptr; ulong addr, addr_sp, len; ulong *s; /* Pointer is writable since we allocated a register for it. */ gd = &amp;gd_data; /* compiler optimization barrier needed for GCC &gt;= 3.4 */ __asm__ __volatile__("" : : : "memory"); memset((void *)gd, 0, sizeof(gd_t)); for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123; if ((*init_fnc_ptr)() != 0) hang(); &#125; /* * Now that we have DRAM mapped and working, we can * relocate the code and continue running from DRAM. */ addr = CONFIG_SYS_SDRAM_BASE + gd-&gt;ram_size;#ifdef CONFIG_SYS_SDRAM_MAX_TOP addr = MIN(addr, CONFIG_SYS_SDRAM_MAX_TOP);#endif /* We can reserve some RAM "on top" here. */ /* round down to next 4 kB limit. */ addr &amp;= ~(4096 - 1); //addr &amp;= ~0x0FFF 这种计算是常用的地址对齐，向下 4K 字节对齐 printf("Top of RAM usable for U-Boot at: %08lx\n", addr);#ifdef CONFIG_LCD#ifdef CONFIG_FB_ADDR gd-&gt;fb_base = CONFIG_FB_ADDR;#else /* reserve memory for LCD display (always full pages) */ addr = lcd_setmem(addr); printf("Reserving %ldk for LCDC at: %08lx\n", len &gt;&gt; 10, addr); gd-&gt;fb_base = addr;#endif /* CONFIG_FB_ADDR */#endif /* CONFIG_LCD */ /* Reserve memory for U-Boot code, data &amp; bss * round down to next 16 kB limit */ len = bss_end() - CONFIG_SYS_MONITOR_BASE; addr -= len; addr &amp;= ~(16 * 1024 - 1); // 向下 64K 字节对齐 printf("Reserving %ldk for U-Boot at: %08lx\n", len &gt;&gt; 10, addr); /* Reserve memory for malloc() arena. */ addr_sp = addr - TOTAL_MALLOC_LEN; // 划分 malloc() 使用的空间，即所谓的堆空间 printf("Reserving %dk for malloc() at: %08lx\n", TOTAL_MALLOC_LEN &gt;&gt; 10, addr_sp); /* * (permanently) allocate a Board Info struct * and a permanent copy of the "global" data */ addr_sp -= sizeof(bd_t); bd = (bd_t *)addr_sp; gd-&gt;bd = bd; printf("Reserving %zu Bytes for Board Info at: %08lx\n", sizeof(bd_t), addr_sp); addr_sp -= sizeof(gd_t); id = (gd_t *)addr_sp; printf("Reserving %zu Bytes for Global Data at: %08lx\n", sizeof(gd_t), addr_sp); /* Reserve memory for boot params. */ addr_sp -= CONFIG_SYS_BOOTPARAMS_LEN; bd-&gt;bi_boot_params = addr_sp; printf("Reserving %dk for boot params() at: %08lx\n", CONFIG_SYS_BOOTPARAMS_LEN &gt;&gt; 10, addr_sp); /* * Finally, we set up a new (bigger) stack. * * Leave some safety gap for SP, force alignment on 16 byte boundary * Clear initial stack frame */ addr_sp -= 16; addr_sp &amp;= ~0xF; // 栈空间 16 字节对齐 s = (ulong *)addr_sp; *s-- = 0; *s-- = 0; addr_sp = (ulong)s; printf("Stack Pointer at: %08lx\n", addr_sp); /* * Save local variables to board info struct */ bd-&gt;bi_memstart = CONFIG_SYS_SDRAM_BASE; /* start of DRAM */ bd-&gt;bi_memsize = gd-&gt;ram_size; /* size of DRAM in bytes */ bd-&gt;bi_baudrate = gd-&gt;baudrate; /* Console Baudrate */ // 将在临时栈空间中的 GD 数据拷贝入 DRAM 中，至此， BD 和 GD 都已经存在于 DRAM 中了 memcpy(id, (void *)gd, sizeof(gd_t)); relocate_code(addr_sp, id, addr); /*NOTREACHED - relocate_code() does not return*/&#125; 调用init_sequence 函数队列，对板子进行一些初始化 12345678910111213141516171819202122232425/* * initialization sequence configurable to the user. * * The requirements for any new initalization function is simple: it * receives a pointer to the "global data" structure as it's only * argument, and returns an integer return code, where 0 means * "continue" and != 0 means "fatal error, hang the system". */typedef int (init_fnc_t)(void);init_fnc_t *init_sequence[] = &#123; board_early_init_f, timer_init, env_init, /* initialize environment */#ifdef CONFIG_INCA_IP incaip_set_cpuclk, /* set cpu clock according to env. variable */#endif init_baudrate, /* initialize baudrate settings */ serial_init, /* serial communications setup */ console_init_f, display_banner, /* say that we are here */ checkboard, init_func_ram, NULL,&#125;; 为uboot在DRAM中执行准备条件 relocate_code重定位，U-boot运行后将自己的代码段,数据段,BSS 段等搬到DRAM 中的另一个位置继续运行. 目的： 为kernel腾出内存的低端空间，防止kernel解压覆盖uboot。 对于由静态存储器（spiflash nandflash）启动，这个relocation是必须的，将代码搬到DRAM中运行 1relocate_code(addr_sp, id, addr); id: 之前在 U-boot 的 1M 空间中分配的 GD 结构体的地址addr: U-boot 重新定位到 DRAM 之后的代码起始地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/* * void relocate_code (addr_sp, gd, addr_moni) * * This &quot;function&quot; does not return, instead it continues in RAM * after relocating the monitor code. * * a0 = addr_sp * a1 = gd * a2 = destination address */ .globl relocate_code .ent relocate_coderelocate_code: move sp, a0 # set new stack pointer li t0, CONFIG_SYS_MONITOR_BASE sub t6, a2, t0 # t6 &lt;-- relocation offset la t3, in_ram lw t2, -12(t3) # t2 &lt;-- __image_copy_end move t1, a2 add gp, t6 # adjust gp /* * t0 = source address * t1 = target address * t2 = source end address */1: lw t3, 0(t0) sw t3, 0(t1) addu t0, 4 blt t0, t2, 1b addu t1, 4 /* If caches were enabled, we would have to flush them here. */ /* flush d-cache */ li t0, KSEG0 or t1, t0, CONFIG_SYS_DCACHE_SIZE2: cache INDEX_WRITEBACK_INV_D, 0(t0) bne t0, t1, 2b addi t0, CONFIG_SYS_CACHELINE_SIZE sync /* flush i-cache */ li t0, KSEG0 or t1, t0, CONFIG_SYS_ICACHE_SIZE3: cache INDEX_INVALIDATE_I, 0(t0) bne t0, t1, 3b addi t0, CONFIG_SYS_CACHELINE_SIZE /* Invalidate BTB */ mfc0 t0, CP0_CONFIG, 7 nop ori t0, 2 mtc0 t0, CP0_CONFIG, 7 nop /* Jump to where we&apos;ve relocated ourselves */ addi t0, a2, in_ram - _start jr t0 nop .word __rel_dyn_end .word __rel_dyn_start .word __image_copy_end .word _GLOBAL_OFFSET_TABLE_ .word num_got_entriesin_ram: /* * Now we want to update GOT. * * GOT[0] is reserved. GOT[1] is also reserved for the dynamic object * generated by GNU ld. Skip these reserved entries from relocation. */ lw t3, -4(t0) # t3 &lt;-- num_got_entries lw t4, -8(t0) # t4 &lt;-- _GLOBAL_OFFSET_TABLE_ add t4, t6 # t4 now holds relocated _G_O_T_ addi t4, t4, 8 # skipping first two entries li t2, 21: lw t1, 0(t4) beqz t1, 2f add t1, t6 sw t1, 0(t4)2: addi t2, 1 blt t2, t3, 1b addi t4, 4 /* Update dynamic relocations */ lw t1, -16(t0) # t1 &lt;-- __rel_dyn_start lw t2, -20(t0) # t2 &lt;-- __rel_dyn_end b 2f # skip first reserved entry addi t1, 81: lw t3, -4(t1) # t3 &lt;-- relocation info sub t3, 3 bnez t3, 2f # skip non R_MIPS_REL32 entries nop lw t3, -8(t1) # t3 &lt;-- location to fix up in FLASH lw t4, 0(t3) # t4 &lt;-- original pointer add t4, t6 # t4 &lt;-- adjusted pointer add t3, t6 # t3 &lt;-- location to fix up in RAM sw t4, 0(t3)2: blt t1, t2, 1b addi t1, 8 # each rel.dyn entry is 8 bytes /* * Clear BSS * * GOT is now relocated. Thus __bss_start and __bss_end can be * accessed directly via $gp. */ la t1, __bss_start # t1 &lt;-- __bss_start la t2, __bss_end # t2 &lt;-- __bss_end1: sw zero, 0(t1) blt t1, t2, 1b addi t1, 4 move a0, a1 # a0 &lt;-- gd la t9, board_init_r jr t9 move a1, a2 .end relocate_code 移动gp指针 复制代码到RAM中 刷新一下cache 跳到RAM代码当中去（in_ram）,in_ram的主要工作是：更新GOT;清空BSS段；最后跳到board_init_r。 疑问 如何对函数进行寻址调用 如何对全局变量进行寻址操作（读写） 对于全局指针变量中存储的其他变量或函数地址在relocation之后如何操作 uboot GOT GOTs(global offset tables):是uboot能跳转到不同空间运行的原理. 一个完整可运行的bin文件，link时指定的链接地址，load时的加载地址，运行时的运行地址，这3个地址应该是一致的。但是relocation后运行地址不同于加载地址，特别是链接地址，uboot任何进行函数跳转？？？ compiler在cc时加入-fpic或-fpie选项，会在目标文件中生成GOT（global offset table），将本文件中需要relocate的值存放在GOT中，函数尾部的Label来存储GOT的offset以及其中变量的offset，变量寻址首先根据尾部Label相对寻址找到GOT地址，以及变量地址在GOT中的位置，从而确定变量地址，这样对于目标文件统一修改GOT中的值，就修改了变量地址的offset，完成了relocation。 ld时加入-pie选项，就会将GOT并入到rel.dyn段中，uboot在relocate_code中统一根据rel.dyn段修改需要relocation的数值 划分RAM12345678910111213141516171819+------------------+| || boot params |+------------------+| || Global Data |+------------------+| || Board Info |+------------------+| || mallco(+env) |+------------------+| || uboot code || || || |+------------------+ board_init_r This is the next part if the initialization sequence: we are now running from RAM and have a “normal” C environment, i. e. global data can be written, BSS has been cleared, the stack size in not that critical any more, etc. 此时已在DRAM中运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void board_init_r(gd_t *id, ulong dest_addr)&#123;#ifndef CONFIG_SYS_NO_FLASH ulong size;#endif bd_t *bd; gd = id; gd-&gt;flags |= GD_FLG_RELOC; /* tell others: relocation done */ printf("Now running in RAM - U-Boot at: %08lx\n", dest_addr); gd-&gt;relocaddr = dest_addr; gd-&gt;reloc_off = dest_addr - CONFIG_SYS_MONITOR_BASE; monitor_flash_len = image_copy_end() - dest_addr; board_early_init_r(); serial_initialize(); bd = gd-&gt;bd; /* The Malloc area is immediately below the monitor copy in DRAM */ mem_malloc_init(CONFIG_SYS_MONITOR_BASE + gd-&gt;reloc_off - TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);#ifndef CONFIG_SYS_NO_FLASH /* configure available FLASH banks */ size = flash_init(); display_flash_config(size); bd-&gt;bi_flashstart = CONFIG_SYS_FLASH_BASE; bd-&gt;bi_flashsize = size;#if CONFIG_SYS_MONITOR_BASE == CONFIG_SYS_FLASH_BASE bd-&gt;bi_flashoffset = monitor_flash_len; /* reserved area for U-Boot */#else bd-&gt;bi_flashoffset = 0;#endif#else bd-&gt;bi_flashstart = 0; bd-&gt;bi_flashsize = 0; bd-&gt;bi_flashoffset = 0;#endif ...#ifdef CONFIG_GENERIC_MMC puts("MMC: "); mmc_initialize(bd);#endif /* relocate environment function pointers etc. */ env_relocate();/*leave this here (after malloc(), environment and PCI are working)*/ /* Initialize stdio devices */ stdio_init(); jumptable_init(); /* Initialize the console (after the relocation and devices init) */ console_init_r(); /* Initialize from environment */ load_addr = getenv_ulong("loadaddr", 16, load_addr);#ifdef CONFIG_USB_GADGETextern void board_usb_init(void); board_usb_init();#endif#if defined(CONFIG_MISC_INIT_R) /* miscellaneous platform dependent initialisations */ misc_init_r();#endif#ifdef CONFIG_BITBANGMII bb_miiphy_init();#endif#if defined(CONFIG_CMD_NET) puts("Net: "); eth_initialize(gd-&gt;bd);#endif /* main_loop() can return to retry autoboot, if so just run it again. */ for (;;) main_loop(); /*NOTREACHED - no way out of command loop except booting*/&#125; 初始化串口 初始化系统内存分配函数 如果使用MMC存储介质，初始化MMC设备 初始化环境变量的指针,将 env_ptr 指针及其指向的地址初始化，用来存放环境变量结构体，然后将 flash 中的环境变量拷贝到内存中。 初始化sdio设备 初始化网络设备 进去命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作 main_loop123456789101112131415161718192021222324252627282930313233343536void main_loop(void)&#123; ... bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop"); /*刷新LCD*/#if defined(CONFIG_UPDATE_TFTP) update_tftp(0UL);#endif /* CONFIG_UPDATE_TFTP *//*从环境变量中取得bootdelay 内核等待延时*/#ifdef CONFIG_BOOTDELAY process_boot_delay();#endif /* * Main Loop for Monitor Command Processing */ for (;;) &#123; len = readline (CONFIG_SYS_PROMPT); flag = 0; /* assume no special flags for now */ if (len &gt; 0) strcpy (lastcommand, console_buffer); else if (len == 0) flag |= CMD_FLAG_REPEAT; if (len == -1) puts ("&lt;INTERRUPT&gt;\n"); else rc = run_command(lastcommand, flag); //执行命令 if (rc &lt;= 0) &#123; /* invalid command or not repeatable, forget it */ lastcommand[0] = 0; &#125; &#125;&#125; file:common/main.c do_bootm将内核解压缩，然后调用do_bootm_linux引导内核 do_bootm_linux启动内核 参考 uboot的relocation原理详细分析]]></content>
      <categories>
        <category>uboot</category>
      </categories>
      <tags>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hung Task]]></title>
    <url>%2Fpost%2F16306.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425[10505.024599] INFO: task ps:26540 blocked for more than 120 seconds.[10505.199520] &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.[10507.707796] ps D 804059d4 0 26540 110 0x00100000[10510.574054] Stack : 00000000 8ba75900 807d2ff0 8008c99c 8052c27c 8057e800 00000003 880022 8ba75900 80402e34 880180a0 00000001 880180a4 80580000 804bac00 8ba75900 804be4ec 880180c4 80ab0000 804059d4 ffffff69 8ba75900 004bb030 880180a0 00000001 80402dc8 8aa7cb80 00000001 8a531df8 800f6b3c 00000002 00000000 800f7c84 8a531df8 8bc8bd60 880180c4 8ba75900 8a531d00 8a531df8 00000001 ...[10530.536867] Call Trace:[10532.061092] [&lt;80405324&gt;] __schedule+0x5d4/0x814[10533.833196] [&lt;804059d4&gt;] schedule_preempt_disabled+0x18/0x30[10535.744720] [&lt;80402dc8&gt;] mutex_lock_nested+0x264/0x468[10537.733761] [&lt;800f7c84&gt;] lookup_slow+0x44/0xd4[10539.417797] [&lt;800f9590&gt;] path_lookupat+0x13c/0x804[10541.347068] [&lt;800f9c8c&gt;] filename_lookup.isra.10+0x34/0xa0[10543.326101] [&lt;800fbd70&gt;] user_path_at_empty+0x60/0xa0[10545.166088] [&lt;800fbdc4&gt;] user_path_at+0x14/0x20[10546.921821] [&lt;800f1fe8&gt;] vfs_fstatat+0x64/0xc4[10548.672953] [&lt;800f25a4&gt;] SyS_stat64+0x18/0x3c[10550.256996] [&lt;800250b4&gt;] stack_done+0x20/0x44[10551.912049][10552.654893] 1 lock held by ps/26540:[10553.986958] #0: (&amp;sb-&gt;s_type-&gt;i_mutex_key)&#123;+.+.+.&#125;, at: [&lt;800f7c84&gt;] lookup_slow+0x44/0xd4 Detecting hung tasks in Linux Sometimes tasks under Linux are blocked forever (essentially hung). Recent Linux kernels have an infrastructure to detect hung tasks. When this infrastructure is active it will periodically get activated to find out hung tasks and present a stack dump of those hung tasks (and maybe locks held). Additionally we can choose to panic the system when we detect atleast one hung task in the system. I will try to explain how khungtaskd works. The infrastructure is based on a single kernel thread named as “khungtaskd”. So if you do a ps in your system and see that there is entry like [khungtaskd] you know it is there. I have one in my system: “136 root SW [khungtaskd]” The loop of the khungtaskd daemon is a call to the scheduler for waking it up after ever 120 seconds (default value). The core algorithm is like this: Iterate over all the tasks in the system which are marked as TASK_UNINTERRUPTIBLE (additionally it does not consider UNINTERRUPTIBLE frozen tasks &amp; UNINTERRUPTIBLE tasks that are newly created and never been scheduled out). If a task has not been switched out by the scheduler atleast once in the last 120 seconds it is considered as a hung task and its stack dump is displayed. If CONFIG_LOCKDEP is defined then it will also show all the locks the hung task is holding. One can change the sampling interval of khungtaskd through the sysctl interface /proc/sys/kernel/hung_task_timeout_secs. 该现象是内核的保护机制造成, D状态即无法中断的休眠进程，是由于在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应. 检测每一个进程控制块；当进程处于TASK_UNINTERRUPTIBLE状态时，调用check_hung_task；内核通过khungtaskd线程在hung_task_timeout_secs时间内唤醒，并检测每一个进程控制块，判断该进程是否挂起(TASK_UNINTERRUPTIBLE),如果存在挂起的任务，将调用check_hung_task。 错误日志输出原因：通过栈的dump信息，可以得到出错的主要原因是由于SyS_stat64系统调用引起。在C语言库里的函数是stat, fstat, lstat. 获取文件的状态。 12345$man stat64NAME stat, fstat, lstat - get file statusDESCRIPTION These functions return information about a file. No permissions are required on the file itself, but—in the case of stat() and lstat() — execute (search) permission is required on all of the directories in path that lead to the file. 参考 khungtaskd 检测处于TASK_UNINTERRUPTIBLE状态的进程 Linux内核调试技术——进程D状态死锁检测]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高端内存]]></title>
    <url>%2Fpost%2F19487.html</url>
    <content type="text"><![CDATA[Linux高端内存是针对物理内存来说的，虚拟内存没有高端这个概念。Linux系统将虚拟内存分为两个部分，即用户地址空间和内核地址空间，对于32位系统来说，虚拟地址空间为4GB，其中用户空间范围为0-3GB，内核空间范围为3-4GB。Linux将3GB开始的内核虚拟地址空间的896M地址直接映射到物理地址空间的0-896M，这部分是永久性映射，剩下的128M则可根据需要进行动态映射，也称临时性映射。如果没有动态映射，那么1GB的内核虚拟地址空间最多只能访问1GB的物理内存，那么如果物理内存大于1GB，就会有一部分物理内存无法被内核访问到，显然不是我们想要的。因此，对于32位系统来说，高端物理内存是内核虚拟地址空间后128M可动态映射使内核得以访问的物理内存，用户空间虚拟地址也是映射到这部分物理内存 123456789101112131415 ________________ _____ ________________ |Other KernelData|___ | | | |----------------| | |__| | | Kernel |\ |____| Real Other |3 GB ---&gt;|----------------| \ | Kernel Data | | |\ \ | | | __|_\_\____|__ Real | | Tasks | \ \ | Tasks | | __|___\_\__|__ Space | | | \ \ | | | | \ \|----------------| | | \ |Real KernelSpace| |________________| \|________________| Logical Addresses Physical Addresses 启动参数”mem=”1mem=255M@0x0 mem=256M@0x30000000 内核解析：1early_param(&quot;mem&quot;, early_parse_mem); file:arch/mips/kernel/setup.c mem参数由early_parse_mem函数处理。每一个mem=size@addr格式的参数，表示从addr地址（物理地址）开始的size大小的内存区域。如果没有”@addr”则默认起始地址为0。 参考 Linux内核高端内存]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Audio ALSA数据传输]]></title>
    <url>%2Fpost%2F6516.html</url>
    <content type="text"><![CDATA[在ALSA数据传输中，主要出现错误underrun和overrun DDR —&gt; buffer —&gt; digital singal overrun1MIC --&gt; DMIC(控制器) --&gt; DDR(RAM) --&gt; Flash 在录音时由于录音数据过快会产生overrun现象 underrun1Flash --&gt; DDR --&gt; I2S --&gt; Codec --&gt; spk 在放音时由于用户层的音频数据到DDR中的速度比控制器到codec放出的速度慢,出现underrun 断音123456+------+ +----+| | | | +---------+ +-----+| | | | DMA | | | || flash+--------&gt; DDR+-------&gt; buffer +----&gt;codec|| | | | +---------+ +-----++------+ +----+ 从flash到DDR的速度，比数据从DDR通过DMA到buffer的速度慢，导致出现断音underrun DMA没有及时的从DDR中将数据搬到FIFO DDR中申请的buffer不够大 DDR中的buffer没有数据 假如播放的是音乐格式是采样率为192KHz，采样宽度为24bit，声道为2，驱动中的buffer大小为1M bytes（256 pages），FIFO深度为64 entry，DDR为150MHz（假如cpu和DDR间的数据拷贝仅仅为200M bytes/s） DDR 那么1s播放出去的声音数据为192000 24 2/8(bytes)=1152000 bytes，而拷贝到buffer的数据为200Mbytes，即每10ms播放1152bytes,进入buffer的数据为2M bytes,而buffer仅仅有1M空间，所以播放完1 1024 1024 / 1152 =910次，即910 * 10ms=9s中内需要将程序调度回来，显然这是没有太大问题，因为我们的系统中不可能跑910个线程的。也就是说驱动中的buffer为1M byte的空间是没有问题的。 FIFO fifo为64个entry，那么存放的音频数据仅仅是64 * 24=1536 bits=192bytes，播放完这些数据需要的时间是192/115.2 (ms)=1.67ms, 也就是说需要播放完fifo中的数据后的2ms内就要把数据添加到fifo中，如果这段时间没有做到这一点，那么就断音了 xrun]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>alsa</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态指令]]></title>
    <url>%2Fpost%2F40422.html</url>
    <content type="text"><![CDATA[通过程序动态生成指令，然后进行执行 123456789 +------------&gt; +-------+ &lt;--+生成指令，写入buffer | | | + | |PC | | | buffer| | | | | | | +-------+ 12345678910uint32_t *InstBuf;InstBuf = (uint32_t)malloc(size);for (int i = 0; i &lt; 16: i++) &#123; InstBuf[i] = 0x03e00008; /* JR RA */&#125;void (*f)(void);f = (void (*)(void))(InstBuf);(*f)();]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM]]></title>
    <url>%2Fpost%2F53957.html</url>
    <content type="text"><![CDATA[内核出现OOM的log分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ 128.496873] min_free_kbytes invoked oom-killer: gfp_mask=0x200da, order=0, oom_score_adj=0[ 128.505497] min_free_kbytes cpuset=/ mems_allowed=0[ 128.510968] CPU: 0 PID: 118 Comm: min_free_kbytes Not tainted 3.10.14-00062-g277665d-dirty #322[ 128.523967] Stack : 00000000 00000000 00000000 00000000 80624582 00000053 805b0000 805ad500 8c3933a0 805ad407 8053d15c 00000076 80623d20 805ad500 00000000 00000000 805ad500 8046cffc 805c0000 8003b3bc 80b3324c 00000000 8053eecc 890019ac 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 89001938 ...[ 128.607831] Call Trace:[ 128.612474] [&lt;800209e0&gt;] show_stack+0x48/0x70[ 128.621191] [&lt;8046daf0&gt;] dump_header.isra.4+0x88/0x260[ 128.628626] [&lt;800bd78c&gt;] oom_kill_process+0xd0/0x478[ 128.635875] [&lt;800be070&gt;] out_of_memory+0x318/0x390[ 128.642951] [&lt;800c1ef4&gt;] __alloc_pages_nodemask+0x8b8/0x900[ 128.650833] [&lt;800d9104&gt;] handle_pte_fault+0xae4/0xc5c[ 128.660245] [&lt;800d9358&gt;] handle_mm_fault+0xdc/0x11c[ 128.667406] [&lt;800298d8&gt;] do_page_fault+0x158/0x480[ 128.674477] [&lt;8001a784&gt;] resume_userspace_check+0x0/0x10[ 128.684178] [ 128.687833] Mem-Info:[ 128.692287] Normal per-cpu:[ 128.699351] CPU 0: hi: 90, btch: 15 usd: 32[ 128.706406] HighMem per-cpu:[ 128.711486] CPU 0: hi: 90, btch: 15 usd: 15[ 128.718564] active_anon:120239 inactive_anon:11 isolated_anon:0[ 128.718564] active_file:5 inactive_file:2 isolated_file:0[ 128.718564] unevictable:0 dirty:0 writeback:0 unstable:0[ 128.718564] free:4617 slab_reclaimable:150 slab_unreclaimable:600[ 128.718564] mapped:1 shmem:15 pagetables:150 bounce:0[ 128.718564] free_cma:0[ 128.754330] Normal free:18244kB min:10084kB low:12604kB high:15124kB active_anon:219220kB inactive_anon:0kB active_file:20kB inactive_file:8kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:262144kB managed:241940kB mlocked:0kB dirty:0kB writeback:0kB mapped:4kB shmem:0kB slab_reclaimable:600kB slab_unreclaimable:2400kB kernel_stack:320kB pagetables:600kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:426 all_unreclaimable? yes[ 128.798925] lowmem_reserve[]: 0 2048 2048[ 128.807365] HighMem free:224kB min:256kB low:2984kB high:5716kB active_anon:261736kB inactive_anon:44kB active_file:0kBinactive_file:0kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:262144kB managed:262144kB mlocked:0kB dirty:0kB writeback:0kB mapped:0kB shmem:60kB slab_reclaimable:0kB slab_unreclaimable:0kB kernel_stack:0kB pagetables:0kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:31 all_unreclaimable? yes[ 128.850710] lowmem_reserve[]: 0 0 0[ 128.858541] Normal: 1*4kB (R) 0*8kB 0*16kB 0*32kB 1*64kB (R) 0*128kB 1*256kB (R) 1*512kB (R) 1*1024kB (R) 0*2048kB 0*4096kB 2*8192kB (R) 0*16384kB 0*32768kB 0*65536kB = 18244kB[ 128.896190] HighMem: 0*4kB 0*8kB 0*16kB 1*32kB (R) 1*64kB (R) 1*128kB (R) 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB 0*8192kB 0*16384kB 0*32768kB 0*65536kB = 224kB[ 128.928406] 22 total pagecache pages[ 128.988524] 262144 pages RAM[ 128.993703] 131072 pages HighMem[ 129.001226] 136074 pages reserved[ 129.006754] 30 pages shared[ 129.011751] 121318 pages non-shared[ 129.017458] [ pid ] uid tgid total_vm rss nr_ptes swapents oom_score_adj name[ 129.027697] [ 61] 0 61 883 18 3 0 0 syslogd[ 129.040259] [ 64] 0 64 883 18 3 0 0 klogd[ 129.050561] [ 86] 1000 86 753 38 4 0 0 dbus-daemon[ 129.061408] [ 96] 0 96 1327 70 4 0 -1000 sshd[ 129.071623] [ 103] 0 103 899 23 5 0 0 sh[ 129.081664] [ 104] 0 104 883 17 3 0 0 telnetd[ 129.094214] [ 108] 0 108 753 36 4 0 0 min_free_kbytes[ 129.105410] [ 118] 0 118 120817 120018 121 0 0 min_free_kbytes[ 129.116617] Out of memory: Kill process 118 (min_free_kbytes) score 922 or sacrifice child[ 129.129353] Killed process 118 (min_free_kbytes) total-vm:483268kB, anon-rss:480072kB, file-rss:0kB 相关变量说明file-rss1[ 129.129353] Killed process 118 (min_free_kbytes) total-vm:483268kB, anon-rss:480072kB, file-rss:0kB rss:”Resident Set Size”, 实际驻留”在内存中”的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等. 处理流程参考 Linux中进程内存RSS与cgroup内存的RSS统计 - 差异 进程实际内存占用: 私有驻留内存数(Private RSS)介绍 Out of Memory(OOM)处理流程 Taming the OOM killer]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cgroup]]></title>
    <url>%2Fpost%2F10807.html</url>
    <content type="text"><![CDATA[CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。 CGroup 是将任意进程进行分组化管理的 Linux 内核功能。CGroup 本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O 或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。这些具体的资源管理功能称为 CGroup 子系统或控制器。CGroup 子系统有控制内存的 Memory 控制器、控制进程调度的 CPU 控制器等。运行中的内核可以使用的 Cgroup 子系统由/proc/cgroup 来确认，根据系统对资源的需求，这个根进程组将被进一步细分为子进程组，子进程组内的进程是根进程组内进程的子集。而这些子进程组很有可能继续被进一步细分，最终，系统内所有的进程组形成一颗具有层次等级（hierarchy）关系的进程组树。 Cgroup虚拟文件系统 CGroup 提供了一个 CGroup 虚拟文件系统，作为进行分组管理和各子系统设置的用户接口。要使用 CGroup，必须挂载 CGroup 文件系统。这时通过挂载选项指定使用哪个子系统。 123456789101112131415161718[root@buildroot /]# mount -t cgroup cgroup /mnt/[root@buildroot /]# ls /mnt/blkio.reset_stats cpuset.mem_exclusivecgroup.clone_children cpuset.mem_hardwallcgroup.event_control cpuset.memory_migratecgroup.procs cpuset.memory_pressurecgroup.sane_behavior cpuset.memory_pressure_enabledcpu.cfs_period_us cpuset.memory_spread_pagecpu.cfs_quota_us cpuset.memory_spread_slabcpu.rt_period_us cpuset.memscpu.rt_runtime_us cpuset.sched_load_balancecpu.shares cpuset.sched_relax_domain_levelcpu.stat devices.allowcpuacct.stat devices.denycpuacct.usage devices.listcpuacct.usage_percpu notify_on_releasecpuset.cpu_exclusive release_agentcpuset.cpus tasks 各个子系统的挂载：123mount -t cgroup -o cpu cgroup /mnt/mount -t cgroup -o cpu,cpuset cgroup /mnt/mount -t cgroup -o cpu,cpuset,devices cgroup /mnt/ CGroup 支持的文件种类: 文件 R/W 用途 release_agent RW 删除分组时执行的命令，这个文件只存在于根分组 notify_on_release RW 设置是否执行 release_agent。为 1 时执行 tasks RW 属于分组的线程 TID 列表(进程ID) cgroup.procs R 属于分组的进程 PID 列表。仅包括多线程进程的线程 leader 的 TID，这点与 tasks 不同 cgroup.event_control RW 监视状态变化和分组删除事件的配置文件 基础概念 子系统（subsystem）一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。12345678[root@buildroot ~]# cat /proc/cgroups#subsys_name hierarchy num_cgroups enabledcpuset 1 1 1cpu 1 1 1cpuacct 1 1 1devices 1 1 1freezer 1 1 1blkio 1 1 1 Version: Linux-3.10.14 1.cpuset: 为cgroup中的任务分配独立CPU（SMP多核）和内存节点2.cpu： 提供调度程序对CPU的cgroup任务访问3.cpuacct： 自动生成cgroup中任务所使用的CPU报告4.devices: 允许或拒绝cgroup中的任务访问设备5.freezer：挂起或者恢复cgroup中的任务6.blkio： 块设备输入输出的限制7.perf_event： 增加了对每group的监测跟踪的能力，即可以监测属于某个特定的group的所有线程以及运行在特定CPU上的线程，此功能对于监测整个group非常有用，https://lwn.net/Articles/421574/ 层级（hierarchy）控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性；1234567891011121314151617181920[root@buildroot ~]# cat /proc/cgroups#subsys_name hierarchy num_cgroups enabledcpuset 0 1 1cpu 0 1 1cpuacct 0 1 1devices 0 1 1freezer 0 1 1blkio 0 1 1[root@buildroot ~]# mount -t cgroup -o cpu cgroup /mnt/cpu/[root@buildroot ~]# mount -t cgroup -o cpuset cgroup /mnt/cpuset/[root@buildroot ~]# mount -t cgroup -o devices cgroup /mnt/blkio/[root@buildroot ~]# mount -t cgroup -o blkio cgroup /mnt/blkio/[root@buildroot ~]# cat /proc/cgroups#subsys_name hierarchy num_cgroups enabledcpuset 0 1 1cpu 4 1 1cpuacct 0 1 1devices 0 1 1freezer 0 1 1blkio 0 1 1 一个子系统最多只能附加到一个层级 控制族群（control group） 控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制.1234567891011121314151617181920[root@buildroot cpu]# mkdir aaa[root@buildroot cpu]# mkdir bbb[root@buildroot cpu]# lsaaa/ cgroup.sane_behavior cpu.sharesbbb/ cpu.cfs_period_us cpu.statcgroup.clone_children cpu.cfs_quota_us notify_on_releasecgroup.event_control cpu.rt_period_us release_agentcgroup.procs cpu.rt_runtime_us tasks[root@buildroot cpu]# ls aaa/ bbb/aaa/:cgroup.clone_children cpu.cfs_quota_us cpu.statcgroup.event_control cpu.rt_period_us notify_on_releasecgroup.procs cpu.rt_runtime_us taskscpu.cfs_period_us cpu.sharesbbb/:cgroup.clone_children cpu.cfs_quota_us cpu.statcgroup.event_control cpu.rt_period_us notify_on_releasecgroup.procs cpu.rt_runtime_us taskscpu.cfs_period_us cpu.shares 任务（task）在 cgroups 中，任务就是系统的一个进程1234[root@buildroot cpu]# cat tasks123 关系 每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 root cgroup，此cgroup在创建层级时自动创建，后面在该层级中创建的cgroup都是此cgroup的后代）的初始成员; root cgroup:12345[root@buildroot mnt]# cat tasks123... subsys cgroup:123[root@buildroot mnt]# mkdir aaa[root@buildroot mnt]# cd aaa/[root@buildroot aaa]# cat tasks 一子系统最多只能附加到一个层级; 一个层级可以附加多个子系统; 一个任务可以是多个cgroup的成员，但是这些cgroup必须在不同的层级; 系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的cgroup。 限制cpu的资源CPU资源的控制，主要是对CPU计算的控制，可以最大化的利用CPU资源。而进程是对CPU资源的利用实体。 实时进程控制 – 系统整体 控制实时进程的CPU资源占用 获取当前系统的设置 1234# sysctl -n kernel.sched_rt_period_us # 实时进程调度的单位CPU时间 1 秒1000000# sysctl -n kernel.sched_rt_runtime_us # 实时进程在 1 秒中实际占用的CPU时间, 0.95秒950000 设置实时进程占用CPU时间 12# sysctl -w kernel.sched_rt_runtime_us=970000 # 设置实时进程每1秒中只占0.97秒的CPU时间kernel.sched_rt_runtime_us = 970000 sysctl -w : 临时修改指定参数的值 实时进程控制 – 系统部分 通过cgroup对一组进程中的实时进程的CPU资源进行控制. 12345678910# mount -t cgroup cgroup -o cpu /mnt/# lscgroup.clone_children cpu.cfs_quota_us notify_on_releasecgroup.event_control cpu.rt_period_us release_agentcgroup.procs cpu.rt_runtime_us taskscgroup.sane_behavior cpu.sharescpu.cfs_period_us cpu.stat# cat cpu.rt_period_us cpu.rt_runtime_us1000000950000 通过虚拟文件系统mount出CPU子系统，为CPU子系统的根节点，其可以控制整个系统的进程tasks,因此如果想对部分实时进程进行控制，需要创建子cgroup，并将需要控制的进程搬到新的cgroup中。 12345# mkdir rt_ctl# cd rt_ctl/# echo PID &gt; tasks# echo 1000000 &gt; cpu.rt_period_us# echo 920000 &gt; cpu.rt_runtime_us 通过配置cpu.rt_period_us和cpu.rt_runtime_us就可以对rt_ctl cgroup 中的进程组中的实时进程进行CPU使用时间的控制. 在子cgroup中，对相关子系统进行修改时，该子系统的相关属性小于父cgroup属性的相应值。 12# echo 960000 &gt; cpu.rt_runtime_ussh: write error: Invalid arguments 限制进程的内存资源内核配置： 12345Location: -&gt; General setup -&gt; Control Group support (CGROUPS [=y]) -&gt; Resource counters (RESOURCE_COUNTERS [=y]) -&gt; Memory Resource Controller for Control Groups (MEMCG [=y]) 123456789101112131415161718# mount -t cgroup -o memory cgroup /mnt/## cd /mnt/# lscgroup.clone_children memory.kmem.usage_in_bytescgroup.event_control memory.limit_in_bytescgroup.procs memory.max_usage_in_bytescgroup.sane_behavior memory.move_charge_at_immigratememory.failcnt memory.oom_controlmemory.force_empty memory.pressure_levelmemory.kmem.failcnt memory.soft_limit_in_bytesmemory.kmem.limit_in_bytes memory.statmemory.kmem.max_usage_in_bytes memory.swappinessmemory.kmem.slabinfo memory.usage_in_bytesmemory.kmem.tcp.failcnt memory.use_hierarchymemory.kmem.tcp.limit_in_bytes notify_on_releasememory.kmem.tcp.max_usage_in_bytes release_agentmemory.kmem.tcp.usage_in_bytes tasks memsw:表示虚拟内存，不带memsw的仅包括物理内存 limit_in_bytes 是用来限制内存使用 ,memory.memsw.limit_in_bytes 必须大于或等于 memory.limit_in_byte。要解除内存限制，对应的值设为 -1 这种方式限制进程内存占用会有个风险。当进程试图占用的内存超过限制时，会触发 oom ，导致进程直接被杀，从而造成可用性问题。即使关闭控制组的 oom killer，在内存不足时，进程虽然不会被杀，但是会长时间进入 D 状态（等待系统调用的不可中断休眠），并被放到 OOM-waitqueue 等待队列中， 仍然导致服务不可用。因此，用 memory.limit_in_bytes 或 memory.memsw.limit_in_bytes 限制进程内存占用仅应当作为一个保险，避免在进程异常时耗尽系统资源 memory.oom_control：内存超限之后的OOM行为控制 123# cat memory.oom_controloom_kill_disable 0under_oom 0 关闭oom killer： oom_kill_disable为1 memory.soft_limit_in_bytes: memory.limit_in_bytes 的不同是，这个限制并不会阻止进程使用超过限额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。 memory.usage_in_bytes: 当前使用量 memory.max_usage_in_bytes: 最高使用量 memory.failcnt: 发生的缺页次数（申请内存失败的次数) memory.stat: 就是内存使用情况报告了。包括当前资源总量、使用量、换页次数、活动页数量等等 进程迁移在多核处理器时，如果想将一个进程指定到特定的CPU上进行执行，可通过cpuset子系统实现。 cpuset:针对 CPU 核心进行隔离，其实就是把要运行的进程绑定到指定的核心上运行，通过让不同的进程占用不同的核心，以达到运算资源隔离的目的。为cgroup中的任务分配独立CPU（在多核系统）和内存节点。 挂载 cgroup 文件系统, 并指定 -o cpuset 指定 A 的物理CPU为 0 (双核CPU的每个核编号分别是 CPU0, CPU1) 指定 B 的物理CPU也为 1 12345678910111213141516# mount -t cgroup -o cpuset cgroup /mnt/# cat cpuset.cpus cpuset.mems0-10# cd /mnt/# mkdir A B # 创建子cgroup A 和 B# cat A/cpuset.cpus# cat B/cpuset.cpus# echo 0 &gt; A/cpuset.cpus # 设置A组绑定到CPU0# echo 1 &gt; B/cpuset.cpus # 设置B组绑定到CPU1# echo 0 &gt; A/cpuset.mems # 设置A组绑定内存# echo 0 &gt; B/cpuset.mems # 设置A组绑定内存# echo pid1 &gt; A/tasks #将B组进程迁入A组# echo pid2 &gt; B/tasks #将A组进程迁入B组 123&gt;# echo $$ &gt; tasks&gt;sh: write error: No space left on devices&gt; 原因：没有配置cpuset.mems 应用实例 ltp-full-20140115/testcases/kernel/controllers/cpuctl/cpuctl_test02.c 参考 CGroup 介绍、应用实例及原理描述 控制族群（CGROUP） Linux内核工程导论——CGroup子系统 Linux资源控制-使用cgroup控制CPU和内存 cgroup实践-资源控制 cgroup原理简析:vfs文件系统 Docker背后的内核知识——cgroups资源限制 Linux cgroup机制分析之框架分析]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内存的VM参数]]></title>
    <url>%2Fpost%2F18938.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233[root@buildroot ~]# sysctl -a | grep &quot;vm&quot;sysctl: error reading key &apos;net.ipv4.route.flush&apos;: Permission deniedvm.admin_reserve_kbytes = 8192vm.block_dump = 0vm.dirty_background_bytes = 0vm.dirty_background_ratio = 10vm.dirty_bytes = 0vm.dirty_expire_centisecs = 3000vm.dirty_ratio = 20vm.dirty_writeback_centisecs = 500vm.drop_caches = 0vm.extra_free_kbytes = 0vm.highmem_is_dirtyable = 0vm.laptop_mode = 0vm.legacy_va_layout = 0vm.lowmem_reserve_ratio = 32 32vm.max_map_count = 65530vm.min_free_kbytes = 1970vm.min_free_order_shift = 1vm.mmap_min_addr = 4096vm.nr_pdflush_threads = 0vm.oom_dump_tasks = 1vm.oom_kill_allocating_task = 0vm.overcommit_memory = 0vm.overcommit_ratio = 50vm.page-cluster = 3vm.panic_on_oom = 0vm.percpu_pagelist_fraction = 0vm.scan_unevictable_pages = 0vm.stat_interval = 1vm.swappiness = 60vm.user_reserve_kbytes = 15712vm.vfs_cache_pressure = 100 proc文件系统：ls /proc/sys/vm/ overcommit_memory 内核分配内存的策略，有0，1，2三种 overcommit_memory 说明 0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何 2 表示内核允许分配超过所有物理内存和交换空间总和的内存]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核--中断]]></title>
    <url>%2Fpost%2F21246.html</url>
    <content type="text"><![CDATA[中断有两种： 由CPU外部产生。（被动） 由CPU本身在执行程序的时候产生。（主动） 中断服务程序一般都是在中断请求关闭的条件下执行的，以避免嵌套而使中断控制复杂化。但是，中断是一个随机事件，它随时会到来，如果关中断的时间太长，CPU就不能及时响应其他的中断请求，从而造成中断的丢失。因此为了保证所有的中断都被响应，并且相对公平的执行，引入了中断下半部，主要有tasklet，工作队列，软中断和线程化irq 条件 tasklet workqueue softirq 运行上下文 软中断 进程（内核态） 软中断 是否sleep 否 否 否 是否关中断 否 否 否 是否可重新调度 是 否 否 是否可带参数 是 否 否 谁被触发，谁执行 是 默认是（进程调度） 是 可同时多CPU执行 同一个Tasklet在任意时刻, 只能被一个CPU执行 有进程调度决定 同一个softirq_action, 可同时被多个CPU执行 是否可延时执行 否 是 否 数据结构 softirq_action(中断服务), irq_cpustat_t(触发状态) tasklet_struct, tasklet_head work_struct, workqueue_struct 初始化 open_softirq tasklet_init, DECLARE_TASKLET INIT_DELAYED_WORK 改变运行状态 tasklet_trylock, tasklet_unlock 使能/停止 tasklet_enable, tasklet_disable 触发 raise_softirq, raise_softirq_irqoff tasklet_schedule, tasklet_hi_schedule schedule_work, queue_work, schedule_delayed_work 执行 do_softirq tasklet_action, tasklet_hi_action resouer_thread被CPU调度执行 创建线程 alloc_workqueue 结束 tasklet_kill destroy_weoker, destroy_weokequeue 上半部 实时性要求高 不能被中断 上半部的功能是响应中断。当中断发生时，它就把设备驱动程序中中断处理例程的下半部挂到设备的下半部执行队列中去，然后继续等待新的中断到来 下半部下半部所负责的工作一般是查看设备以获得产生中断的事件信息，并根据这些信息（一般通过读设备上的寄存器得来）进行相应的处理。 上半部与下半部的区分？ 下半部和上半部最大的区别是可中断，而上半部却不可中断 对于一个中断，如何划分上下两部分呢？哪些处理放在上半部，哪些处理放在下半部？ 如果一个任务对时间十分敏感，将其放在上半部 如果一个任务和硬件有关，将其放在上半部 如果一个任务要保证不被其他中断打断，将其放在上半部 其他所有任务，考虑放在下半部 下半部的实现方式软中断linux中，执行软中断有专门的内核线程，每个处理器对应一个线程，名称ksoftirqd/n (n对应处理器号) Tasklet工作队列线程化irq区别 什么时候选择哪种方式更好？ 参考 中断处理“下半部”机制 《Linux内核设计与实现》读书笔记（八）- 中断下半部的处理]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ANR分析]]></title>
    <url>%2Fpost%2F35493.html</url>
    <content type="text"><![CDATA[ANR是Application Not Response的简写就是应用没有响应。Android应用主线程卡住的时候系统会提示用户是否需要结束掉此App，这是Android系统优化用户体验的一种做法，类似的Windows系统也有类似“程序没有响应”的提示。就是主线程无法及时响应用户输入 123E/ActivityManager( 373): ANR in com.android.settings (com.android.settings/.Settings)E/ActivityManager( 373): PID: 803E/ActivityManager( 373): Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.) 原因 主线程被阻塞 主线程有耗时操作,比如IO 主线程异常操作比如Thread.sleep,Thread.wait (Activity)应用在5秒内没有响应用户输入（例如键盘输入, 触摸屏幕等） BroadcastReceiver10秒钟没有响应 获取不到CPU时间片（CPU太满了） CPU占有率100%123456789101112E/ActivityManager( 373): ANR in com.android.settings (com.android.settings/.Settings)E/ActivityManager( 373): PID: 803E/ActivityManager( 373): Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.) Load: 1.43 / 2.3 / 1.84 //表示ANR发生之前的一段时间内的CPU使用率，并不是某一时刻的值 CPU usage from 810ms to -13732ms ago: 63% 803/com.android.settings: 17% user + 45% kernel / faults: 3557 minor 225 major 55% 373/system_server: 22% user + 33% kernel / faults: 3423 minor ... 1% 569/android.process.acore: 0% user + 1% kernel / faults: 1 minor 1% 777/Binder_4: 0% user + 1% kernel100% TOTAL: 39% user + 60% kernel traces memory1Heap: 15% free, 1338KB/`1585KB`; 51388 objects 虚拟机堆会动态扩展，1585KB代表堆扩展到的大小，1338KB代表堆上使用的大小，15%是使用的百分比, 51388创建的对象数量 12345671. //Total number of allocations 1703402. //Total bytes allocated 13MB3. //Free memory 247KB4. //Free memory until GC 247KB5. //Free memory until OOME 62MB6. //Total memory `1585KB`7. //Max memory 64MB 进程创建到现在一共创建的对象数 进程创建到现在一共申请的内存 不扩展堆的情况下可用的内存 可回收的大小 还能扩展多少内存达到Max memory 堆扩展后的大小 进程最多能申请的内存 参考 ANR机制以及问题分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell常用代码]]></title>
    <url>%2Fpost%2F3776.html</url>
    <content type="text"><![CDATA[shell常用代码： 多线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/bin/shcpu_tmp=0cpu=""pmon=""cycles=0data_dir="test_rpt.$$"while read LINEdo if echo $LINE|grep 'cpu_tmp' then cpu_tmp=$&#123;LINE#*:&#125; fi if echo $LINE|grep 'cycles' then cycles=$&#123;LINE#*:&#125; fidone &lt; run.cfg#多线程：# init fifo fileTHREAD1DIR=3 &amp;&amp; FIFONR=4 &amp;&amp; FIFONAME="$$.ff" &amp;&amp; mkfifo $FIFONAME &amp;&amp; str="exec $FIFONR&lt;&gt; $FIFONAME" &amp;&amp; eval $str &amp;&amp; rm $FIFONAME -fi=0while [ $i -lt $THREAD1DIR ]; do i=$((i+1)) echodone &gt;&amp; $FIFONR#for (( i=0; i&lt;$THREAD1DIR; i++ )); do# start test 1st level dirall=`find . -maxdepth 1 -name "?????\.*"`for i in $alldo if [ -d $i ] then read ( echo $i" 1runing" &amp;&amp; cd $i/ &amp;&amp; ./$i'.run'.sh $cycles &amp;&amp; cd - &amp;&amp; echo &gt;&amp; $FIFONR ) &amp; fidone &lt;&amp; $FIFONR# rm fifo filewait &amp;&amp; str="exec $FIFONR&gt;&amp;-" &amp;&amp; eval $str#get log[ -d $data_dir ] &amp;&amp; rm -rf $data_dir || mkdir $data_dir &amp;&amp; cp run.cfg $data_dir -ffor i in $alldo if [ -d $i ] then des_dir=$data_dir'/'$i'/' mkdir $des_dir src_dir='./'$i'/' file_path=`find $src_dir/ -name *_*.log` echo $file_path mv $file_path $des_dir fidonechmod 777 './'$data_dir -Rrm *.ff -f 修改文件名后缀123456for file in `find . -name "*.f90"`do newfile=$&#123;file%.*&#125;.f77 #echo "$newfile" mv $file $newfiledone Linux批量更改文件后缀名 检查网段IP占用情况12345678910111213141516171819202122#!/bin/bashup=0down=0for siteip in $(seq 1 255)do #site="192.168.2.$&#123;siteip&#125;" site="172.16.189.$&#123;siteip&#125;" ping -c1 -W1 $&#123;site&#125; &amp;&gt; /dev/null if [ "$?" == "0" ]; then up=$[$up+1] echo "$site is UP, cnt=$up" else down=$[$down+1] echo "$site is DOWN, cnt=$down" fidone# 除法alive=`awk 'BEGIN&#123;printf "%.2f\n",('$up'/'$(($up + $down))')&#125;'`echo "up:$up, down:$down, alive:$alive" 提取本地IP1ip=`ifconfig | grep &quot;inet &quot; | grep -v &quot;127.0.0.1&quot;| awk &apos;&#123;print $2&#125;&apos;` -v: 排除 参考 [shell中各种括号的作用()、(())、[]、[]]、{}]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ART编译预优化]]></title>
    <url>%2Fpost%2F40126.html</url>
    <content type="text"><![CDATA[1234567# Enable dex-preoptimization to speed up the first boot sequence # of an SDK AVD. Note that this operation only works on Linux for now ifeq ($(HOST_OS),linux) ifeq ($(WITH_DEXPREOPT),) WITH_DEXPREOPT := true endif endif device/xxx/xxx/BoardConfig.mk WITH_DEXPREOPT true system image 就会被预先优化. 由于在启动时不再需要进行app的dex文件进行优化(dex2oat操作)从而提升其启动速度. false 禁止预编译优化，在系统启动时编译 ARTART兼容Dalvik.也就是说ART 能运行”dex”(Dalvik执行文件).因此对Androidapp的开发者来说,他们没有什么区别.两者最大的区别是:ART把JIT(Just-in-Time)变成了AOT(Ahead-of-Time).JIT需要在每次运行app时都需要执行一遍,而AOT 只需要执行一次,而后续再运行此app是不需要再执行,其明显提高了性能.当然ART 这样做,也是有代价的,那就是以空间换时间.ART能对应用的所有code做优化,其把bitcode 编译为ELF文件.而ELF文件也往往比odex文件大很多.而JIT只能对local/method做优化.ART的另一个缺点是其第一次执行优化时需要更长的时间.这也是导致第一次开机时间过长的原因 dex2oatdex2oat顾名思义dex file to oat file，就是在新旧两种运行时文件的转换。 dex文件字节码，（多个class每个文件都有的共有信息合成一体）oat文件格式:ELF 好处 优化开机速度，减少启动时间(不是第一次) 参考 Android 开机速度优化—–ART 预先优化]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务调度]]></title>
    <url>%2Fpost%2F65317.html</url>
    <content type="text"><![CDATA[调度器 多任务操作系统分为非抢占式多任务和抢占式多任务。与大多数现代操作系统一样，Linux采用的是抢占式多任务模式。这表示对CPU的占用时间由操作系统决定的，具体为操作系统中的调度器。调度器决定了什么时候停止一个进程以便让其他进程有机会运行，同时挑选出一个其他的进程开始运行 schedule 抢占 调度时机 调度什么时候发生？schedule()函数什么时候被调用 调度方式： 主动式调度（自愿调度）在内核中进程直接调用schelule(), 当进程需要等待资源而暂时停止运行时，会把进程状态置为挂起（睡眠），并主动请求调度，让出CPU。 被动式调度（抢占调度）内核抢占和用户抢占 用户抢占当内核即将返回用户空间时, 内核会检查need_resched是否设置, 如果设置, 则调用schedule(), 此时,发生用户抢占. 内核抢占内核抢占就是指一个在内核态运行的进程, 可能在执行内核函数期间被另一个进程取代. 参考 Linux用户抢占和内核抢占详解(概念, 实现和触发时机)–Linux进程的管理与调度(二十）)]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cache]]></title>
    <url>%2Fpost%2F50757.html</url>
    <content type="text"><![CDATA[123456789101112+----+ +----+ +----+ +----+|CPU0| |CPU1| |CPU2| |CPU3|+----+ +----+ +----+ +----+ +-+ +-+ +-+ +-+ | | | |+---v-----v--+ +--v------v--+| L1 Cache | | L2 Cache |+------+-----+ +------+-----+ | |+------v----------------v-----+| L2 Cache |+-----------------------------+ Cache 初始化1234kernel_start \-&gt;setup_arch \-&gt;cpu_cache_init \-&gt;r4k_cache_init 123456#define cpu_dcache_size() (32 * 1024) #define cpu_dcache_ways() 8 #define cpu_dcache_line_size() 32 #define cpu_icache_size() (32 * 1024) #define cpu_icache_ways() 8 #define cpu_icache_line_size() 32 cpuinfo_mips12345678910111213141516struct cpuinfo_mips &#123; unsigned int udelay_val; ... /* *Capability and feature descriptor structure for MIPS CPU */ unsigned int processor_id; unsigned int fpu_id; unsigned int msa_id; unsigned int cputype; ...&#125; __attribute__((aligned(SMP_CACHE_BYTES))); extern struct cpuinfo_mips cpu_data[]; #define current_cpu_data cpu_data[smp_processor_id()] #define raw_current_cpu_data cpu_data[raw_smp_processor_id()] file: arch/mips/include/asm/cpu-info.h 初始化：12struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;EXPORT_SYMBOL(cpu_data); file: arch/mips/kernel/setup.c]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cache</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setup_per_cpu_areas]]></title>
    <url>%2Fpost%2F23122.html</url>
    <content type="text"><![CDATA[为了对内核的内存管理（mm）进行初始化而调用的函数之一。只在SMP系统中调用，UP（单核）中不执行任何操作。为SMP的每个处理器生成per-cpu数据 12start_kernel \-&gt;setup_per_cpu_areas file: init/main.c 参考 start_kernel——setup_per_cpu_areas 对Linux内核中percpu data进行分析]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPI通信（SMP）]]></title>
    <url>%2Fpost%2F60164.html</url>
    <content type="text"><![CDATA[IPI(Interrupt-Procecesorr Interrupt): 处理中间的中断 主要应用是一个处理器让另一个处理器做特定的事情（function和sched） 123456789101112131415161718192021222324 +---------------------------+-+system boot | request_percpu_irq（） + | mailbox irq handle + +--+-----------------------+--+ | | | | +--v--+ +---v-+ | CPU0| &gt; CPU1| +--+--+ +----++ | | +----+----+ +-----+-----+ |mailbox0 | +--&gt;mailbox1 | +---------+ | +-----------+ | +---------------+ |system run A send IPI CPU1 | write mailbox1 | | | | +-----v-----------------+---+ +------+----+ | 1. 读取mailbox中的action + | Task A | | 2. 通过action判断IPI类型 + | | | 3. 进行function和sched处理+ +-----------+ | + +---------------------------+ 在多核处理器中，每一个CPU核有一个mailbox(相当于邮箱)，如果需要进行IPI通信时，其主要通过IPI的中断实现。假设CPU0需要给CPU1发送一个action(actionI的类型：SMP_CALL_FUNCTION,SMP_RESCHEDULE_YOURSELF等)时, 只需要CPU0向CPU1的mailbox中写于action的id（相当于信），此时CPU1将产生一个IPI中断（表明收到信），mailbox的中断处理程序将读取mailbox（相当于看信）中的action，判断action的类型进行相应的处理。 MIPS架构下的IPI通信 关闭中断后还会发送IPI MIPS接口12345struct plat_smp_ops &#123; void (*send_ipi_single)(int cpu, unsigned int action); void (*send_ipi_mask)(const struct cpumask *mask, unsigned int action); ...&#125; IPI通信就是多个处理器之间的交流。send_ipi_single： 一对一聊天send_ipi_mask : 群发，mask表示群发的成员（CPU） action类型1234567#define SMP_RESCHEDULE_YOURSELF 0x1 /* XXX braindead */#define SMP_CALL_FUNCTION 0x2/* Octeon - Tell another core to flush its icache */#define SMP_ICACHE_FLUSH 0x4/* Used by kexec crashdump to save all cpu's state */#define SMP_DUMP 0x8#define SMP_IPI_TIMER 0xC file: arch/mips/include/asm/smp.h 不同的action(活动)何时将产生？ 各自都有什么作用？ SMP_RESCHEDULE_YOURSELF SMP_RESCHEDULE_YOURSELF将直接调用scheduler_ipi.将任务插入目标CPU的运行队列。 1234567891011/* * this function sends a 'reschedule' IPI to another CPU. * it goes straight through and wastes no time serializing * anything. Worst case is that we lose a reschedule ... */static inline void smp_send_reschedule(int cpu)&#123; extern struct plat_smp_ops *mp_ops; /* private */ mp_ops-&gt;send_ipi_single(cpu, SMP_RESCHEDULE_YOURSELF);&#125; file: arch/mips/include/asm/smp.h SMP_CALL_FUNCTION SMP_CALL_FUNCTION:将特定的函数在目标CPU上运行 内核回调接口：12345678910111213static inline void arch_send_call_function_single_ipi(int cpu)&#123; extern struct plat_smp_ops *mp_ops; /* private */ mp_ops-&gt;send_ipi_mask(&amp;cpumask_of_cpu(cpu), SMP_CALL_FUNCTION);&#125;static inline void arch_send_call_function_ipi_mask(const struct cpumask *mask)&#123; extern struct plat_smp_ops *mp_ops; /* private */ mp_ops-&gt;send_ipi_mask(mask, SMP_CALL_FUNCTION);&#125; file: arch/mips/include/asm/smp.h 123456789101112131415161718192021222324252627282930/* * smp_call_function_single - Run a function on a specific CPU * @func: The function to run. This must be fast and non-blocking. * @info: An arbitrary pointer to pass to the function. * @wait: If true, wait until function has completed on other CPUs. * * Returns 0 on success, else a negative status code. */smp_call_function_single \-&gt;generic_exec_single \-&gt;arch_send_call_function_single_ipi/** * smp_call_function_many(): Run a function on a set of other CPUs. * @mask: The set of cpus to run on (only runs on online subset). * @func: The function to run. This must be fast and non-blocking. * @info: An arbitrary pointer to pass to the function. * @wait: If true, wait (atomically) until function has completed * on other CPUs. * * If @wait is true, then returns once @func has returned. * * You must not call this function with disabled interrupts or from a * hardware interrupt handler or from a bottom half handler. Preemption * must be disabled when calling this function. */smp_call_function_many \-&gt;arch_send_call_function_ipi_mask file: kernel/smp.c 刷新TLB多核进行TLB的同步？]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>SMP</tag>
        <tag>IPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2Fpost%2F28384.html</url>
    <content type="text"><![CDATA[123[15299.717341] BUG: spinlock lockup suspected on CPU#1, rixitest/4186[15299.723758] lock: 0x8c77d644, .magic: dead4ead, .owner: rixitest/4161, .owner_cpu: 0[15299.731858] CPU: 1 PID: 4186 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c #3 死锁检测以spin_lock进行死锁机制的检测流程说明： raw_lock12345678910111213typedef struct raw_spinlock &#123; arch_spinlock_t raw_lock;#ifdef CONFIG_GENERIC_LOCKBREAK unsigned int break_lock;#endif#ifdef CONFIG_DEBUG_SPINLOCK unsigned int magic, owner_cpu; void *owner;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map dep_map;#endif&#125; raw_spinlock_t; 死锁的检测内核需要配置CONFIG_DEBUG_SPINLOCK,它主要使用的数据有magic, owner_cpu,*owner: type 作用 magic 幻数,表示锁以及初始化 owner_cpu raw_smp_processor_id(),锁所在的当前CPU号 *ower current,锁所在的当前进程 Init123456789101112#define SPINLOCK_MAGIC 0xdead4ead#define SPINLOCK_OWNER_INIT ((void *)-1L)#ifdef CONFIG_DEBUG_SPINLOCK# define SPIN_DEBUG_INIT(lockname) \ .magic = SPINLOCK_MAGIC, \ .owner_cpu = -1, \ .owner = SPINLOCK_OWNER_INIT,#else# define SPIN_DEBUG_INIT(lockname)#endif 初始化时owner_cpu=-1表示该锁不属于任何CPU，并且不属于任何进程(owner=(void *)-1L) Use 在什么时候指明该锁属于哪一个CPU，哪一个进程。 上锁时指定：spin_lock 解锁时恢复：spin_unlock 123456789spin_lock |_raw_spin_lock |__raw_spin_lock --&gt; &#123; preempt_disable(); spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_); LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); &#125; do_raw_spin_trylock定义：CONFIG_LOCK_STAT 12345678910111213141516static inline voiddebug_spin_lock_before(raw_spinlock_t *lock)&#123; SPIN_BUG_ON(lock-&gt;magic != SPINLOCK_MAGIC, lock, "bad magic"); //进程重入 SPIN_BUG_ON(lock-&gt;owner == current, lock, "recursion"); //CPU重入 SPIN_BUG_ON(lock-&gt;owner_cpu == raw_smp_processor_id(), lock, "cpu recursion");&#125;static inline void debug_spin_lock_after(raw_spinlock_t *lock)&#123; lock-&gt;owner_cpu = raw_smp_processor_id(); lock-&gt;owner = current;&#125; 12345678910111213141516171819202122232425定义：CONFIG_LOCK_STAT#define LOCK_CONTENDED(_lock, try, lock) \do &#123; \ if (!try(_lock)) &#123; \ lock_contended(&amp;(_lock)-&gt;dep_map, _RET_IP_); \ lock(_lock); \ &#125; \ lock_acquired(&amp;(_lock)-&gt;dep_map, _RET_IP_); \&#125; while (0)int do_raw_spin_trylock(raw_spinlock_t *lock)&#123; int ret = arch_spin_trylock(&amp;lock-&gt;raw_lock); if (ret) debug_spin_lock_after(lock); //上锁成功后进行重新赋值#ifndef CONFIG_SMP /* * Must not happen on UP: */ SPIN_BUG_ON(!ret, lock, "trylock failure on UP");#endif return ret;&#125; file: lib/spinlock_debug.c do_raw_spin_lock1234567891011#define LOCK_CONTENDED(_lock, try, lock) \ lock(_lock)void do_raw_spin_lock(raw_spinlock_t *lock)&#123; debug_spin_lock_before(lock); if (unlikely(!arch_spin_trylock(&amp;lock-&gt;raw_lock))) __spin_lock_debug(lock); debug_spin_lock_after(lock);&#125; file: lib/spinlock_debug.c arch_spin_trylock主要实现不同架构的实际加锁的功能函数。如果上锁失败将进入_spin_lock_debug函数，打印上锁失败的原因。在do_raw_spin_lock函数中除路上锁的关键函数，其他函数均为debug函数，这里主要说明debug函数的原理和死锁出现后的debug info的具体含义。 Debug Info如果上锁失败，将不断尝试上锁直到超时，内核认为出现死锁，主要的引起原因有：该锁没有被释放（排除CPU硬件错误） 1234567891011121314static void __spin_lock_debug(raw_spinlock_t *lock)&#123; u64 i; u64 loops = loops_per_jiffy * HZ; for (i = 0; i &lt; loops; i++) &#123; if (arch_spin_trylock(&amp;lock-&gt;raw_lock)) return; __delay(1); &#125; /* lockup suspected: */ spin_dump(lock, "lockup suspected"); ...&#125; 1unsigned long loops_per_jiffy = (1&lt;&lt;12); file: /init/main.c loops_per_jiffy:定义超时时间, (4096)_delay(1)为4096s 123[15299.717341] BUG: spinlock lockup suspected on CPU#1, rixitest/4186[15299.723758] lock: 0x8c77d644, .magic: dead4ead, .owner: rixitest/4161, .owner_cpu: 0[15299.731858] CPU: 1 PID: 4186 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c #3 1234567891011121314static void spin_dump(raw_spinlock_t *lock, const char *msg)&#123; ... printk(KERN_EMERG "BUG: spinlock %s on CPU#%d, %s/%d\n", msg, raw_smp_processor_id(), current-&gt;comm, task_pid_nr(current)); printk(KERN_EMERG " lock: %pS, .magic: %08x, .owner: %s/%d, " ".owner_cpu: %d\n", lock, lock-&gt;magic, owner ? owner-&gt;comm : "&lt;none&gt;", owner ? task_pid_nr(owner) : -1, lock-&gt;owner_cpu); dump_stack();&#125; lockup suspected on CPU#1: 说明当前检测到死锁的CPU为核1.owner_cpu: 0:说明之前上锁的CPU为核0 以上log说明有一把锁，在核0上锁后，没有释放之前核1有一次去上锁，从而导致死锁 场景信号异常造成的死锁 两核互锁 1234567891011121314151617181920212223242526272829303132333435363738394041[ 50.920653] BUG: spinlock lockup suspected on CPU#0, rixitest/835[ 50.933282] lock: 0x8c57c9e4, .magic: dead4ead, .owner: rixitest/507, .owner_cpu: 1[ 50.941294] CPU: 0 PID: 835 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c-dirty [ 50.949568] Stack : 8211374a 0000004b 80510000 80510000 00000343 80050000 8c888d40 8049e028 00000000 00000343 82112ee0 8004eee8 8cff7ee8 82120000 803e79ac 80510000 8003b454 8c57c9e4 00000000 8049fb4c 8cff7d74 8cff7d74 8c888d40 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 8cff7d08 ... [ 50.986508] Call Trace: [ 50.989051] [&lt;80021cf4&gt;] show_stack+0x48/0x70 [ 50.993564] [&lt;8021c804&gt;] do_raw_spin_lock+0x12c/0x184 //spin_lock_irq(&amp;sighand-&gt;siglock)[ 50.998793] [&lt;8004ecc0&gt;] get_signal_to_deliver+0xb8/0x690[ 51.004378] [&lt;8001fb08&gt;] do_signal+0x30/0x1fc [ 51.008887] [&lt;80020c84&gt;] do_notify_resume+0x34/0x90[ 51.013940] [&lt;8001b8a4&gt;] work_notifysig+0x10/0x18 [ 51.018802] [ 64.332523] SMP[0] action:1 will reenter, mailbox:1, timeout:16777216[ 64.339172] CPU: 1 PID: 507 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c-dirty [ 64.347425] Stack : 8211374a 0000004b 80510000 80510000 000001fb 01000000 8c54b9c0 8049e028 00000001 000001fb 82112ee0 00000000 8c551ee8 82120000 803e79ac 00000000 8003b454 00000006 00000000 8049fb4c 8c551c14 8c551c14 8c54b9c0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 8c551ba8 ... [ 64.384270] Call Trace: [ 64.386796] [&lt;80021cf4&gt;] show_stack+0x48/0x70 [ 64.391295] [&lt;80011eb4&gt;] xburst2_send_ipi_single+0xb4/0x114[ 64.397051] [&lt;8006d800&gt;] try_to_wake_up+0x298/0x31c[ 64.402093] [&lt;8004c7fc&gt;] signal_wake_up_state+0x44/0x68[ 64.407489] [&lt;80138e44&gt;] zap_process+0x80/0xbc //spin_lock_irq(&amp;tsk-&gt;sighand-&gt;siglock); [ 64.412077] [&lt;8013926c&gt;] do_coredump+0x160/0xc24 [ 64.416843] [&lt;8004f24c&gt;] get_signal_to_deliver+0x644/0x690[ 64.422504] [&lt;8001fb08&gt;] do_signal+0x30/0x1fc [ 64.427002] [&lt;80020c84&gt;] do_notify_resume+0x34/0x90[ 64.432040] [&lt;8001b8a4&gt;] work_notifysig+0x10/0x18 [ 64.436889] 死锁的产生和发送IPI的先后顺序：先死锁后发送IPI 最开始的两个打印可以得到，CPU0进行上锁时，发现该锁被CPU1所持有，所以造成两核互锁 CPU1上完spin_lock_irq(siglock)锁后，发送IPI（sched调度），此时信号处理进程被调度到CPU0，并且也进行spin_lock_irq(siglock)上锁，由于CPU1上完锁后等待IPI的完成，但是此时CPU1已经关闭中断的IE位，其中包括IPI中断，因此IPI无法完成，CPU1的锁无法释放，同时CPU0又在上同一把锁siglock,从而造成死锁]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASLR]]></title>
    <url>%2Fpost%2F4177.html</url>
    <content type="text"><![CDATA[ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。 控制接口1/proc/sys/kernel/randomize_va_space randomize_va_space的属性： randomize_va_space 作用 0 关闭 1 mmap base、stack、vdso page将随机化。这意味着.so文件将被加载到随机地址。链接时指定了-pie选项的可执行程序，其代码段加载地址将被随机化。randomize_va_space缺省为1。此时heap没有随机化 2 在1的基础上增加了heap随机化。配置内核时如果禁用CONFIG_COMPAT_BRK，randomize_va_space缺省为2。 操作查看1cat /proc/sys/kernel/randomize_va_space 1sysctl -n kernel.randomize_va_space 设置（关闭）1echo 0 &gt; /proc/sys/kernel/randomize_va_space 1sysctl -w kernel.randomize_va_space=0]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>ASLR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程迁移]]></title>
    <url>%2Fpost%2F62989.html</url>
    <content type="text"><![CDATA[进程迁移就是将一个进程从当前位置移动到指定的处理器上。它的基本思想是在进程执行过程中移动它，使得它在另一个计算机上继续存取它的所有资源并继续运行，而且不必知道运行进程或任何与其它相互作用的进程的知识就可以启动进程迁移操作，这意味着迁移是透明的。 进程迁移是支持负载平衡和高容错性的一种非常有效的手段。 动态负载平衡：将进程迁移到负载轻或空闲的节点上，充分利用可用资源，通过减少节点间负载的差异来全面提高性能。 容错性和高可用性：某节点出现故障时，通过将进程迁移到其它节点继续恢复运行，这将极大的提高系统的可靠性和可用性。在某些关键性应用中，这一点尤为重要。 并行文件IO：将进程迁移到文件服务器上进行IO，而不是通过传统的从文件服务器通过网络将数据传输给进程。对于那些需向文件服务器请求大量数据的进程，这将有效的减少了通讯量，极大的提高效率。 充分利用特殊资源：进程可以通过迁移来利用某节点上独特的硬件或软件能力。 内存导引（Memory Ushering）机制：当一个节点耗尽它的主存时，Memory Ushering机制将允许进程迁移到其它拥有空闲内存的节点，而不是让该节点频繁地进行分页或和外存进行交换。这种方式适合于负载较为均衡，但内存使用存在差异或内存物理配置存在差异的系统。 Task migration(LTP) ltp-full-20140115/testcases/kernel/controllers/cpuctl/cpuctl_test02.c 通过cgroup将两个cgroup同两个物理核进行绑定，然后在两个cgroup中的tasks中进行两个进程ID的移动，从而进行进程的迁移 123456789101112131415mount -t cgroup -o cpuset cgroup /mntcd /mnt#创建子cgroup，cpu0, cpu1mkdir cpu0 cpu1#将CPU0绑定到子cgroup.cpu0cd cpu0echo 0 &gt; cpuset.cpus#将CPU1绑定到子cgroup.cpu1cd cpu1echo 1 &gt; cpuset.cpus#进程迁移echo PID0 &gt; /mnt/cpu0/tasks或echo PID1 &gt; /mnt/cpu1/tasks Cgroup参考 Linux Cgroup系列（01）：Cgroup概述]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[double free or corruption (fasttop)]]></title>
    <url>%2Fpost%2F27831.html</url>
    <content type="text"><![CDATA[1*** Error in `./rixitest-static-ok&apos;: double free or corruption (fasttop): 0x76e006f0 ***` 在进行多线程编程的时候，可能出现double free 问题。主要是在多线程函数中有个对new出来的变量进行操作，但是未加锁同步导致的。只要在在对new变量进行读写操作之前，加个锁，就可以避免该问题的产生。 0x76e006f0 : 多次free的变量地址，变量（或对象）通过new得到的，地址空间在堆里。 在多线程测试中，由于其中一个线程因为异常而exit(-1)退出时，另外的线程也可能因为异常对象的生命周期结束而执行析构函数去delete同一个变量。 exit and _exit 用于终止一个程序 12void exit(int status);void _exit(int status); _exit直接进入内核，exit则先执行一些清除处理（在进程退出之前要检查文件状态，将文件缓冲区中的内容写回文件）再进入内核 调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流（stdin,stdout,stderr…）.exit函数是在_exit函数之上增加了一个封装，写回文件缓存区中的内容 析构函数何时被调用析构函数在下边3种情况时被调用： 对象生命周期结束，被销毁时； delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时； 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。 固定程序的加载地址关闭ASLR，每次执行时，进程的加载地址将被固定。 1echo 0 &gt; /proc/sys/kernel/randomize_va_space ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。 信号处理1234567891011121314151617void Exception::InstallException()&#123; memset(&amp;mCurrentAction,0,sizeof(struct sigaction)); mCurrentAction.sa_handler = Exception::segv_handler; mCurrentAction.sa_flags = SA_RESTART | SA_SIGINFO; sigemptyset(&amp;mCurrentAction.sa_mask); sigaction (SIGSEGV, &amp;mCurrentAction, NULL);&#125;void Exception::unInstallException()&#123; sigaction (SIGSEGV, &amp;mOldAction, NULL);&#125;void Exception::segv_handler(int sig)&#123; ... exit(-1); //Error ...&#125; 在自定义捕获异常信号时，对异常的处理中不能使用exit()来结束进程。 原因： 在异常处理中，系统已经陷入内核态进行do_singal的操作，而测试的异常处理函数中存在exit()，执行exit并等待其完成需要等异常信号的完成，而测试正在进行异常信号的处理，因此将造成死锁现象。 异常处理的多次重入，如果在执行exit时，产生新的相同的异常信号，但是此时由于系统的性能下降（存在多个进程执行，压力测试），使其exit的执行需要一定的CPU周期后才可以完成，这时将进行可能在一次进入异常处理，并再一次执行exit，可能将对相同的资源进行再一次的释放，从而造成double free的错误 疑问？？？ 如果在信号处理中调用exit可以造成死锁，为啥不是必现？ 两次重入可能对资源造成二次释放的现象，为啥每次释放的地址相同？ 进程号123456struct task_struct &#123; ... pid_t pid; pid_t tgid; ...&#125; 用户空间获取pid和tgid, 分别是syscall(SYS_gettid)和getpid 在linux系统中，我们用pid区分每一个进程，linux给每一个进程和轻量级进程都分配一个pid，但是linux程序员希望由一个进程产生的轻量级进程具有相同的pid，这样当我们向进程发送信号时，此信号可以影响进程及进程产生的轻量级进程。为了做到这一点，linux用了线程组（可以理解为轻量级进程组）的概念，在线程组内，每个线程都使用此线程组内第一个线程(thread group leader)的pid，并将此值存入tgid pid和tgid的关系 The four threads will have the same PID but only when viewed from above. What you (as a user) call a PID is not what the kernel (looking from below) calls a PID. In the kernel, each thread has it’s own ID, called a PID (although it would possibly make more sense to call this a TID, or thread ID) and they also have a TGID (thread group ID) which is the PID of the thread that started the whole process. Simplistically, when a new process is created, it appears as a thread where both the PID and TGID are the same (new) number. When a thread starts another thread, that started thread gets its own PID (so the scheduler can schedule it independently) but it inherits the TGID from the original thread. That way, the kernel can happily schedule threads independent of what process they belong to, while processes (thread group IDs) are reported to you. 123456789101112131415 USER VIEW &lt;-- PID 43 --&gt; &lt;----------------- PID 42 -----------------&gt; +---------+ | process | _| pid=42 |_ _/ | tgid=42 | \_ (new thread) _ _ (fork) _/ +---------+ \ / +---------++---------+ | process || process | | pid=44 || pid=43 | | tgid=42 || tgid=43 | +---------++---------+ &lt;-- PID 43 --&gt; &lt;--------- PID 42 --------&gt; &lt;--- PID 44 ---&gt; KERNEL VIEW 信号handle的重入1234567891011121314151617void Exception::InstallException()&#123; memset(&amp;mCurrentAction,0,sizeof(struct sigaction)); mCurrentAction.sa_handler = Exception::segv_handler; mCurrentAction.sa_flags = SA_RESTART | SA_SIGINFO; sigemptyset(&amp;mCurrentAction.sa_mask); sigaction (SIGSEGV, &amp;mCurrentAction, NULL);&#125;void Exception::unInstallException()&#123; sigaction (SIGSEGV, &amp;mOldAction, NULL);&#125;void Exception::segv_handler(int sig)&#123; ... Exception::unInstallException();&#125; 将异常信号的handle应用程序自定义接受后，由于异常信号的不断产生将不断的进入handle，连续多次的进入会对程序造成什么影响？？? 如果进入异常处理后，最后又交给内核处理，结果会咋样？？？ 信号的处理handler，必须是可重入的 可重入函数 _exit() SIG_DFL and SIG_IGN123456typedef void __signalfn_t(int);typedef __signalfn_t __user *__sighandler_t;#define SIG_DFL ((__force __sighandler_t)0) /* default signal handling */#define SIG_IGN ((__force __sighandler_t)1) /* ignore signal */#define SIG_ERR ((__force __sighandler_t)-1) /* error return from signal */ file: include/uapi/asm-generic/signal-defs.h signal函数中的信号处理函数handler，可以是用户指定的一个信号处理函数，也可以是内核特定的函数指针SIG_IGN或SIG_DFL。若信号句柄是SIG_IGN或SIG_DFL，则分别表示对捕获的信号采取忽略操作或者默认操作。 example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;using namespace std;class Test&#123; public: Test(int i) &#123; m_i = i; printf("%s: construct %d\n", __func__, m_i); &#125;; ~Test() &#123; printf("%s: destruct %d\n", __func__, m_i); &#125;; private: int m_i;&#125;;Test t_1(1);void *threadFunc(void *arg)&#123; Test t_3(3);/* exit(1);*/ return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t thread; int err; Test t_2(2); err = pthread_create(&amp;thread, NULL, threadFunc, NULL); if (err != 0) printf("pthread_create fail!!!\n"); pthread_join(thread,NULL); printf("Hello World\n"); return 0;/* exit (0);*//* _exit(0);*/&#125; main(return), threadFunc(return)1234567Test: construct 1Test: construct 2Test: construct 3~Test: destruct 3Hello World~Test: destruct 2~Test: destruct 1 main(return)，threadFunc(exit)1234Test: construct 1Test: construct 2Test: construct 3~Test: destruct 1 main(exit)，threadFunc(return)123456Test: construct 1Test: construct 2Test: construct 3~Test: destruct 3Hello World~Test: destruct 1 main(_exit)，threadFunc(return)12345Test: construct 1Test: construct 2Test: construct 3~Test: destruct 3Hello World 参考 The Linux Process Principle，NameSpace, PID、TID、PGID、PPID、SID、TID、TTY task_struct解析(三) 进程id #define SIG_DFL ((void(*)(int))0) 深入理解可重入与线程安全 【C/C++】对于可重入、线程安全、异步信号安全几个概念的理解]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpu_cache_init与rixi]]></title>
    <url>%2Fpost%2F30991.html</url>
    <content type="text"><![CDATA[cpu_cache_init接口： 初始化cache（r4k_cache_init） 设置cache的保护权限（setup_protection_map） 123kernel_start \-&gt;setup_arch \-&gt;cpu_cache_init() file: arch/mips/mm/cache.c r4k_cache_initsetup_protection_map12345678910111213141516171819202122232425262728293031323334353637383940static inline void setup_protection_map(void) &#123; if (cpu_has_rixi) &#123; protection_map[0] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ); protection_map[1] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC); protection_map[2] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ); protection_map[3] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC); protection_map[4] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ); protection_map[5] = __pgprot(_page_cachable_default | _PAGE_PRESENT); protection_map[6] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ); protection_map[7] = __pgprot(_page_cachable_default | _PAGE_PRESENT); protection_map[8] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ); protection_map[9] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC); protection_map[10] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_WRITE | _PAGE_NO_READ); protection_map[11] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_WRITE); protection_map[12] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ); protection_map[13] = __pgprot(_page_cachable_default | _PAGE_PRESENT); protection_map[14] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_WRITE | _PAGE_NO_READ); protection_map[15] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_WRITE); &#125; else &#123; protection_map[0] = PAGE_NONE; protection_map[1] = PAGE_READONLY; protection_map[2] = PAGE_COPY; protection_map[3] = PAGE_COPY; protection_map[4] = PAGE_READONLY; protection_map[5] = PAGE_READONLY; protection_map[6] = PAGE_COPY; protection_map[7] = PAGE_COPY; protection_map[8] = PAGE_NONE; protection_map[9] = PAGE_READONLY; protection_map[10] = PAGE_SHARED; protection_map[11] = PAGE_SHARED; protection_map[12] = PAGE_READONLY; protection_map[13] = PAGE_READONLY; protection_map[14] = PAGE_SHARED; protection_map[15] = PAGE_SHARED; &#125; &#125; setup_protection_map函数主要是对protection_map结构体数组的初始化cpu_has_rixi: 需要CPU中rixi的硬件支持 12345678910111213141516171819/* description of effects of mapping type and prot in current implementation. * this is due to the limited x86 page protection hardware. The expected * behavior is in parens: * * map_type prot * PROT_NONE PROT_READ PROT_WRITE PROT_EXEC * MAP_SHARED r: (no) no r: (yes) yes r: (no) yes r: (no) yes * w: (no) no w: (no) no w: (yes) yes w: (no) no * x: (no) no x: (no) yes x: (no) yes x: (yes) yes * * MAP_PRIVATE r: (no) no r: (yes) yes r: (no) yes r: (no) yes * w: (no) no w: (no) no w: (copy) copy w: (no) no * x: (no) no x: (no) yes x: (no) yes x: (yes) yes * */ pgprot_t protection_map[16] = &#123; __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 &#125;; file: mm/mmap.c protection_map定义16种内存访问权限，其中映射类型MAP_PRIVATE和MAP_SHARED __P000 的意思是 P ( private)，0 ( No Exec)，0 ( No Write)，0 ( No Read)； __P001 的意思是 P ( private)，0 ( No Exec)，0 ( No Write)，0 ( Read)； __S111 的意思是 S ( Shared)，1 (Exec)，1 ( Write)，1 ( Read)； rixi1#define cpu_has_rixi 1 arch/mips/xburst2/soc-x2000/include/cpu-feature-overrides.h 使能该功能 1__pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ); 相应宏定义：1234567891011121314151617181920212223#if defined(CONFIG_JZRISC_PEP) &amp;&amp; defined(CONFIG_CPU_MIPS32) #define _PAGE_PRESENT_SHIFT 0 #define _PAGE_PRESENT (1 &lt;&lt; _PAGE_PRESENT_SHIFT) #define _PAGE_READ_SHIFT 1 #define _PAGE_READ (1 &lt;&lt; _PAGE_READ_SHIFT) #define _PAGE_WRITE_SHIFT 2 #define _PAGE_WRITE (1 &lt;&lt; _PAGE_WRITE_SHIFT) #define _PAGE_ACCESSED_SHIFT 3 #define _PAGE_ACCESSED (1 &lt;&lt; _PAGE_ACCESSED_SHIFT) #define _PAGE_MODIFIED_SHIFT 4 #define _PAGE_MODIFIED (1 &lt;&lt; _PAGE_MODIFIED_SHIFT) #define _PAGE_FILE (1 &lt;&lt; 4) #define _PAGE_NO_EXEC (1 &lt;&lt; 5) #define _PAGE_GLOBAL (1 &lt;&lt; 6) #define _PAGE_VALID_SHIFT 7 #define _PAGE_VALID (1 &lt;&lt; _PAGE_VALID_SHIFT) #define _PAGE_SILENT_READ (1 &lt;&lt; 7) #define _PAGE_DIRTY_SHIFT 8 #define _PAGE_DIRTY (1 &lt;&lt; _PAGE_DIRTY_SHIFT) #define _PAGE_SILENT_WRITE (1 &lt;&lt; 8) #define _CACHE_SHIFT (9) #define _CACHE_MASK (7 &lt;&lt; _CACHE_SHIFT) #define _PFN_SHIFT (PAGE_SHIFT - 12 + _CACHE_SHIFT + 3) file: arch/mips/include/asm/pgtable-bits.h _page_cachable_default 定义MMU的类型 1234567static void __cpuinit coherency_setup(void) &#123; if (mips_cca &lt; 0 || mips_cca &gt; 7) mips_cca = read_c0_config() &amp; CONF_CM_CMASK; _page_cachable_default = mips_cca &lt;&lt; _CACHE_SHIFT; ...&#125; file: arch/mips/mm/c-r4k.c c0_config: Config寄存器主要描述CPU资源信息和配置，CONF_CM_CMASK(#define CONF_CM_CMASK 7)Config[7:9]为MT，表示MMU的类型 Config[7:9]: MT MMU类型 0: None； 1: MIPS32/64标准的TLB； 2：BAT类型； 3： MIPS32标准的FMT固定映射 cpu_has_rixi = 1 和 cpu_has_rixi = 0 区别 cpu_has_rixi = 1 1protection_map[0] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ); cpu_has_rixi = 0 1234#define _CACHE_CACHABLE_NONCOHERENT (3&lt;&lt;_CACHE_SHIFT) /* R4[0246]00 */#define PAGE_NONE __pgprot(_PAGE_PRESENT | _CACHE_CACHABLE_NONCOHERENT)protection_map[0] = PAGE_NONE; 通过对protection_map[0]定义的对比，在使能rixi后，其属性增加了 _PAGE_NO_EXEC和_PAGE_NO_READ也就是rixi在内存的访问权限上增加了_PAGE_WRITE, _PAGE_READ,_PAGE_NO_READ, _PAGE_NO_EXEC的属性控制 参考 内核初始化]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMP多核启动]]></title>
    <url>%2Fpost%2F49009.html</url>
    <content type="text"><![CDATA[smp的多核启动： MIPS框架下的启动流程 数据结构1234567891011121314struct plat_smp_ops &#123; void (*send_ipi_single)(int cpu, unsigned int action); void (*send_ipi_mask)(const struct cpumask *mask, unsigned int action); void (*init_secondary)(void); void (*smp_finish)(void); void (*cpus_done)(void); void (*boot_secondary)(int cpu, struct task_struct *idle); void (*smp_setup)(void); void (*prepare_cpus)(unsigned int max_cpus);#ifdef CONFIG_HOTPLUG_CPU int (*cpu_disable)(void); void (*cpu_die)(unsigned int cpu);#endif&#125;; smp init 123456smp_prepare_cpus --&gt; (.prepare_cpus) |1. 初始化mailbox并申请mailbox中断2. 制造每个核启动时的初始化代码3. 将初始化代码写入reset entry4. 刷cache 将CCU中的相应CPU进行reset后， 相应的CPU PC将跳入reset entry执行代码 init_secondary在boot_secondary中，将per CPU进行reset后，系统所有CPU依次启动 系统启动系统上电后，boot CPU启动，执行start_kernel（init/main.c），并分别调用boot_cpu_init和setup_arch两个接口，进行possible CPU相关的初始化。 12345678910111213/* * Activate the first processor. */static void __init boot_cpu_init(void)&#123; int cpu = smp_processor_id(); /* Mark the boot cpu "present", "online" etc for SMP and UP case */ set_cpu_online(cpu, true); set_cpu_active(cpu, true); set_cpu_present(cpu, true); set_cpu_possible(cpu, true);&#125; set_cpu_xxx接口，可以将指定的CPU设置为（或者清除）指定的状态。 123456789101112131415161718192021222324252627282930313233343536373839/* * The following particular system cpumasks and operations manage * possible, present, active and online cpus. * * cpu_possible_mask- has bit &apos;cpu&apos; set iff cpu is populatable * cpu_present_mask - has bit &apos;cpu&apos; set iff cpu is populated * cpu_online_mask - has bit &apos;cpu&apos; set iff cpu available to scheduler * cpu_active_mask - has bit &apos;cpu&apos; set iff cpu available to migration * * If !CONFIG_HOTPLUG_CPU, present == possible, and active == online. * * The cpu_possible_mask is fixed at boot time, as the set of CPU id&apos;s * that it is possible might ever be plugged in at anytime during the * life of that system boot. The cpu_present_mask is dynamic(*), * representing which CPUs are currently plugged in. And * cpu_online_mask is the dynamic subset of cpu_present_mask, * indicating those CPUs available for scheduling. * * If HOTPLUG is enabled, then cpu_possible_mask is forced to have * all NR_CPUS bits set, otherwise it is just the set of CPUs that * ACPI reports present at boot. * * If HOTPLUG is enabled, then cpu_present_mask varies dynamically, * depending on what ACPI reports as currently plugged in, otherwise * cpu_present_mask is just a copy of cpu_possible_mask. * * (*) Well, cpu_present_mask is dynamic in the hotplug case. If not * hotplug, it&apos;s a copy of cpu_possible_mask, hence fixed at boot. * * Subtleties: * 1) UP arch&apos;s (NR_CPUS == 1, CONFIG_SMP not defined) hardcode * assumption that their single CPU is online. The UP * cpu_&#123;online,possible,present&#125;_masks are placebos. Changing them * will have no useful affect on the following num_*_cpus() * and cpu_*() macros in the UP case. This ugliness is a UP * optimization - don&apos;t waste any instructions or memory references * asking if you&apos;re online or how many CPUs there are if there is * only one CPU. */ 状态 作用 online 可以被调度的 active 可以被迁移的 present 内核已接管的 possible 系统存在的CPU，但没有被内核接管 123456789101112131415161718192021222324252627void __init setup_arch(char **cmdline_p)&#123;#ifdef CONFIG_EARLY_PRINTK setup_early_printk();#endif cpu_probe(); prom_init(); cpu_report(); check_bugs_early();#if defined(CONFIG_VT)#if defined(CONFIG_VGA_CONSOLE) conswitchp = &amp;vga_con;#elif defined(CONFIG_DUMMY_CONSOLE) conswitchp = &amp;dummy_con;#endif#endif arch_mem_init(cmdline_p); resource_init(); plat_smp_setup(); cpu_cache_init();&#125; file: arch/mips/kernel/setup.c 12345678void __init prom_init(void)&#123; prom_init_cmdline((int)fw_arg0, (char **)fw_arg1); mips_machtype = MACH_XBURST;#ifdef CONFIG_SMP register_smp_ops(&amp;xburst2_smp_ops);#endif&#125; file: arch/mips/xburst2/core/prom.c 将struct plat_smp_ops结构体注册SMP框架 1234567/* preload SMP state for boot cpu */void smp_prepare_boot_cpu(void)&#123; set_cpu_possible(0, true); set_cpu_online(0, true); cpu_set(0, cpu_callin_map);&#125; file: arch/mips/kernel/smp.c 开关核12echo 0 &gt; /sys/devices/system/cpu/cpu1/online //关echo 1 &gt; /sys/devices/system/cpu/cpu1/online //开 123456789101112131415161718192021222324static ssize_t __ref store_online(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)&#123; ... cpu_hotplug_driver_lock(); switch (buf[0]) &#123; case '0': ret = cpu_down(cpuid); ... break; case '1': from_nid = cpu_to_node(cpuid); ret = cpu_up(cpuid); ... break; default: ret = -EINVAL; &#125; cpu_hotplug_driver_unlock(); ...&#125;static DEVICE_ATTR(online, 0644, show_online, store_online); file: drivers/base/cpu.c echo 0 &gt; online实现接口： 1234567891011121314151617#ifdef CONFIG_HOTPLUG_CPUstatic inline int __cpu_disable(void)&#123; extern struct plat_smp_ops *mp_ops; /* private */ return mp_ops-&gt;cpu_disable();&#125;static inline void __cpu_die(unsigned int cpu)&#123; extern struct plat_smp_ops *mp_ops; /* private */ mp_ops-&gt;cpu_die(cpu);&#125;extern void play_dead(void);#endif file: arch/mips/include/asm/smp.h 调用关系： 123456cpu_down \-&gt;_cpu_down(cpu, 0) \-&gt;take_cpu_down \-&gt;__cpu_disable() \-&gt;mp_ops-&gt;cpu_disable() \-&gt;__cpu_die(cpu) file: /kernel/cpu.c 将被关闭的CPU的中断迁移走后，使其处理完成最后的（飞行状态）任务，进入idle模式，在idle模式判断自己是否需要关闭，如果需要将执行到play_dead将自己杀掉（关闭中断）。 12345678910static void cpu_idle_loop(void)&#123; while (1) &#123; ... if (cpu_is_offline(smp_processor_id())) arch_cpu_idle_dead(); ... &#125;&#125; file: kernel/cpu/idle.c 12345678#ifdef CONFIG_HOTPLUG_CPUvoid arch_cpu_idle_dead(void)&#123; /* What the heck is this check doing ? */ if (!cpu_isset(smp_processor_id(), cpu_callin_map)) play_dead();&#125;#endif file: arch/mips/kernel/process.c echo 1 &gt; online调用被开核的boot_secondary,重新走一次启动时的第二阶段。 1234cpu_up \-&gt;_cpu_up \-&gt;__cpu_up \-&gt;mp_ops-&gt;boot_secondary(cpu, tidle) file: /kernel/cpu.c 参考 clement-smp-bring-up-on-arm-soc.pdf]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>SMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC]]></title>
    <url>%2Fpost%2F54464.html</url>
    <content type="text"><![CDATA[GCC的使用和相关特性。 内置函数1__builtin_xxx(x) GCC includes built-in versions of many of the functions in the standard C library. The versions prefixed with __builtin_ will always be treated as having the same meaning as the C library function even if you specify the -fno-builtin option. gcc内置函数 函数 作用 builtin_clear_cache 刷新指令Cache (iCache), MIPS使用synci指令]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket Buffer]]></title>
    <url>%2Fpost%2F21941.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存屏障]]></title>
    <url>%2Fpost%2F15089.html</url>
    <content type="text"><![CDATA[Memory barrier能够让CPU或编译器在内存访问上有序。一个Memory barrier之前的内存访问操作必定先于其之后的完成。 程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能. Linux kernel doc: memory-barriers 内存乱序访问主要发生在两个阶段： 编译时，编译器优化导致内存乱序访问（指令重排） 运行时，多CPU间交互引起内存乱序访问 12345678#define wmb() fast_wmb() #define rmb() fast_rmb() #define mb() fast_mb() #define iob() fast_iob() # define smp_mb() __asm__ __volatile__("sync" : : :"memory") # define smp_rmb() __asm__ __volatile__("sync" : : :"memory") # define smp_wmb() __asm__ __volatile__("sync" : : :"memory") [MIPS] file: arch/mips/include/asm/barrier.h smp_mb作用对象：CPU与CPU mb作用对象：CPU与IO 参考 理解 Memory barrier（内存屏障）]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>mem</tag>
        <tag>barrier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jiffies && HZ]]></title>
    <url>%2Fpost%2F33522.html</url>
    <content type="text"><![CDATA[jiffies全局变量jiffies用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的(jiffies是记录着从电脑开机到现在总共的时钟中断次数),一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就是Hz。系统运行时间以秒为单位，等于ijiffies/Hz。 注意: jiffies类型为无符号长整型(unsigned long)，其他任何类型存放它都不正确。 将以秒为单位的时间转化为jiffies： seconds * Hz (jiffies) 将jiffies转化为以秒为单位的时间： jiffies / Hz (s) HZLINUX系统时钟频率是一个常数HZ来决定的， 通常HZ＝100，那么他的精度度就是10ms（毫秒）。也就是说每10ms一次中断。 接口时间比较12345time_after(a,b)time_before(a,b)time_after_eq(a,b)time_before_eq(a,b)time_in_range(a,b,c) 时间转换jiffies和msecs以及usecs的转换：1234unsigned int jiffies_to_msecs(const unsigned long);unsigned int jiffies_to_usecs(const unsigned long);unsigned long msecs_to_jiffies(const unsigned int m);unsigned long usecs_to_jiffies(const unsigned int u); 实例 watchdog_timeo = 2 * HZ; 将2s转换为jiffies, 设定2s延时。 mod_timer(&amp;host-&gt;timer, jiffies + 10 * HZ); 设定10s的定时时间。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTP测试]]></title>
    <url>%2Fpost%2F39613.html</url>
    <content type="text"><![CDATA[LTP套件是由 Linux Test Project 所开发的一套系统测试套件。它基于系统资源的利用率统计开发了一个测试的组合,为系统提供足够的压力。 通过压力测试来判断系统的稳定性和可靠性。 压力测试是一种破坏性的测试,即系统在非正常的、超负荷的条件下的运行情况 。用来评估在超越最大负载的情况下系统将如何运行,是系统在正常的情况下对某种负载强度的承受能力的考验 LTP测试套件对Linux操作系统进行超长时间的测试,重点在于Linux用户环境相关的工作负荷。而并不是致力于证明缺陷。 LTP测试测试分为两个阶段：初始测试，压力测试 初始测试 是开始测试的必要条件。初始测试包括LTP测试套件在硬件和操作系统上成功运转,这些硬件和操作系统将用于可靠性运转 测试脚本： 1runalltests.sh(或runltp) runltp默认执行的内容与runalltests相同 1cd usr; ./runltp 详细使用见：LTP使用说明 测试单元1cd /usr; ./runltp -f crashme crashme对系统的极端测试 测试项 说明 f00f x86测试 crash01 生成随机指令进行执行， 申请一块空间写随机值后，将PC跳转至此进行执行，并判断执行结果, 由于指令随机生成可能导致相同卡死，就看相同是否足够强壮，（同时也可能存成内存的泄露） crash02 随机进行系统调用（0～127）， 并且系统调用的所有参数全是随机值， 由于随机的系统调用可以进行内存分配，而不会释放，也可能存在内存泄露 mem01 根据系统中可以内存的大小，随机或线性申请内存，别填充释放 fork12 尽可能的fork子进程，目的是耗尽系统的pid号，主要冲突是pid_max和内存容量 mmmax_map_count12# cat /proc/sys/vm/max_map_count65530 限制一个进程所拥有的最大内存区域(64MB) min_free_kbytes12# cat /proc/sys/vm/min_free_kbytes1961 表示系统所保留空闲内存的最低限 压力测试 验证产品在系统高使用率时的健壮性。 参考 LTP–linux稳定性测试,性能测试和压力测试 测试 Linux 的可靠性 Building a Robust Linux kernel piggybacking The Linux Test Project [kernel]—-理解kswapd的低水位min_free_kbytes]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>LTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux应用调试方法---Debug]]></title>
    <url>%2Fpost%2F43503.html</url>
    <content type="text"><![CDATA[常用的Linux应用调试方法： strace用法：1strace ./a.out gdbcore dump 查看core设置1ulimit -a 12345678910111213141516core file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 30956max locked memory (kbytes, -l) 16384max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 30956virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 开启core file1ulimit -c unlimited 示例 ubuntu18.04 64bit 异常程序(段错误) 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; int *a; *a = 1; while(1) &#123; &#125; return EXIT_SUCCESS;&#125; 1gcc -g test.c 运行异常程序后,生成core文件 使用gdb查看异常位置 1gdb ./a.out core 12345678910111213141516171819202122GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-gitCopyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from ./a.out...done.warning: exec file is newer than core file.[New LWP 20661]Core was generated by `./a.out&apos;.Program terminated with signal SIGSEGV, Segmentation fault.#0 0x0000563a00047609 in main (argc=1, argv=0x7ffe99b73178) at tst.c:88 *a = 1; ARM平台 本地编译支持arm平台的gdb 123456789101112131415161718192021#!/bin/bashPWD=`pwd`mkdir tmpcd tmpif [ ! -f gdb-8.2.tar.gz ]; then wget http://101.110.118.57/ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gzfirm gdb-8.2 -rftar zxvf gdb-8.2.tar.gzcd gdb-8.2./configure --target=arm-linux --prefix=$PWD/_install --enable-staticmake -j2make installcd .. #gdb-8.2cd .. #tmp gdb调试命令]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核调试方法---Debug]]></title>
    <url>%2Fpost%2F53462.html</url>
    <content type="text"><![CDATA[常用的Linux调试方法： 工具 描述 debugfs文件系统 提供了 procfs, sysfs, debugfs以及 relayfs 来与用户空间进行数据交互, 尤其是 debugfs, 这是内核开发者们实现的专门用来调试的文件系统接口. 其他的工具或者接口, 多数都依赖于 debugfs printk 强大的输出系统, 没有什么逻辑上的bug是用PRINT解决不了的 ftrace以及其前端工具trace-cmd等 内核提供了 ftrace 工具来实现检查点, 事件等的检测, 这一框架依赖于 debugfs, 他在 debugfs 中的 tracing 子系统中为用户提供了丰富的操作接口, 我们可以通过该系统对内核实现检测和分析. 功能虽然强大, 但是其操作并不是很简单, 因此使用者们为实现了 trace-cmd 等前端工具, 简化了 ftrace 的使用. objdump用法：1objdump -D a.out &gt; a.dump 常用参数： -d:将代码段反汇编 -D:表示对全部文件进行反汇编 -S:将代码段反汇编的同时，将反汇编代码和源代码交替显示，编译时需要给出-g，即需要调试信息。 -C:将C++符号名逆向解析。 -l:反汇编代码中插入源代码的文件名和行号。 -j section:仅反汇编指定的section。可以有多个-j参数来选择多个section。 $mips-linux-gnu-objdump -d vmlinux &gt; a.s addr2line一个可以将指令的地址和可执行映像转换成文件名、函数名和源代码行数的工具 12=====&gt;$mips-linux-gnu-addr2line -e out/target/product/xxxxx/symbols/system/lib/libdvm.so 23452/work/android-4.3-fpga/dalvik/vm/mterp/out/InterpAsm-mips.S:1335 23452 –&gt; 异常PC mips-linux-gnu-addr2line -e vmlinux 0x802354c0 汇编定位 在函数中添加空指令，确认该代码段反汇编后的具体位置. 12345678asm __volatile__(&quot;ssnop\n\t&quot;);asm __volatile__(&quot;ssnop\n\t&quot;);for (i = 0; i &lt;= MAXJSAMPLE; i++) table[i] = (JSAMPLE) i;asm __volatile__(&quot;ssnop\n\t&quot;);asm __volatile__(&quot;ssnop\n\t&quot;); ftraceftrace 是内建于 Linux 内核的跟踪工具，从 2.6.27 开始加入主流内核。使用 ftrace 可以调试或者分析内核中发生的事情。ftrace 提供了不同的跟踪器，以用于不同的场合，比如跟踪内核函数调用、对上下文切换进行跟踪、查看中断被关闭的时长、跟踪内核态中的延迟以及性能问题等 Documentation/trace/ftrace.txt kernel配置123456789101112131415161718192021222324Symbol: FTRACE [=y]Type : booleanPrompt: Tracers Location: -&gt; Kernel hacking Defined at kernel/trace/Kconfig:135 Depends on: TRACING_SUPPORT [=y]--- Tracers-*- Kernel Function Tracer[*] Kernel Function Graph Tracer[*] Interrupts-off Latency Tracer[*] Preemption-off Latency Tracer[*] Scheduling Latency Tracer-*- Create a snapshot trace buffer-*- Allow snapshot to swap per CPUBranch Profiling (No branch profiling) ---&gt;[*] Trace max stack[*] Support for tracing block IO actions[*] enable/disable function tracing dynamically[ ] Kernel function profiler[ ] Perform a startup test on ftrace&lt; &gt; Ring buffer benchmark stress tester[ ] Ring buffer startup self test Use1# mount -t debugfs none /mnt/ 1234567891011121314151617181920# cd /mnt/tracing/# lsREADME set_eventavailable_events set_ftrace_filteravailable_filter_functions set_ftrace_notraceavailable_tracers set_ftrace_pidbuffer_size_kb set_graph_functionbuffer_total_size_kb snapshotcurrent_tracer stack_max_sizedyn_ftrace_total_info stack_traceenabled_functions stack_trace_filterevents tracefree_buffer trace_clockinstances trace_markermax_graph_depth trace_optionsoptions trace_pipeper_cpu tracing_cpumaskprintk_formats tracing_max_latencysaved_cmdlines tracing_onsaved_tgids tracing_thresh available_tracers记录了当前编译进内核的跟踪器的列表 available_tracers - list of configured tracers for current_tracer 12# cat available_tracersblk function_graph wakeup_rt wakeup preemptirqsoff preemptoff irqsoff function nop current_tracer用于设置或显示当前使用的跟踪器；使用echo将跟踪器名字写入该文件可以切换到不同的跟踪器。系统启动后，其缺省值为nop ，即不做任何跟踪操作。在执行完一段跟踪任务后，可以通过向该文件写入nop来重置跟踪器。 1# echo wakeup &gt; current_tracer trace文件提供了查看获取到的跟踪信息的接口。 通过 cat 等命令查看该文件以查看跟踪到的内核活动记录，也可以将其内容保存为记录文件以备后续查看。 1234567891011121314151617181920212223242526# cat trace# tracer: wakeup## wakeup latency trace v1.1.5 on 3.10.14-00042-ge40985e# --------------------------------------------------------------------# latency: 624 us, #174/174, CPU#0 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:2)# -----------------# | task: ksdioirqd/mmc1-155 (uid:0 nice:0 policy:1 rt_prio:1)# -----------------## _------=&gt; CPU## / _-----=&gt; irqs-off# | / _----=&gt; need-resched# || / _---=&gt; hardirq/softirq# ||| / _--=&gt; preempt-depth# |||| / delay# cmd pid ||||| time | caller# \ / ||||| \ | /&lt;idle&gt;-0 0dNh4 4us+: 0:120:R + [000] 155: 98:R ksdioirqd/mmc1&lt;idle&gt;-0 0dNh4 12us+: 0&lt;idle&gt;-0 0dNh4 17us+: task_woken_rt &lt;-ttwu_do_wakeup&lt;idle&gt;-0 0dNh4 21us+: _raw_spin_unlock &lt;-try_to_wake_up&lt;idle&gt;-0 0dNh4 24us+: sub_preempt_count &lt;-_raw_spin_unlock&lt;idle&gt;-0 0dNh3 28us+: _raw_spin_unlock_irqrestore &lt;-try_to_wake_up.... 使用 内核中断 12345678910111213141516171819202122232425# echo 0 &gt; tracing_on# echo &gt; trace# echo nop &gt; current_tracer# echo irq &gt; set_event# echo 1 &gt; tracing_on# cat trace_pipe sh-100 [000] d.h3 1333.894909: irq_handler_entry: irq=58 name=uart1 sh-100 [000] d.h3 1333.894931: irq_handler_exit: irq=58 ret=handled &lt;idle&gt;-0 [000] d.h2 1333.902444: irq_handler_entry: irq=34 name=jz-timerirq# cat trace# tracer: nop## entries-in-buffer/entries-written: 5510/5510 #P:1## _-----=&gt; irqs-off# / _----=&gt; need-resched# | / _---=&gt; hardirq/softirq# || / _--=&gt; preempt-depth# ||| / delay# TASK-PID CPU# |||| TIMESTAMP FUNCTION# | | | |||| | | sh-100 [000] d.h3 1342.498892: irq_handler_exit: irq=58 ret=handled &lt;idle&gt;-0 [000] d.h2 1342.673707: irq_handler_entry: irq=34 name=jz-timerirq &lt;idle&gt;-0 [000] d.h2 1342.673717: irq_handler_exit: irq=34 ret=handled 参考 Linux内核调试的方式以及工具集锦]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器和Cache]]></title>
    <url>%2Fpost%2F12702.html</url>
    <content type="text"><![CDATA[在平时的工作中经常进行寄存器和Cache的相关操作，这里主要说明其二者的具体操作和实现的不同 1*(volatile unsigned int*)(0xb3450000 + 0x20) = 0x5a5a5a5a; 写寄存器时经过Cache吗？，为什么？怎么实现的？ 如果经常Cache，是CPU进行同步，还是软件进行同步？ 寄存器 寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。 Cache 即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。 二者联系？]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件系统性能测试--iozone]]></title>
    <url>%2Fpost%2F40023.html</url>
    <content type="text"><![CDATA[iozone 一个文件系统性能评测工具，可以测试Read, write, re-read,re-write, read backwards, read strided, fread, fwrite, random read, pread, mmap, aio_read, aio_write 等不同模式下不同文件系统的读写性能 官网： http://www.iozone.org 参数 参数 说明 -a 全自动模式测试。测试记录块大小从4k到16M，测试文件从64k到512M -A 使用自动模式虽然测试比较全面，但是比较花时间。-a选项将在文件大于32MB时停止使用低于64k一下记录块，来节省时间。-A通知iozone不要节省时间，进行所有测试。注：在3.61版本以后不建议使用，用-az代替-aA -B 使用mmap()。这将使用mmap()接口来创建并访问所有测试用的临时文件。一些应用程序倾向于将文件当作内存的一块来看待。这些应用程序对文件执行mmap()调用，然后就可以以读写内存的方式访问那个块来完成文件I/O。 -c 计算时间将close()包括进来 -C 显示吞吐量测试中每个客户端的字节数。 -D 对mmap文件使用MSYNC(MS_ASYNC)。告诉操作系统在mmap空间的所有数据需要被异步的写到磁盘上。 -e 测试时间是包含flush(fsync, fflush) -f filename 指定用来测试临时文件，在测试完成后将被自动删除 -F filename filename … 指定测试中每个临时文件名，文件名的数量应该和指定的进程或线程数相同 -g # 在自动模式下设置文件最大值，可以使用#k #m #g分别表示kb，mb，gb -G 对mmap文件使用msync(MS_SYNC)。告诉操作系统在mmap空间的所有数据需要被同步的写到磁盘上 -h 显示帮助 -i # 指定运行于哪种模式测试。可以使用-i # -i # -i #进行多个测试 0=write/rewrite 1=read/re-read 2=random read/random write 3=backwards read 4=re-write-record 5=stride-read 6=fwirte/re-fwrite 7=fread/re-fread 8=random mix 9=pwrite/re-pwrite 10=pread/re-pread 11=pwritev/re-pwritev 12=preadv/re-preadv -I 对所有文件操作使用DIRECT I/O。通知文件系统所有操作跳过缓存直接在磁盘上操作 -j # 设置访问文件的跨度为(# * 块)。stride read测试将使用这个跨度来读块 -J #（毫秒） 在每个I/O操作之前产生指定毫秒的计算延迟。看-X和-Y获取控制计算延迟的其他参数 -l # 设置程序最小进程数。在测试过程允许用户设置的最小进程或线程数。需要配合-u选项使用。 -L # 设置处理器交换信息的单位量为#（bytes）。可以加速测试。 -m iozone将在内部使用多个缓存。一些程序反复复写一块缓存，还有就是设置多个缓存块。此参数将允许使用这两种模式。iozone默认行为是重复使用内部一个缓存。此选项将允许在内部使用多个缓存块。 -M 调用uname()，将返回字符串放在输出文件中 -n # 设置自动模式下测试文件的最小值 -N 报告结果以毫秒每操作的方式显示 -o 写方式是同步写到磁盘上 -O 报告结果以操作每秒方式显示 -q # 在自动模式下设置记录块的最大值，可以使用#k(kb)，#m(mb)，#g(gb)。使用-y可以设置最小值 -r # 设置记录块大小为# -R 使用Excel显示结果 -s # 设置测试文件大小 -S # 设置处理器的缓存大小 -t # 设置测试程序的线程或进程数 -T 使用POSIX的pthreads进行测试 -u # 设置最大进程或线程数，需要配合-l参数使用 -U mountpoint 在测试开始之前，iozone将unmount和remount挂载点。这将保证测试中缓存不包含任何文件 -w 在测试结束后不要删除临时文件。临时文件将在测试过后保存下来 -W 在测试过程中，当读或写文件时锁住文件 -y # 设置记录块最小值 -z 同-a一起使用，进行全部测试 -Z 允许mmap I/O和file I/O混合使用 实例1sudo iozone -ac -s 8m -f /home/testfile -y 2k -q 8m 12345678910111213141516171819Time Resolution = 0.000001 seconds.Processor cache size set to 1024 Kbytes.Processor cache line size set to 32 bytes.File stride size set to 17 * record size. random random bkwd record stride KB reclen write rewrite read reread read write read rewrite read fwrite frewrite fread freread 8192 2 189862 415349 1181932 1608842 1018766 374677 1329412 398615 665257 405521 367288 1569381 1528607 8192 4 237746 686099 1981095 2178140 1788563 536369 1336133 765253 1662395 391698 586565 1920739 2217786 8192 8 312623 871304 1620222 1851298 2215927 607182 2392438 979445 1817225 853513 873808 2615731 2264859 8192 16 280834 625953 2536184 2567262 2224823 1134478 2546334 1416090 2339815 938923 890545 2510611 2251797 8192 32 395003 1122984 1941688 1715601 1975400 721755 2480882 1573550 1757908 940543 1122654 2917577 2592443 8192 64 270175 1053372 2642689 2850293 2632364 1407332 2715153 1819245 2919312 1094161 1165811 1840095 1886259 8192 128 275769 1149623 2585809 2727871 2409382 1451995 2636606 1789028 2325877 1041968 1090826 2615731 1923858 8192 256 291167 1144454 2486987 2536184 2369668 1446067 2202151 1263978 2343965 1137144 1136994 2354728 2517417 8192 512 349935 1193800 2327295 2420755 2422804 1362140 1923427 1698135 2658845 1083329 1143007 1855096 1833907 8192 1024 333752 1308403 2522962 2538433 2496020 1461568 2443132 1573550 2954201 901409 1139520 1943115 2304969 8192 2048 276766 1110176 2367709 2430860 2420755 1338162 1757548 1406583 1580571 805492 1024660 2241221 2357313 8192 4096 592891 1179538 2268747 2339337 2063424 1196419 1890618 1383531 1853795 204928 1006737 1808425 1798486 8192 8192 328823 1199761 2394606 2408707 2175244 1265747 2327926 1293333 2159657 1222513 1181607 2380009 2428798 结果： 左边第一列是测试文件大小，第二列是记录块大小（单位是kb），以后每列就是测试模式（单位是kb/s） 测试项 测试项 说明 Write 测试向一个新文件写入的性能。当一个新文件被写入时，不仅仅是那些文件中的数据需要被存储，还包括那些用于定位数据存储在存储介质的具体位置的额外信息。这些额外信息被称作“元数据”。它包括目录信息，所分配的空间和一些与该文件有关但又并非该文件所含数据的其他数据。拜这些额外信息所赐，Write的性能通常会比Re-write的性能低。 Re-write 测试向一个已存在的文件写入的性能。当一个已存在的文件被写入时，所需工作量较少，因为此时元数据已经存在。Re-write的性能通常比Write的性能高。 Read 测试读一个已存在的文件的性能。 Re-Read 测试读一个最近读过的文件的性能。Re-Read性能会高些，因为操作系统通常会缓存最近读过的文件数据。这个缓存可以被用于读以提高性能。 Random Read 测试读一个文件中的随机偏移量的性能。许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。 Random Write 测试写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。 Random Mix 测试读写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。这个测试只有在吞吐量测试模式下才能进行。每个线程/进程运行读或写测试。这种分布式读/写测试是基于round robin 模式的。最好使用多于一个线程/进程执行此测试。 Backwards Read 测试使用倒序读一个文件的性能。这种读文件方法可能看起来很可笑，事实上，有些应用确实这么干。MSC Nastran是一个使用倒序读文件的应用程序的一个例子。它所读的文件都十分大（大小从G级别到T级别）。尽管许多操作系统使用一些特殊实现来优化顺序读文件的速度，很少有操作系统注意到并增强倒序读文件的性能。 Record Rewrite 测试写与覆盖写一个文件中的特定块的性能。这个块可能会发生一些很有趣的事。如果这个块足够小（比CPU数据缓存小），测出来的性能将会非常高。如果比CPU数据缓存大而比TLB小，测出来的是另一个阶段的性能。如果比此二者都大，但比操作系统缓存小，得到的性能又是一个阶段。若大到超过操作系统缓存，又是另一番结果。 Strided Read 测试跳跃读一个文件的性能。举例如下：在0偏移量处读4Kbytes，然后间隔200Kbytes,读4Kbytes，再间隔200Kbytes，如此反复。此时的模式是读4Kbytes，间隔200Kbytes并重复这个模式。这又是一个典型的应用行为，文件中使用了数据结构并且访问这个数据结构的特定区域的应用程序常常这样做。许多操作系统并没注意到这种行为或者针对这种类型的访问做一些优化。同样，这种访问行为也可能导致一些有趣的性能异常。一个例子是在一个数据片化的文件系统里，应用程序的跳跃导致某一个特定的磁盘成为性能瓶颈。 Fwrite 测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I/O功能能通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。这个测试是写一个新文件，所以元数据的写入也是要的。 Frewrite 测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I/O功能能通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。 导出Excel表格1iozone -i 0 -i 1 -s 8m -f /testfile -y 2k -q 8m -Rab /iozone_test.xls 在嵌入式开发板上导出表格数据全为0，无法使用 测试1./iozone -s 100M -ac -S 512k 2&gt;&amp;1 | tee test.log]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件相同， iozone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eMMC中的HPI]]></title>
    <url>%2Fpost%2F14442.html</url>
    <content type="text"><![CDATA[在某些情景下，不同类型的数据对于Host来讲可能会有不同的优先级。比如在写指定的数据的时候，由于写数据会消耗掉很多的时间，当用于想要立即进行另外一个操作的时候，就必须项办法抑制住当前的写操作来实现分页操作的需求。 HPI(High Priority Interrupt)高优先级中断，该机制可以中断一些还没有完成的优先级比较低的操作，来满足对高优先级操作的需求。 HPI命令可以从一下两个命令中的任何一个来发送： 1.CMD12 - 基于STOP_TRANSMISSION命令，当HPI标志位置一的时候生效 2.CMD13 - 基于SEND_STATUS命令，当HPI标志位置一的时候生效 当HPI生效的时候，以上两个命令的参数必须设定为: RCA 填充位 HPI [31:16] [15:1] [0] 填充位不影响参数配置 当在执行WRITE_MULTIPLE_BLOCK命令时(CMD 25)，设备会更新CORRECTLY_PRG_SECTORS_NUM(EXT_CSD[245:242])，这个值会根据目前成功写入的扇区(512B)数量来更新。当HPI生效之后，Host可以根据这个值来重新继续写入数据而不必从头开始写。 如果HPI中断了在Packed write command中的CMD25，CORRECTLY_PRG_SECTORS_NUM返回的是所有写命令积累起来的当前成功写入扇区的总数量，Host应当通过这个值计算出具体的中断的命令和扇区偏移地址。 在使用HPI功能之前，要先把在EXT_CSD里面[161]字节的HPI_MGMT，把HPI_EN置1 参考 eMMC当中HPI的作用以及使用方法]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内核常见问题]]></title>
    <url>%2Fpost%2F57226.html</url>
    <content type="text"><![CDATA[常见错误的总结； Unhandled kernel unaligned access思路: 数据被冲掉(也就是其他数据的覆盖) DDR出错(除非新调试的内存,不然机率很小) alignment fault的代码编写方式指针转换：将低位宽类型的指针转换为高位宽类型的指针，如：将char * 转为int *，或将void *转为结构体指针。这类操作是导致alignment fault的最主要的来源，在分析定位问题时，需要特别关注。对于出现异常却又必须这样使用的场景，对这类转换后的指针进行访问时，如果不能确认其对应的地址是对齐的，则应该使用memcpy访问(memcpy方式不存在对齐问题)。另外，建议转换后立即使用，不要将其传递到其他函数和模块，防止扩展，带来潜在的问题。 使用packed属性或者编译选项这样的操作会关闭编译器的自动填充功能，从而使结构体中各个字段紧凑排列，如果排列时未处理好对齐，则可能导致alignment fault。一些场景下(内核中也较常见)确实需要用户自行紧凑排列结构体，可节省空间(在内存资源稀缺的场景下，很有用)，此时需要特别关注对齐问题，建议通过填充的方法尽量对齐，如此可能会导致空间浪费，但是会提升访问性能，典型的“以空间换时间”的思路。如果对空间有强烈要求，而可以接受性能损失，也可以不考虑对齐，不做padding，但在访问这些结构体的数据时，需要全部使用memcpy的方式。 BUG: soft lockup - CPU#0 stuck for 22s!思路: 死锁 死循环 not syncing: softlockup: hung tasks]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMP--对称多处理器]]></title>
    <url>%2Fpost%2F14018.html</url>
    <content type="text"><![CDATA[SMP的结构中，在CPU运行时都是“对称”的，没有主次之分。所有的CPU通过同一条总线共享同一个内存以及外设。为了减少内存访问的冲突，SMP结构中的各干CPU通常都有自己的高速缓存。 程序的运行： 各个CPU动态的从系统的就绪队列中调度进程加以执行，一个进程在不同的时间可以在不同的CPU上运行，中断请求则动态的分配给其中的一个CPU，由这个CPU提供中断服务。除一般的内存共享外，处理器间的通信手段还有进程间通信和处理器间的中断请求。 SMP中的主要问题： 同步 cache一致性 中断 同步 进程间的同步实际是对临界资源的互斥操作 在单处理器结构中，只要能保证在对临界资源的操作中途不发生进程调度，并且不会发生中断，或者即使发生中断也与操作的对象无关，就保证了操作的互斥性。12spin_lockatomic 一般而言，只要能保证对临界资源操作的“原子性”，互斥性就保证了，在单处理器结构中，能够在单条指令完成的操作就认为是“原子操作”。在CPU的设计中为保证原子操作，设计一些原子指令，“测试并设置”， “测试并清除”。 在SMP结构中，对指令间的执行顺序的依赖会存在很大的风险。必须使用锁使其在一个CPU上执行完毕，不能中断，否则可能导致指令顺序错乱。 Cache一致性123456789101112+----+ +----+ +----+ +----+|CPU0| |CPU1| |CPU2| |CPU3|+----+ +----+ +----+ +----+ +-+ +-+ +-+ +-+ | | | |+---v-----v--+ +--v------v--+| L1 Cache | | L2 Cache |+------+-----+ +------+-----+ | |+------v----------------v-----+| L2 Cache |+-----------------------------+ 中断Q&amp;ACache line参考 [Linux内核源代码情景分析] 基于多核处理器的RTOS多核扩展分析与研究 一]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>SMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户空间的GPIO操作]]></title>
    <url>%2Fpost%2F50599.html</url>
    <content type="text"><![CDATA[用户空间的GPIO的操作 1234567891011# cd sys/class/gpio/# lsexport gpiochip0 gpiochip32 gpiochip64 gpiochip96 unexport# echo 33 &gt; export # lsexport gpiochip0 gpiochip64 unexportgpio33 gpiochip32 gpiochip96# cd gpio33/# lsactive_low edge subsystem valuedirection power uevent 输入输出 support “in” and “out” 1echo "in" &gt; direction GPIO中断 support “both” or “none”, “rising”, “falling” edge trigger” 上升沿中断 1echo "rising" &gt; edge 下降沿中断 1echo "falling" &gt; edge]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>GPIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emmc的HS200特性]]></title>
    <url>%2Fpost%2F34668.html</url>
    <content type="text"><![CDATA[emmc设备支持的时钟模式: Speed Mode clock (MHz) Default Speed 26 Hight Speed SDR 52 Hight Speed DDR 52 HS200 200 HS400 200 SDR : 单边沿采样DDR : 双边沿采样 Hardware System DS（Data Strobe）：This signal is generated by the device and used for data output and CRC statusresponse output in HS400 mode. 注: 在电路的设计中需要将RST_n的pin脚可以控制，否则在第一次写数据是容易出现超时错误，因此可以通过mmc驱动控制软件控制，也可以通过硬件的系统reset时控制 Boot的状态转换 GO_PRE_IDLE_STATE command (CMD0 with argument of 0xF0F0F0F0) is the software reset command and puts the device into Pre-idle State. Hardware reset may be used by host resetting a device , moving the device to Pre-idle state and disabling power-on period write protect on blocks that had been set as power-on write protect before the reset was asserted. BOOT_PARTITION_ENABLE配置： Extended CSD register进行设置，BOOT_PARTITION_ENABLE默认配置为0，（0x0 : Device not boot enabled (default)） Bus Speed Mode HS200 Bus Speed ModeThe HS200 mode offers the following features: SDR Data sampling method CLK frequency up to 200MHz Data rate – up to 200MB/s 4 or 8-bits bus width supported Single ended signaling with 4 Drive Strengths Signaling levels of 1.8V and 1.2V Tuning concept for Read Operations HS200 System Block Diagram After power-on or software reset(CMD0), the interface timing of the device is set as the default “Backward Compatible Timing “. Device shall select HS200 Timing mode if required and perform the Tuning process if needed. HS200 Adjustable Sampling Host The Host may use adjustable sampling to determine the correct sampling point. A predefined tuning block stored in Device may be used by the Host as an aid for finding the optimal data sampling point. The Host can use CMD21 tuning command to read the tuning block. HS200为什么需要tuning， 其作用，好处？ 何时发生tuning，tuning的原理？ HS400 Bus Speed ModeThe HS400 mode has the following features: DDR Data sampling method CLK frequency up to 200MHz, Data rate is up to 400MB/s Only 8-bit bus width supported Signaling levels of 1.8V and 1.2V Support up to 5 Drive Strengths Data strobe signal is toggled only for Data out and CRC response e•MMC device in HS400 mode while enabling Enhanced Strobe without the need for tuning procedure. HS400 System Block Diagram For read operations, Data Strobe is generated by device output circuit. Host receives the data which is aligned to the edge of Data Strobe. DS信号初始状态啥样、何时、什么情况下发生跳变? DS的初始信号为O/PP， 上拉高电平* HOST端接受数据为啥要与DS的边沿对齐? 为啥只支持8bit？ 为啥不需要和HS200 mode一样使用tuning? DS和tuning?]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ext4文件系统扩容]]></title>
    <url>%2Fpost%2F38978.html</url>
    <content type="text"><![CDATA[ext4文件系统在制作时，已将大小进行固定，但是在实际的使用过程中，由于后续的测试和使用导致文件系统的空间不足，而同时有不想重新进行文件系统的制作，只是单纯的进行容量的扩展 查看现有ext4文件系统1mount -t ext4 roofs.ext4 tmp resize2fs文件系统扩展容量： 1resize2fs system.ext4 300000 文件系统大小: 300MB 容量扩展创建空的文件系统12dd if=/dev/zero of=new_roofs.ext4 bs=1M count=300mkfs.ext4 new_roofs.ext4 文件系统大小：300M 现有文件系统的拷贝123mount -t ext4 roofs.ext4 tmpmount -t ext4 new_roofs.ext4 tmp1cp tmp/* tmp1 -arpdf]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整理文件分类]]></title>
    <url>%2Fpost%2F39420.html</url>
    <content type="text"><![CDATA[1ls *.md | xargs sed -i &apos;/categories:/&#123;s/单片机/嵌入式/; &#125;&apos;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uImage dump成反汇编]]></title>
    <url>%2Fpost%2F17694.html</url>
    <content type="text"><![CDATA[通过Linux调试使用的uImage文件,进行反汇编查看CPU的具体执行指令 uImage的组成12345+------+-----------------------------+| | || 64k | zImage || | |+------+-----------------------------+ 解压如果时zImage可以直接进行解压操作 去除64k头信息1dd if=uImage of=Image.gz bs=1 skip=64 zip解压1gunzip Image.gz 生成’Image’,CPU执行的二进制代码 获取二进制的执行指令码 通过gcc的工具将二进制的指令码反汇编,CPU的取指是以word进行,也就是每一个wrod对应一条指令 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE *ifp = fopen(argv[1],"r"); FILE *ofp = fopen(argv[2],"wt"); fprintf(ofp,"#include &lt;stdio.h&gt;\n"); fprintf(ofp,"int main(int argc, char *argv[])\n"); fprintf(ofp,"&#123;"); fprintf(ofp,"\tasm volatile ("); while(!feof(ifp))&#123; unsigned int d; fread(&amp;d,1,4,ifp); fprintf(ofp,"\t\t\".word 0x%08x \\t\\n\"\n",d); &#125; fprintf(ofp,"\t);"); fprintf(ofp,"return 0;"); fprintf(ofp,"&#125;"); fclose(ifp); fclose(ofp); return 0;&#125; 使用: 123gcc m.c -o m./m Image Image.c Image.c 12345678910111213#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; asm volatile ( ".word 0x00000000 \t\n" ".word 0x00000000 \t\n" ".word 0x00000000 \t\n" ".word 0x00000000 \t\n" ".word 0x00000000 \t\n" ".word 0x00000000 \t\n" ... ); return 0;&#125; 反汇编12$mips-linux-gnu-gcc Image.c -o Image$mips-linux-gnu-objdump -Dz Image &gt; Image.S Image.S 1234567891011121314151600400640 &lt;main&gt;:400640: 27bdfff8 addiu sp,sp,-8400644: afbe0004 sw s8,4(sp)400648: 03a0f025 move s8,sp40064c: afc40008 sw a0,8(s8)400650: afc5000c sw a1,12(s8)400654: 00000000 nop...400a54: 3c05805f lui a1,0x805f &lt;==== Load Address: 80010000400a58: 3c06805f lui a2,0x805f400a5c: aca404cc sw a0,1228(a1)400a60: 24c60444 addiu a2,a2,1092400a64: 0804078d j 101e34 &lt;_DYNAMIC-0x2fe384&gt;400a68: 24a504cc addiu a1,a1,1228400a6c: 3c028065 lui v0,0x8065400a70: 90422000 lbu v0,8192(v0) 注意:无法进行函数跳转的判断 将PC指针替换成内核入口地址12345678910111213141516#!/usr/bin/env pythonfp = open("Image.S","r")iaddr = 0x80010000flag = 0for line in fp.readlines(): if "400654: 00000000" in line: flag = 1 if flag == 1: s = line.split(":") if len(s) &gt; 1: addr = s[0] data = s[1] print("%08x:\t %s" % (iaddr,s[1])), iaddr = iaddr + 4fp.close() 1python a.py &gt; uImage.S 注意:文件权限问题,可以无法读取文件数据 结果uImage.S12345678800103f8: 00000000 nop800103fc: 00000000 nop80010400: 3c05805f lui a1,0x805f80010404: 3c06805f lui a2,0x805f80010408: aca404cc sw a0,1228(a1)8001040c: 24c60444 addiu a2,a2,109280010410: 0804078d j 101e34 &lt;_DYNAMIC-0x2fe384&gt;80010414: 24a504cc addiu a1,a1,1228 vmlinux.S123456780010400 &lt;run_init_process&gt;:80010400: 3c05805f lui a1,0x805f80010404: 3c06805f lui a2,0x805f80010408: aca404cc sw a0,1228(a1)8001040c: 24c60444 addiu a2,a2,109280010410: 0804078d j 80101e34 &lt;do_execve&gt;80010414: 24a504cc addiu a1,a1,1228]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>umage</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核中的read_mostly]]></title>
    <url>%2Fpost%2F59553.html</url>
    <content type="text"><![CDATA[Linux内核版本: linux4.4.166 read_mostly__read_mostly原语将定义的变量为存放在.data..read_mostly段中. 1#define __read_mostly __attribute__((__section__(&quot;.data..read_mostly&quot;))) file: arch/arm/include/asm/cache.h 定义1234567891011121314151617#define RW_DATA_SECTION(cacheline, pagealigned, inittask) \ . = ALIGN(PAGE_SIZE); \ .data : AT(ADDR(.data) - LOAD_OFFSET) &#123; \ INIT_TASK_DATA(inittask) \ NOSAVE_DATA \ PAGE_ALIGNED_DATA(pagealigned) \ CACHELINE_ALIGNED_DATA(cacheline) \ READ_MOSTLY_DATA(cacheline) \ DATA_DATA \ CONSTRUCTORS \ &#125;...#define READ_MOSTLY_DATA(align) \ . = ALIGN(align); \ *(.data..read_mostly) \ . = ALIGN(align); file: include/asm-generic/vmlinux.lds.h 作用因为__read_mostly修饰的变量均放在.data..read_mostly段中，因此，我们可以将经常需要被读取的数据定义为__read_mostly类型， 这样Linux内核被加载时,该数据将自动被存放到Cache中,以提高整个系统的执行效率。 如果所在平台没有Cache，或者虽然有Cache，但是并不提供存放数据的接口，(也就是并不允许人工放置数据在Cache中), 那么定义为__read_mostly类型的数据将不能存放在Linux内核中，甚至也不能够被加载到系统内存去执行。 如果数据不能存放在linux内核，甚至也不能够被加载到系统内存去执行，后果非常严重，将造成Linux 内核启动失败。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Audio驱动总结--ALSA]]></title>
    <url>%2Fpost%2F50356.html</url>
    <content type="text"><![CDATA[接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结 音频参数 Sample：样本长度(位宽)，音频数据最基本的单位，常见的有8位和16位。 Channel：声道数，分为单声道mono和立体声stereo。 Frame：帧，构成一个声音单元，Frame = Sample channel, samplechannel/8 Byte。 Rate：又称Sample rate，采样率，即每秒的采样次数，针对帧而言。 Interleaved：交错模式，一种音频数据的记录方式，在交错模式下，数据以连续桢的形式存放，即首先记录完桢1的左声道样本和右声道样本（假设为立体声），再开始桢2的记录。而在非交错模式下，首先记录的是一个周期内所有桢的左声道样本，再记录右声道样本，数据是以连续通道的方式存储。多数情况下使用交错模式。 Period size：周期，每次硬件中断处理音频数据的帧数，对于音频设备的数据读写，以此为单位。 Buffer size：数据缓冲区大小，这里特指runtime的buffer size，而不是snd_pcm_hardware定义的buffer_bytes_max。 码率: (编码速率), 码率 = 采样频率 位宽 声道个数 采样率和实际的分频误差在5%左右 Period The interval between interrupts from the hardware. This defines the input latency, since the CPU will not have any idea that there is data waiting until the audio interface interrupts it. The audio interface has a “pointer” that marks the current position for read/write in its h/w buffer. The pointer circles around the buffer as long as the interface is running. Typically, there are an integral number of periods per traversal of the h/w buffer, but not always. There is at least one card (ymfpci)that generates interrupts at a fixed rate indepedent of the buffer size (which can be changed), resulting in some “odd” effects compared to more traditional designs. Note: h/w generally defines the interrupt in frames, though not always. Alsa’s period size setting will affect how much work the CPU does. if you set the period size low, there will be more interrupts and the work that is done every interrupt will be done more often. So, if you don’t care about low latency,set the period size large as possible and you’ll have more CPU cycles for other things. The defaults that ALSA provides are in the middle of the range, typically. (from an old AlsaDevel thread[1], quoting Paul Davis) Retrieved from “http://alsa.opensrc.org/Period&quot; 来自：http://alsa.opensrc.org/Period FramesPeriods A frame is equivalent of one sample being played, irrespective of the number of channels or the number of bits. e.g. 1 frame of a Stereo 48khz 16bit PCM stream is 4 bytes. 1 frame of a 5.1 48khz 16bit PCM stream is 12 bytes.A period is the number of frames in between each hardware interrupt. The poll() will return once a period.The buffer is a ring buffer. The buffer size always has to be greater than one period size. Commonly this is 2*period size, but some hardware can do 8 periods per buffer. It is also possible for the buffer size to not be an integer multiple of the period size.Now, if the hardware has been set to 48000Hz , 2 periods, of 1024 frames each, making a buffer size of 2048 frames. The hardware will interrupt 2 times per buffer. ALSA will endeavor to keep the buffer as full as possible. Once the first period of samples hasbeen played, the third period of samples is transfered into the space the first one occupied while the second period of samples is being played. (normal ring buffer behaviour). Additional example Here is an alternative example for the above discussion.Say we want to work with a stereo, 16-bit, 44.1 KHz stream, one-way (meaning, either in playback or in capture direction). Then we have: ‘stereo’ = number of channels: 2 1 analog sample is represented with 16 bits = 2 bytes 1 frame represents 1 analog sample from all channels; here we have 2 channels, and so: 1 frame = (num_channels) (1 sample in bytes) = (2 channels) (2 bytes (16 bits) per sample) = 4 bytes (32 bits) To sustain 2x 44.1 KHz analog rate - the system must be capable of data transfer rate, in Bytes/sec: Bps_rate = (num_channels) (1 sample in bytes) (analog_rate) = (1 frame) (analog_rate) = ( 2 channels ) (2 bytes/sample) (44100 samples/sec) = 22*44100 = 176400 Bytes/secNow, if ALSA would interrupt each second, asking for bytes - we’d need to have 176400 bytes ready for it (at end of each second), in order to sustain analog 16-bit stereo @ 44.1Khz. If it would interrupt each half a second, correspondingly for the same stream we’d need 176400/2 = 88200 bytes ready, at each interrupt; if the interrupt hits each 100 ms, we’d need to have 176400*(0.1/1) = 17640 bytes ready, at each interrupt.We can control when this PCM interrupt is generated, by setting a period size, which is set in frames. Thus, if we set 16-bit stereo @ 44.1Khz, and the period_size to 4410 frames =&gt; (for 16-bit stereo @ 44.1Khz, 1 frame equals 4 bytes - so 4410 frames equal 4410*4 = 17640 bytes) =&gt; an interrupt will be generated each 17640 bytes - that is, each 100 ms. Correspondingly, buffer_size should be at least 2period_size = 24410 = 8820 frames (or 8820*4 = 35280 bytes).It seems (writing-an-alsa-driver.pdf), however, that it is the ALSA runtime that decides on the actual buffer_size and period_size, depending on: the requested number of channels, and their respective properties (rate and sampling resolution) - as well as theparameters set in the snd_pcm_hardware structure (in the driver).Also, the following quote may be relevant, from http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html: The “frame” represents the unit, 1 frame = # channels x sample_bytes.In your case, 1 frame corresponds to 2 channels x 16 bits = 4 bytes. The periods is the number of periods in a ring-buffer. In OSS, calledas “fragments”. So, buffer_size = period_size * periods period_bytes = period_size * bytes_per_frame bytes_per_frame = channels * bytes_per_sample I still don’t understand what ‘period_size’ and a ‘period’ is? The “period” defines the frequency to update the status, usually viathe invokation of interrupts. The “period_size” defines the frame sizes corresponding to the “period time”. This term corresponds to the “fragment size” on OSS. On major sound hardwares,a ring-buffer is divided to several parts and an irq is issued on each boundary. The period_size defines the size of this chunk. On some hardwares, the irq is controlled on the basis of a timer. In this case, the period is defined as the timer frequency to invoke an irq. 来自：http://alsa-project.org/main/index.php/FramesPeriods 音频处理软件 Audacity 2.0.5 硬件主要由音频总线(I2S,PCM)和控制总线(I2C或SPI)组成。 alsa - ASOC在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。 ASoC被分为Machine、Platform和Codec三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。 machine用于描述设备组件信息和特定的控制如耳机/外放等。 是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。 这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等 Platform用于实现平台相关的DMA驱动和音频接口等。 一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。 这一部分只关心CPU本身，不关心Codec。主要处理两个问题：DMA引擎和SoC集成的PCM、I2S或AC &#39;97数字接口控制。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：snd_soc_platform_driver和snd_soc_dai_driver。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。 Codec用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等 字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。 这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是： 对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。 对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。 对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。 对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。 ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上。 ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。 Codec驱动向ASoC注册snd_soc_codec和snd_soc_dai设备。 Platform驱动向ASoC注册snd_soc_platform和snd_soc_dai设备。 Machine驱动通过snd_soc_dai_link绑定codec/dai/platform. Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。 path描述与其它widget的连接关系。 event用于通知该widget的上下电状态。 power指示当前的上电状态。 control实现空间用户接口用于控制widget的音量/通路切换等。 对驱动开者来说，就可以很好的解耦了： codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了; soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等; 板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。 DAPMDPCM Dynamic PCM PCM设备放音 – 应用 tinyplay播放音乐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# strace tinyplay pcmrec.wavexecve("/usr/bin/tinyplay", ["tinyplay", "pcmrec.wav"], [/* 16 vars */]) = 0...open("pcmrec.wav", O_RDONLY) = 3...//读取wav格式的音频文件的头数据read(3, "RIFF$\342\4\0WAVEfmt \20\0\0\0\1\0\2\0@\37\0\0\0&#125;\0\0"..., 4096) = 4096//第一次打开`pcmC0D0p`设备节点, 重新设置硬件参数open("/dev/snd/pcmC0D0p", O_RDWR) = 4//ioctl - cmd=SNDRV_PCM_IOCTL_HW_REFINEioctl(4, 0xc25c4110, 0x412178) = 0close(4) = 0//第二次打开`pcmC0D0p`设备节点, 进行音频播放的准备工作和播放open("/dev/snd/pcmC0D0p", O_RDWR) = 4//ioctl - cmd=`SNDRV_PCM_IOCTL_INFO`ioctl(4, AGPIOC_ACQUIRE or APM_IOC_STANDBY, 0x7f83f3cc) = 0//ioctl - cmd=`SNDRV_PCM_IOCTL_HW_PARAMS`ioctl(4, 0xc25c4111, 0x7f83f170) = 0//ioctl - cmd=`SNDRV_PCM_IOCTL_SW_PARAMS`ioctl(4, 0xc0684113, 0x7f83f5ec) = 0//在播放期间响应Ctrl+C的中断信号rt_sigaction(SIGINT, &#123;0x10000000, [RT_65 RT_67], 0x401240 /* SA_??? */&#125;, &#123;SIG_DFL, [RT_67 RT_68 RT_72 RT_74 RT_75 RT_77 RT_81 RT_89 RT_90 RT_91 RT_93 RT_94], 0&#125;, 16) = 0// mmap// ioctl - cmd=`SNDRV_PCM_IOCTL_SYNC_PTR`read(3, "\320\367\200\367\370\370`\370\220\370\330\370@\372h\371\240\371\320\374\230\373\240\374\341\5\301\1\241\5\221\25"..., 12288) = 12288read(3, "a\0361\36\241\f\10\376\300\374\320\375\30\375\360\375\340\375\0\377\320\377(\377\370\376p\375p\374\321\0"..., 4096) = 4096//ioctl - cmd=`SNDRV_PCM_IOCTL_PREPARE`ioctl(4, 0x20004140, 0x7f83f648) = 0//ioctl - cmd=`SNDRV_PCM_IOCTL_WRITEI_FRAMES`ioctl(4, 0x800c4150, 0x7f83f648) = 0read(3, "\201\21\301\27q\30\261\25\301\20Q\6x\375h\373\370\373\230\374\210\374x\374p\374\220\374\30\375 \375"..., 12288) = 12288read(3, "\201\35\1%\241'\301\32\341\t@\377\250\374\220\372\20\373\30\374\340\373X\374H\374X\376\201\v\321\32"..., 4096) = 4096ioctl(4, 0x800c4150, 0x7f83f648) = 0... //while()&#123; 循环读取播放 &#125;read(3, "\370\375\10\376 \376\210\376X\376x\376\250\376\350\376\360\376\260\376(\377H\377q\0\301\5\1\vq\21"..., 12288) = 12288read(3, "\221\0021\n\21\f\241\5x\376\30\377\300\377(\377\1\1!\3q\4Q\3\301\4\240\377h\376\210\377"..., 4096) = 4096ioctl(4, 0x800c4150, 0x7f83f648) = 0read(3, "P\377\0\377!\0\361\6Q\t\230\377@\376\250\377X\377\361\3\1\16\241\n!\0!\6A\16\241\v"..., 12288) = 4652read(3, "", 4096) = 0ioctl(4, 0x800c4150, 0x7f83f648) = 0read(3, "", 16384) = 0ioctl(4, 0x800c4150, 0x7f83f648) = 0close(4) = 0close(3) = 0munmap(0x76fe9000, 65536) = 0write(1, "Playing sample: 2 ch, 8000 hz, 1"..., 38) = 38 //printfexit_group(0) 为什么open两次pcmC0D0p设备节点 第一次打开pcmC0D0p,主要为了重新规范硬件1234567891011121314151617struct snd_pcm_hw_params &#123; unsigned int flags; struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - SNDRV_PCM_HW_PARAM_FIRST_MASK + 1]; struct snd_mask mres[5]; /* reserved masks */ struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1]; struct snd_interval ires[9]; /* reserved intervals */ unsigned int rmask; /* W: requested masks */ unsigned int cmask; /* R: changed masks */ unsigned int info; /* R: Info flags for returned setup */ unsigned int msbits; /* R: used most significant bits */ unsigned int rate_num; /* R: rate numerator */ unsigned int rate_den; /* R: rate denominator */ snd_pcm_uframes_t fifo_size; /* R: chip FIFO size in frames */ unsigned char reserved[64]; /* reserved for future */&#125;; file: include/uapi/sound/asound.h 主要是将用户空间的snd_pcm_hw_params信息和内核空间的进行对比和规范化 第二次打开pcmC0D0p,主要为了进行音频播放的准备和播放音频信号 为什么read音频文件两次,并且读的数据大小不一致tinyplay中播放时,每次只读取一部分(16KB)的音频文件进行播放123456789101112131415161718192021size = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm)); //size=16384Byte=16KBbuffer = malloc(size);...do &#123; //buffer 临时存放音频文件的数据的buf //size 一次读取的大小(16384Byte) //file 打开的音频文件描述符 num_read = fread(buffer, 1, size, file); if (num_read &gt; 0) &#123; if (pcm_write(pcm, buffer, num_read)) &#123; fprintf(stderr, "Error playing sample\n"); break; &#125; &#125;else if(num_read == 0) &#123; memset(buffer, 0, size); if(pcm_write(pcm, buffer, size))&#123; fprintf(stderr, "Error playing sample\n"); break; &#125; &#125;&#125; while (!close &amp;&amp; num_read &gt; 0); 在进行strace时,一次播放进行了两次的read系统调用,将每一次read数据的大小相加(12288+4096=16384Byte),正好与malloc的buffer大小一致.因此两次的read是由用户空间的函数进行数据分割的. 用户空间申请buffer大小的依据在播放当前歌曲时,所申请的buffer大小为16KB,为什么申请16K? 音频信息: 采样率 通道 位宽(format) 44100Hz 2 16bit 4KB的buffer大小为tinyplay默认大小,period_size = 1024, period_count = 4决定了buffer大小,而period_size可以进行修改默认大小. 需要申请buffer的大小: 1024 4 2 * (16 / 8) = 16384 放音 – 内核ASOC接口1234567891011121314151617181920212223242526272829303132333435363738394041/* create a new pcm */int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)&#123; ... /* ASoC PCM operations */ if (rtd-&gt;dai_link-&gt;dynamic) &#123; rtd-&gt;ops.open = dpcm_fe_dai_open; rtd-&gt;ops.hw_params = dpcm_fe_dai_hw_params; rtd-&gt;ops.prepare = dpcm_fe_dai_prepare; rtd-&gt;ops.trigger = dpcm_fe_dai_trigger; rtd-&gt;ops.hw_free = dpcm_fe_dai_hw_free; rtd-&gt;ops.close = dpcm_fe_dai_close; rtd-&gt;ops.pointer = soc_pcm_pointer; rtd-&gt;ops.ioctl = soc_pcm_ioctl; &#125; else &#123; //回调函数 rtd-&gt;ops.open = soc_pcm_open; rtd-&gt;ops.hw_params = soc_pcm_hw_params; rtd-&gt;ops.prepare = soc_pcm_prepare; rtd-&gt;ops.trigger = soc_pcm_trigger; rtd-&gt;ops.hw_free = soc_pcm_hw_free; rtd-&gt;ops.close = soc_pcm_close; rtd-&gt;ops.pointer = soc_pcm_pointer; rtd-&gt;ops.ioctl = soc_pcm_ioctl; &#125; if (platform-&gt;driver-&gt;ops) &#123; rtd-&gt;ops.ack = platform-&gt;driver-&gt;ops-&gt;ack; rtd-&gt;ops.copy = platform-&gt;driver-&gt;ops-&gt;copy; rtd-&gt;ops.silence = platform-&gt;driver-&gt;ops-&gt;silence; rtd-&gt;ops.page = platform-&gt;driver-&gt;ops-&gt;page; rtd-&gt;ops.mmap = platform-&gt;driver-&gt;ops-&gt;mmap; &#125; if (playback) snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops); if (capture) snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops); ...&#125; file: sound/soc/soc-pcm.c soc_pcm_open123456789101112131415161718192021static int soc_pcm_open(struct snd_pcm_substream *substream)&#123; ... // CPU &lt;I2S&gt; : jz_i2s_startup if (cpu_dai-&gt;driver-&gt;ops-&gt;startup) &#123; ret = cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai); &#125; // Platform &lt;DMA&gt; : jz_pcm_open if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;open) &#123; ret = platform-&gt;driver-&gt;ops-&gt;open(substream); &#125; // Codec &lt;idec_d3&gt; : jz_icdc_startup if (codec_dai-&gt;driver-&gt;ops-&gt;startup) &#123; ret = codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai); &#125; // Machine &lt;link&gt; : phoenix_spk_sup file:sound/soc/ingenic/asoc-board/phoenix_icdc.c if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;startup) &#123; ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream); &#125; ...&#125; soc_pcm_hw_params12345678910111213141516171819202122static int soc_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)&#123; ... // Machine &lt;link&gt; : phoenix_i2s_hw_params if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_params) &#123; ret = rtd-&gt;dai_link-&gt;ops-&gt;hw_params(substream, params); &#125; // Codec &lt;idec_d3&gt; : icdc_d3_hw_params if (codec_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123; ret = codec_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, codec_dai); &#125; // CPU &lt;I2S&gt; : jz_i2s_hw_params if (cpu_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123; ret = cpu_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, cpu_dai); &#125; // Platform &lt;DMA&gt; : jz_pcm_hw_params if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_params) &#123; ret = platform-&gt;driver-&gt;ops-&gt;hw_params(substream, params); &#125; ...&#125; soc_pcm_prepare123456789101112131415161718192021static int soc_pcm_prepare(struct snd_pcm_substream *substream)&#123; ... // Machine &lt;link&gt; : phoenix_i2s_hw_params if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;prepare) &#123; ret = rtd-&gt;dai_link-&gt;ops-&gt;prepare(substream); &#125; // Platform &lt;DMA&gt; : jz_pcm_prepare if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;prepare) &#123; ret = platform-&gt;driver-&gt;ops-&gt;prepare(substream); &#125; // Codec &lt;idec_d3&gt; : 默认函数 if (codec_dai-&gt;driver-&gt;ops-&gt;prepare) &#123; ret = codec_dai-&gt;driver-&gt;ops-&gt;prepare(substream, codec_dai); &#125; // CPU &lt;I2S&gt; : 默认函数 if (cpu_dai-&gt;driver-&gt;ops-&gt;prepare) &#123; ret = cpu_dai-&gt;driver-&gt;ops-&gt;prepare(substream, cpu_dai); &#125; ...&#125; soc_pcm_trigger12345678910111213141516static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)&#123; // Codec &lt;idec_d3&gt; : icdc_d3_trigger if (codec_dai-&gt;driver-&gt;ops-&gt;trigger) &#123; ret = codec_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, codec_dai); &#125; // Platform &lt;DMA&gt; : jz_pcm_trigger if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;trigger) &#123; ret = platform-&gt;driver-&gt;ops-&gt;trigger(substream, cmd); &#125; // CPU &lt;I2S&gt; : jz_i2s_trigger if (cpu_dai-&gt;driver-&gt;ops-&gt;trigger) &#123; ret = cpu_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, cpu_dai); &#125; ...&#125; soc_pcm_hw_free123456789101112131415161718192021static int soc_pcm_hw_free(struct snd_pcm_substream *substream)&#123; /* free any machine hw params */ // Machine &lt;link&gt; : phoenix_i2s_hw_free if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_free) rtd-&gt;dai_link-&gt;ops-&gt;hw_free(substream); /* free any DMA resources */ // Platform &lt;DMA&gt; : snd_pcm_lib_free_pages if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_free) platform-&gt;driver-&gt;ops-&gt;hw_free(substream); /* now free hw params for the DAIs */ // Codec &lt;idec_d3&gt; : 默认函数 if (codec_dai-&gt;driver-&gt;ops-&gt;hw_free) codec_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, codec_dai); // CPU &lt;I2S&gt; : 默认函数 if (cpu_dai-&gt;driver-&gt;ops-&gt;hw_free) cpu_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, cpu_dai); ...&#125; soc_pcm_pointer123456789101112131415static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)&#123; // Platform &lt;DMA&gt; : if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;pointer) offset = platform-&gt;driver-&gt;ops-&gt;pointer(substream); if (cpu_dai-&gt;driver-&gt;ops-&gt;delay) delay += cpu_dai-&gt;driver-&gt;ops-&gt;delay(substream, cpu_dai); if (codec_dai-&gt;driver-&gt;ops-&gt;delay) delay += codec_dai-&gt;driver-&gt;ops-&gt;delay(substream, codec_dai); if (platform-&gt;driver-&gt;delay) delay += platform-&gt;driver-&gt;delay(substream, codec_dai);&#125; soc_pcm_close12345678910111213141516static int soc_pcm_close(struct snd_pcm_substream *substream)&#123; // CPU &lt;I2S&gt; : jz_i2s_shutdown if (cpu_dai-&gt;driver-&gt;ops-&gt;shutdown) cpu_dai-&gt;driver-&gt;ops-&gt;shutdown(substream, cpu_dai); // Codec &lt;idec_d3&gt; : jz_icdc_shutdown if (codec_dai-&gt;driver-&gt;ops-&gt;shutdown) codec_dai-&gt;driver-&gt;ops-&gt;shutdown(substream, codec_dai); // Machine &lt;link&gt; : phoenix_spk_sdown if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;shutdown) rtd-&gt;dai_link-&gt;ops-&gt;shutdown(substream); // Platform &lt;DMA&gt; : jz_pcm_close if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;close) platform-&gt;driver-&gt;ops-&gt;close(substream); ...&#125; open12345678910111213141516171819|(sound/core/pcm_native.c )|-&gt; snd_pcm_playback_open \ |-&gt; snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK); \ |-&gt; while(1)&#123; snd_pcm_open_file(file, pcm, stream); schedule(); &#125; \ |-&gt; snd_pcm_open_substream \ |-&gt; substream-&gt;ops-&gt;open(substream) |(sound/soc/soc-pcm.c) |-&gt; soc_pcm_open \ |-&gt; cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai); \_**snd_soc_register_component** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_i2s_startup) |-&gt; codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai); \_**snd_soc_register_codec** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_icdc_startup) |-&gt; rtd-&gt;dai_link-&gt;ops-&gt;startup(substream); \_ **snd_soc_register_card** -&gt; snd_soc_dai_link -&gt; snd_soc_ops (.startup = phoenix_spk_sup) ioctl ioctl幻数 123456789101112//获取声卡信息返回给用户空间#define SNDRV_PCM_IOCTL_INFO _IOR('A', 0x01, struct snd_pcm_info)//硬件参数重新规范#define SNDRV_PCM_IOCTL_HW_REFINE _IOWR('A', 0x10, struct snd_pcm_hw_params)//设置硬件参数#define SNDRV_PCM_IOCTL_HW_PARAMS _IOWR('A', 0x11, struct snd_pcm_hw_params)//设置软件参数#define SNDRV_PCM_IOCTL_SW_PARAMS _IOWR('A', 0x13, struct snd_pcm_sw_params)//准备操作#define SNDRV_PCM_IOCTL_PREPARE _IO('A', 0x40)//从用户空间把音频数据拿过来，从wav文件中读出数据#define SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW('A', 0x50, struct snd_xferi) 1234567891011121314151617181920212223242526272829(`sound/core/pcm_native.c`)|-&gt; snd_pcm_playback_ioctl||-&gt; snd_pcm_playback_ioctl1 --&gt; 判断cmd &lt;SNDRV_PCM_IOCTL_WRITEI_FRAMES&gt;|(`sound/core/pcm_lib.c`)|-&gt; snd_pcm_lib_write --- &gt; struct snd_pcm_substream *substream||-&gt; snd_pcm_lib_write1 |_call_back--&gt;snd_pcm_lib_write_transfer(数据传输:copy和map) |_.(内存和DMA之间的数据传递, 循环搬送直到播放完毕) char *hwbuf = runtime-&gt;dma_area + frames_to_bytes(runtime, hwoff); if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames))) | |-&gt; snd_pcm_start(substream) //**启动传输(只是在开始时,调用一次)** | |-&gt; snd_pcm_action | |-&gt; snd_pcm_action_single | |-&gt; &#123; res = ops-&gt;pre_action(substream, state); if (res &lt; 0) return res; res = ops-&gt;do_action(substream, state); if (res == 0) ops-&gt;post_action(substream, state); else if (ops-&gt;undo_action) ops-&gt;undo_action(substream, state); &#125; file: sound/core/pcm_native.c close通过系统调用close, 到release进行关闭 1234567891011121314.release = snd_pcm_releasesnd_pcm_release | |-&gt; snd_pcm_release_substream | |-&gt; snd_pcm_drop | |-&gt; snd_pcm_stop | |-&gt; snd_pcm_action(&amp;snd_pcm_action_stop, substream, state) | |-&gt; substream-&gt;ops-&gt;hw_free(substream) |-&gt; substream-&gt;ops-&gt;close(substream) control设备codec数据路由amixer的设置调试ASoC添加了debugfs和ftrace的调试支持。 12345678910111213141516171819202122mount -t debugfs none /mnt/# cat available_events | grep "asoc"asoc:snd_soc_cache_syncasoc:snd_soc_jack_notifyasoc:snd_soc_jack_reportasoc:snd_soc_jack_irqasoc:snd_soc_dapm_connectedasoc:snd_soc_dapm_input_pathasoc:snd_soc_dapm_output_pathasoc:snd_soc_dapm_walk_doneasoc:snd_soc_dapm_widget_event_doneasoc:snd_soc_dapm_widget_event_startasoc:snd_soc_dapm_widget_powerasoc:snd_soc_dapm_doneasoc:snd_soc_dapm_startasoc:snd_soc_bias_level_doneasoc:snd_soc_bias_level_startasoc:snd_soc_preg_readasoc:snd_soc_preg_writeasoc:snd_soc_reg_readasoc:snd_soc_reg_write 在DEBUGFS下，可以查看一个各个组件及widgets的状态。 在FTRACE下，echo asoc &gt; tracing/set_event打开调试，就可以cat /mnt/tracing/trace查看widget的上下电顺序， 通路的切换等。 性能频响 频率响应 简称频响，英文名称是Frequency Response，在电子学上用来描述一台仪器对于不同频率的信号的处理能力的差异。 扫频 利用正弦波信号的频率随时间在一定范围内反复扫描]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>alsa</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态机]]></title>
    <url>%2Fpost%2F32902.html</url>
    <content type="text"><![CDATA[状态机有限状态机（Finite State Machine或者Finite State Automata)是软件领域中一种重要的工具，很多东西的模型实际上就是有限状态机。 FSM的实现方式： switch/case或者if/else 这无意是最直观的方式，使用一堆条件判断，会编程的人都可以做到，对简单小巧的状态机来说最合适，但是毫无疑问，这样的方式比较原始，对庞大的状态机难以维护。 状态表 维护一个二维状态表，横坐标表示当前状态，纵坐标表示输入，表中一个元素存储下一个状态和对应的操作。这一招易于维护，但是运行时间和存储空间的代价较大。 实现有限状态机(finite state machine)是一个数学概念，如果把它运用于程序中，可以发挥很大的作用。它是一种协议，用于有限数量的子程序(“状态”)的发展变化。每个子程序进行一些处理并选择下一种状态(通常取决于下一段输入)。 有限状态机(FSM)可以用作程序的控制结构。FSM对于那些基于输入的在几个不同的可选动作中进行循环的程序尤其合适。投币售货机就是FSM的一个好例子。另外一个你可以想到的复杂的例子就是你正在用的东西，想到了吗？没错，就是操作系统。在投币售货机的例子中，输入是硬币，输出是待售商品，售货机有”接受硬币”，”选择商品”，”发送商品”和”找零钱”等几种状态。 它的基本思路是用一张表保存所有可能的状态，并列出进入每个状态时可能执行的所有动作，其中最后一个动作就是计算(通常在当前状态和下一次输入字符的基础上，另外再经过一次表查询)下一个应该进入的状态。你从一个”初始状态”开始。在这一过程中，翻译表可能告诉你进入了一个错误状态，直到到达结束状态。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; //比如我们定义了小明一天的状态如下enum&#123; GET_UP, GO_TO_SCHOOL, HAVE_LUNCH, DO_HOMEWORK, SLEEP,&#125;;enum&#123; EVENT1 = 1, EVENT2, EVENT3,&#125;;typedef struct FsmTable_s&#123; int event; //事件 int CurState; //当前状态 void (*eventActFun)(); //函数指针 int NextState; //下一个状态&#125;FsmTable_t;typedef struct FSM_s&#123; FsmTable_t* FsmTable; //指向的状态表 int curState; //FSM当前所处的状态&#125;FSM_t;int g_max_num; //状态表里含有的状态个数void GetUp()&#123; // do something printf("xiao ming gets up!\n");&#125;void Go2School()&#123; // do something printf("xiao ming goes to school!\n");&#125;void HaveLunch()&#123; // do something printf("xiao ming has lunch!\n");&#125;void DoHomework()&#123; // do something printf("xiao ming does homework!\n");&#125;void Go2Bed()&#123; // do something printf("xiao ming goes to bed!\n");&#125;/*状态机注册*/void FSM_Regist(FSM_t* pFsm, FsmTable_t* pTable)&#123; pFsm-&gt;FsmTable = pTable;&#125;/*状态迁移*/void FSM_StateTransfer(FSM_t* pFsm, int state)&#123; pFsm-&gt;curState = state;&#125;/*事件处理*/void FSM_EventHandle(FSM_t* pFsm, int event)&#123; FsmTable_t* pActTable = pFsm-&gt;FsmTable; void (*eventActFun)() = NULL; //函数指针初始化为空 int NextState; int CurState = pFsm-&gt;curState; int flag = 0; //标识是否满足条件 int i; /*获取当前动作函数*/ for (i = 0; i&lt;g_max_num; i++) &#123; //当且仅当当前状态下来个指定的事件，我才执行它 if (event == pActTable[i].event &amp;&amp; CurState == pActTable[i].CurState) &#123; flag = 1; eventActFun = pActTable[i].eventActFun; NextState = pActTable[i].NextState; break; &#125; &#125; if (flag) &#123; /*动作执行*/ if (eventActFun) &#123; eventActFun(); &#125; //跳转到下一个状态 FSM_StateTransfer(pFsm, NextState); &#125; else &#123; // do nothing &#125;&#125;FsmTable_t XiaoMingTable[] =&#123; //&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125; &#123; EVENT1, SLEEP, GetUp, GET_UP &#125;, &#123; EVENT2, GET_UP, Go2School, GO_TO_SCHOOL &#125;, &#123; EVENT3, GO_TO_SCHOOL, HaveLunch, HAVE_LUNCH &#125;, &#123; EVENT1, HAVE_LUNCH, DoHomework, DO_HOMEWORK &#125;, &#123; EVENT2, DO_HOMEWORK, Go2Bed, SLEEP &#125;, //add your codes here&#125;;//初始化FSMvoid InitFsm(FSM_t* pFsm)&#123; g_max_num = sizeof(XiaoMingTable) / sizeof(FsmTable_t); pFsm-&gt;curState = SLEEP; FSM_Regist(pFsm, XiaoMingTable);&#125;//测试void test(int *event)&#123; if (*event == 3) &#123; *event = 1; &#125; else &#123; (*event)++; &#125;&#125;int main()&#123; FSM_t fsm; InitFsm(&amp;fsm); int event = EVENT1; //小明的一天,周而复始的一天又一天，进行着相同的活动 while (1) &#123; printf("event %d is coming...\n", event); FSM_EventHandle(&amp;fsm, event); printf("fsm current state %d\n", fsm.curState); test(&amp;event); sleep(1); //休眠1秒，方便观察 &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>FSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞，非阻塞]]></title>
    <url>%2Fpost%2F63673.html</url>
    <content type="text"><![CDATA[在mmc子系统自带的测试中数据的读写有阻塞和非阻塞两种，这里主要将这两种IO的操作进一步做简单的总结，来加深自己的理解。同时，也将在学习过程中又接触到的同步和异步记录在此。 阻塞IO(block IO) 阻塞操作是指在执行设备操作时，若不能获取资源，则挂起进程直到满足可操作的条件后再进行操作。 在进行阻塞的IO操作时，如果没有可用的资源，当前进程将进入睡眠模式，它将CPU资源让给其他进程，但是由于会进入睡眠状态，因此在我们得到资源可以利用时（设备驱动中一般中断的方式得到该状态，因为在硬件资源发生变化是一般都会产生中断），必须将休眠的进程再次唤醒进行后续的操作。 非阻塞IO(unblock IO) 非阻塞操作进程在不能进行设备操作时，并不挂起，它要么放弃，要么不停的查询，直到可以进行操作为止 这种方式是不断的查询当前资源的状态，不断的尝试，将消耗大量的CPU资源。]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>阻塞IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程退出的exitcode]]></title>
    <url>%2Fpost%2F7653.html</url>
    <content type="text"><![CDATA[错误信息内核打印 1Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b 分析出错位置123panic("Attempted to kill init! exitcode=0x%08x\n", father-&gt;signal-&gt;group_exit_code ?: father-&gt;exit_code); kernel/exit.c exit_cede赋值12345678void do_exit(long code)&#123; ... tsk-&gt;exit_code = code; ... exit_notify(tsk, group_dead); ...&#125; 函数调用关系:1234exit_notify |-&gt; forget_original_parent(tsk); |-&gt; find_new_reaper(father); |-&gt; &quot;Attempted to kill init! exitcode=0x%08x\n&quot; 错误来源在Android系统中,linux内核启动过程中,进入用户空间后,init进程执行过程中出现该错误 由于在用户空间引起的内核错误,因此只能通过系统调用产生 1234SYSCALL_DEFINE1(exit, int, error_code) &#123; do_exit((error_code&amp;0xff)&lt;&lt;8);&#125; 在进入内核是do_exit取了用户空间传入的错误码的低8位 进程退出的错误码在系统中的进程在正常和非正常退出时，都有一个表示当前进程退出状态的标识，即退出码 查看进程退出码退出码代表的是一个进程退出的状态码, 可以使用wait函数进行查看。1void _exit(int status)， status表明了进程终止时的状态。当子进程使用_exit()后，父进程如果在用wait()等待子进程，那么wait()将会返回status状态，注意只有status的低8位（0~255）会返回给父进程 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;int main(void)&#123; int count = 1; int pid; int status; pid = fork( ); printf("pid=%d\n", pid); if(pid &lt; 0) &#123; perror("fork error : "); &#125; else if(pid == 0) &#123; printf("This is son, his count is: %d (%p). and his pid is: %d\n", ++count, &amp;count, getpid()); sleep(3); _exit(0); &#125; else &#123; pid = wait(&amp;status); printf("This is father, his count is: %d (%p), his pid is: %d, son exit status: %d[%08x]\n", count, &amp;count, getpid(), status, status); &#125; return 0;&#125; 正常退出结果：12345=====&gt;$./a.outpid=4018pid=0This is son, his count is: 2 (0x7fff19658714). and his pid is: 4018This is father, his count is: 1 (0x7fff19658714), his pid is: 4017, son exit status: 0[00000000] 在子进程sleep时将其kill掉的结果：12345678910=====&gt;$./a.out &amp;[1] 406600:11 [xxx@machine]~/work/MyCode/systemcall/test=====&gt;$pid=4067pid=0This is son, his count is: 2 (0x7ffe19987d04). and his pid is: 406700:11 [xxx@machine]~/work/MyCode/systemcall/test=====&gt;$kill 4067This is father, his count is: 1 (0x7ffe19987d04), his pid is: 4066, son exit status: 15[0000000f] 在进程正常退出时，子进程的状态码是0，而kill掉后变为了15. 注：此时如果在linux终端下使用echo $?,获取的仅仅该进程的main函数的返回值。 退出码的含义根据前面分析，在进程调用_exit退出时,是通过exit系统调用实现的，而这里的0和15,就是系统调用exit的参数error_code 进程的退出状态不等于退出码，程退出时候的状态码是8位，高4位存储退出码，低4位存储导致进程退出的信号标志位 网上有人说16位，分别是高八位和低八位，还需确认 根据这段话的描述，之前测试中子进程的退出状态0和15中，退出码均为0,而退出时的singal不同，正常退出时为0，kill掉后变为15 制造段错误在测试case中的子进程中，制造一个段错误，根据此时的分析子进程退出的状态码中的signal应该代表段错误子进程中添加：12int *a;*a = 3; 测试结果：12345=====&gt;$./a.outpid=4500pid=0This is son, his count is: 2 (0x7fff54e86d1c). and his pid is: 4500This is father, his count is: 1 (0x7fff54e86d1c), his pid is: 4499, son exit status: 139[0000008b] 此时子进程的退出码=8，而signal=b 信号linux内核中x86的信号列表：12#define SIGSEGV 11#define SIGTERM 15 arch/x86/include/uapi/asm/signal.h 信号 行为 产生原因 SIGTERM 请求中断 kill() 可以发 SIGTERM 过去；kill 命令默认也使用 SIGTERM 信号 SIGSEGV 无效内存引用 段错误 总结进程在退出时都会将自己当前的状态告诉内核，而此时的状态码包含两种含义： 高4位代表当前进程的退出码 低4位代表使当前进程退出所使用的信号 在本文最开始提到的错误也是由于SIGSEGV无效内存引用引起的。 mips架构下的信号列表： 1#define SIGTERM 15 /* Termination (ANSI). */ arch/mips/include/uapi/asm/signal.h 参考： linux子进程退出状态值解析：waitpid() status意义解析]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>exit_code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频接口I2S]]></title>
    <url>%2Fpost%2F25782.html</url>
    <content type="text"><![CDATA[I2S(Inter—IC Sound)总线, 又称 集成电路内置音频总线，是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准，该总线专责于音频设备之间的数据传输，广泛应用于各种多媒体系统。它采用了沿独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。 硬件接口三个主要的信号线 BCLK 时钟是方波的形式 串行时钟SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK都有1个脉冲。SCLK的频率=2×采样频率×采样位数。 如采样频率=44.1Khz 采样位数=24bit SCLK = 2 44.1kHz 24 = 2.1168MHz LRCLK帧时钟LRCK，(也称WS)，用于切换左右声道的数据。LRCK为“1”表示正在传输的是右声道的数据，为“0”则表示正在传输的是左声道的数据。LRCK的频率 = 采样频率。在目前的测试中主要为SYNC_CLK LRCLK=44.1kHz SDATA串行数据SDATA，就是用二进制补码表示的音频数据。 数据格式—–I2SI2S LJ (Left Justified) RJ (Left Justified) I2S–八声道 i2s normal mode 参考 16I2S/PCM Controller (8 channel).pdf)]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>I2S</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网站]]></title>
    <url>%2Fpost%2F20962.html</url>
    <content type="text"><![CDATA[平时工作学习的常用网站. 技术 python –廖雪峰Python教程 学习 嵌入式linux学习 –蜗窝科技 阅读 电子书 –kindle推]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据处理]]></title>
    <url>%2Fpost%2F60233.html</url>
    <content type="text"><![CDATA[https://supergis.gitbooks.io/git_notebook/content/doc/opendatasource.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SD卡的硬件电路及相关属性]]></title>
    <url>%2Fpost%2F47964.html</url>
    <content type="text"><![CDATA[class电路连接相关属性总线信号的变化CMD线的数据传输]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>SD</tag>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等待队列]]></title>
    <url>%2Fpost%2F36894.html</url>
    <content type="text"><![CDATA[等待队列由循环链表实现，其元素包括指向进程描述符的指针。每个等待队列都有一个等待队列头(wait queue head),等待队列头是一个类型为wait_queue_head_t的数据结构 用途]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sd卡测速]]></title>
    <url>%2Fpost%2F11560.html</url>
    <content type="text"><![CDATA[测试sd卡的读写速度 mmc驱动测速结合mmc子系统提供的测试列表进行速度测试和其他相关测试。 添加配置123-&gt;DeviceDriver -&gt; MMC/SD/SDIO card support (MMC [=y]) [*]MMC host test driver 绑定编译并启动新编译的linux内核，进入文件系统。 进入mmcblk解除绑定 12cd sys/bus/mmc/drivers/mmcblkecho mmc0:e624 &gt; unbind 绑定测试 123cd sys/bus/mmc/drivers/mmc_testecho mmc0:e624 &gt; bind[ 17.243808] mmc_test mmc0:e624: Card claimed for testing. 挂载debugfs1# mount -t debugfs none /mnt 测试 进入测试目录mmc0:e624 1cd /mnt/mmc0/mmc0:e624 查看测试列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#cat testlist 1: Basic write (no data verification) 2: Basic read (no data verification) 3: Basic write (with data verification) 4: Basic read (with data verification) 5: Multi-block write 6: Multi-block read 7: Power of two block writes 8: Power of two block reads 9: Weird sized block writes 10: Weird sized block reads 11: Badly aligned write 12: Badly aligned read 13: Badly aligned multi-block write 14: Badly aligned multi-block read 15: Correct xfer_size at write (start failure) 16: Correct xfer_size at read (start failure) 17: Correct xfer_size at write (midway failure) 18: Correct xfer_size at read (midway failure) 19: Highmem write 20: Highmem read 21: Multi-block highmem write 22: Multi-block highmem read 23: Best-case read performance 24: Best-case write performance 25: Best-case read performance into scattered pages 26: Best-case write performance from scattered pages 27: Single read performance by transfer size 28: Single write performance by transfer size 29: Single trim performance by transfer size 30: Consecutive read performance by transfer size 31: Consecutive write performance by transfer size 32: Consecutive trim performance by transfer size 33: Random read performance by transfer size 34: Random write performance by transfer size 35: Large sequential read into scattered pages 36: Large sequential write from scattered pages 37: Write performance with blocking req 4k to 4MB 38: Write performance with non-blocking req 4k to 4MB 39: Read performance with blocking req 4k to 4MB 40: Read performance with non-blocking req 4k to 4MB 41: Write performance blocking req 1 to 512 sg elems 42: Write performance non-blocking req 1 to 512 sg elems 43: Read performance blocking req 1 to 512 sg elems 44: Read performance non-blocking req 1 to 512 sg elems 45: eMMC hardware reset 执行测试 1echo 34 &gt; test 测试命令 dd1dd if=/dev/zero of=/dev/null 输入或输出 dd if=[STDIN] of=[STDOUT] 强迫输入或输出的Size为多少Bytes bs: dd -ibs=[BYTE] -obs=[SIZE] 强迫一次只做多少个 Bytes bs=BYTES 跳过一段以后才输出 seek=BLOCKS 跳过一段以后才输入 skip=BLOCKS 写测试1dd if=/dev/zero of=/mnt/sd/test.txt bs=512 count=100 写数据量：512*100 / 1024 = 50Kb 读测试1dd if=/mnt/sd/test.txt of=/dev/null bs=512 count=100 读数据量：512*100 / 1024 = 50Kb PC测试在pc上使用以上命令，将读写的目标改为（/dev/sdb）即可得到当前的读写速度 开发板测试由于在开发板中的文件系统使用busybox编译生成，其中的dd命令无法直接得到读写速度，因此需要结合time命令 写测试1time dd if=/dev/zero of=/mnt/sd/test.txt bs=512 count=100 写数据量：512*100 / 1024 = 50Kb 读测试1time dd if=/mnt/sd/test.txt of=/dev/null bs=512 count=100 读数据量：512*100 / 1024 = 50Kb 注意事项 在对sd进行测速时，使用以上命令进行读写操作，文件系统会将该数据块进行一定大小（128个block为一个单元，即一个request请求）的分割，并将其传入sd驱动。在mmc驱动中配置msc控制器的block count大小时，其值为VFS层传入的128blk。 也就是说一个大于128个block数据块的读写，在mmc驱动中使用若干个request请求进行读写操作完成。 写测试增加conv=fsync参数 该参数可通过dd -h查看，作用将写的数据完全写入到sd完成返回，但是使用后根据写操作所得到的时间计算的写速度将降低主要原因是，使用fsync后文件系统会将写的数据块根据bs的大小进行分割，也就是将其分割成count个bs。如果bs为512时，一次request请求的block count为512，加大了request请求次数，同时将增加sd驱动中的中断次数和读及等状态的次数，继而增大了写操作的时间，最后计算的写速度将降低。 总结读写速率和以下情况有关： 外部通信时钟； DDR时钟， 代码运行速率，和CPU时钟、L2CACHE时钟有关 当前系统负荷 内部的总线时钟，比如MMC控制器所在的APB总线等 MMC控制器的DMA工作时钟 读写代码的流程 MSC的通信数据线的位数 读写的位置是否连续。 其中瓶颈是在（1）SD的通信速率（7）代码的流程（8）SD卡通信所占用的数据线（9）读写的位置是否连续]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>MMC</tag>
        <tag>SD</tag>
        <tag>dd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作]]></title>
    <url>%2Fpost%2F53101.html</url>
    <content type="text"><![CDATA[记录平时对git的使用方法和技巧 1. 创建本地git库mkdir test.git 进入test.git git init --bare --shared 2. 创建分支git branch branch_name 删除本地分支： git branch -d branch_name 3. 切换分支git checkout branch_name 4. 下载git clone URL 5. 日志git commit 6. 提交git push 远程库名 分支名 7. 更新git pull 远程库名 分支名 8.添加代码git add &lt;filename&gt; git add -A #添加所有修改 9.查看日志git log git log -n #查看前n条日志 git log --stat #查看日志的修改情况 git log -p #查看日志的具体修改 git log &lt;filename/dirname&gt; #查看该文件或目录的修改日志 tig 命令行下查看git历史提交记录的工具 10.回退git reset HEAD &lt;filename&gt; #将该文件从缓冲区撤回 11.查看远程库git remote -v 添加远程库： git remote add &lt;name&gt; &lt;url&gt; 12.获取远程库中的最新版本，但与git pull 不同它不会mergegit fetch 远程库名 分支名 作用：可以对比远程库与当前本地的差异。 13.查看标签git tag 作用：一个稳定的版本或者完成一个功能，为了发布或者保存而打的标签，主要是发布 14.切换标签git checkout &lt;Tag&gt; 15.暂存当前改动1git stash 保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save ‘message…’可以添加一些注释 1git stash list 显示保存进度的列表。也就意味着，git stash命令可以多次执行。 1git stash pop [–index] [stash_id] git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。 1git stash apply [–index] [stash_id] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 1git stash drop [stash_id] 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。 1git stash clear 删除所有存储的进度。 16.恢复本地错误操作1git reflog 查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） 12$git reflog -husage: git reflog [ show | expire | delete ] show: 显示所有条目,缺省值 expire: 删除掉更老的reflog条目 delete: 从reflog中删除一个条目 17.模块管理 添加模块 1git submodule add projectB.git projectB 使用子模块 12git submodule initgit submodule update 克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行此命令完成子模块的下载 在clone整个项目时添加递归参数:--recurse-submodules 删除子模块 rm -rf 子模块目录 删除子模块目录及源码 vi .gitmodules 删除项目目录下.gitmodules文件中子模块相关条目 vi .git/config 删除配置项中子模块相关条目 rm .git/module/* 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可 执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下：1git rm --cached 子模块名称 18.commit统计可以大致了解一下每个人对这个项目提交的commit数量和大致的贡献度 1git summary DoTo Git 最佳实践：分支管理]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arm交叉编译工具]]></title>
    <url>%2Fpost%2F64642.html</url>
    <content type="text"><![CDATA[编译工具命名规则 交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi] arch - 体系架构，如ARM，MIPS vendor - 工具链提供商 os - 目标操作系统 eabi - 嵌入式应用二进制接口（Embedded Application Binary Interface） 根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如 arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork(2)。他使用的是newlib这个专用于嵌入式系统的C库。arm-none-linux-eabi：用于Linux的，使用Glibc 示例arm-none-eabi-gcc（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用，所以不支持那些跟操作系统关系密切的函数，比如fork(2)，他使用的是 newlib 这个专用于嵌入式系统的C库。 arm-none-linux-gnueabi-gcc(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。arm-none-linux-gnueabi基于GCC，使用Glibc库，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。 下载arm-none-eabi-gcc地址：https://launchpad.net/gcc-arm-embedded注:在a8中使用该编译工具（gcc-arm-none-eabi-5_4-2016q2），编译uboot在uboot启动时，对nand进行初始化无法成功。 arm-none-linux-gnueabi-gccMentor官方下载地址（需要注册，注册之后官方会发送一个下载地址到邮箱里面）地址：http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/evaluations网盘下载：http://www.veryarm.com/arm-none-linux-gnueabi-gcc]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>交叉编译工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cortex-A8平台实验]]></title>
    <url>%2Fpost%2F36419.html</url>
    <content type="text"><![CDATA[毕业的时候有把A8板子拿了过来，之前由于没有源程序（光盘丢失找不到资料）对它的开发和实验都一直没有做过，它上面的资源很多不想让它就静静的放着浪费。虽然已经很久没有接触ARM平台了，但是它与MIPS的上层基本原理相似，所以最近想倒腾它，希望可以把linux系统跑起来，也不枉失去它在我手中的价值嘿嘿嘿。在这里简单记录实验的过程和中间的少许思考吧。 实验环境： 开发板：Cortex-A8 开发系统：Linux machine 4.2.0-27-generic #32~14.04.1-Ubuntu SMP uboot：u-boot-2016-07 uboot：u-boot-v2014.07-rc4 linux：linux-4.0.9 文件系统：buildroot 在实际的操作中可能会有所变动，不断更新 DebugCode 交叉编译工具作为嵌入式开发交叉编译工具链是必不可少的，主要是为了在宿主机（PC）上，开发目标机（arm开发板）中可以运行的程序。 下载这里选择gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2 配置由于PC中从在多个交叉编译工具链，这里采用脚本envsetup.sh设置，每进入一个终端需要运行其脚本进行配置，方可使用该编译工具链。12345678910#!/bin/bashMY_PWD=`pwd`PATH=$PATH:$MY_PWD/gcc-arm-none-eabi-5_4-2016q2/bin CROSS_COMPILE=arm-none-eabi-export PATH CROSS_COMPILEecho $PATHecho $CROSS_COMPILE 设置：1source envsetup.sh uboot移植编译 查找Cortex-A8相关的README，进行参考，全局搜索 1grep "Cortex-A8" . -rn ./doc/README.s5pc1xx中有Cortex-A8的相关说明，结合该文档进行最初的编译。 2. 根据README.s5pc1xx的步骤配置编译 将出现以下错误： lib/asm-offsets.c:1:0: error: bad value (armv5) for -march= switch 出现这个错误的原因是我们没有为uboot指定交叉编译工具链，它依然用自己默认的gcc进行编译，有怎么会找到armv5呢。 3. 指定交叉编译工具链12CROSS_COMPILE=arm-none-eabi-export CROSS_COMPILE 为了以后方便使用可将以上两句命令添加到envsetup.sh脚本中。参考：./README — 4963 Building the Software: 改变uboot版本 最新的uboot采用图形界面的配置方式及增加了设备树的配置，由于对这两方面都不太了解尤其设备树，根据自己比较熟悉的使用方式，选择u-boot-v2014.07-rc4。设备树等uboot可以正常启动后在深入学习添加。 选择默认配置编译 选择配置 根据README在boards.cfg选择smdkc100，后续在此基础上进行移植 指定编译器 根据上文（3. 指定交叉编译工具链）即可 编译 12make smdkc100_configmake 顺利编译通过，接下来将添加spl和uboot 添加自己配置 添加配置文件s5pv210.h cp include/configs/smdkc100.h include/configs/s5pv210.h 添加编译配置boards.cfg Active arm armv7 s5pc1xx samsung smdkc100 s5pv210 Winddoing &lt;winddoing@sina.cn&gt; 添加SPL阶段在uboot中SPL阶段的控制是通过spl/Makefile中的CONFIG_SPL_BUILD宏控制 使用最新的uboot环境 指定编译工具链 1export CROSS_COMPILE 使用相关配置测试工具链 12$make s5pc210_universal_defconfig$make -j12 添加自定义配置在s5pc210_universal_defconfig配置基础上修改。 添加配置文件 拷贝现有相关配置12$cp include/configs/s5pc210_universal.h include/configs/s5pc210_a8.h$cp configs/s5pc210_universal_defconfig configs/s5pc210_a8_defconfig 2.添加板级123board/samsung/cortex-a8/configs/s5pc210_a8_defconfiginclude/configs/s5pc210_a8.h 添加SPL错误123456./tools/mkexynosspl spl/u-boot-spl.bin spl/qt210-spl.binmake[1]: ./tools/mkexynosspl: Command not foundscripts/Makefile.spl:283: recipe for target &apos;spl/qt210-spl.bin&apos; failedmake[1]: *** [spl/qt210-spl.bin] Error 127Makefile:1508: recipe for target &apos;spl/u-boot-spl&apos; failedmake: *** [spl/u-boot-spl] Error 2 这是个可执行文件是在make时自动增加头信息用的 参考 【u-boot-2016到s5pv210】1.1 自定义板卡ok210 u-boot-2016.09移植(3)-u-boot-spl.bin u-boot-2016.11移植uboot-spl.bin u-boot v2018.01 启动流程分析 参考 S5PV210开发版配置]]></content>
      <categories>
        <category>Cortex-A8</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>Cortex-A8</tag>
        <tag>uboot</tag>
        <tag>linux</tag>
        <tag>bulidroot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】python练习项目]]></title>
    <url>%2Fpost%2F9636.html</url>
    <content type="text"><![CDATA[转载再次，自己实现练习python本书链接 http://aosabook.org/blog/目录页：http://aosabook.org/blog/以下是章节目录，每一章都让你热血澎湃，看完介绍你就向往下读。 A Template Engine （http://aosabook.org/en/500L/a-template-engine.html）MVC模型中的view层如何解析html中的静态变量和简单的语句，如下： Welcome, {name}! Products: {products} web中的view层不只是html代码，还有支持其他的代码。比如 {products}是一个变量。 同时view层还支持{if} , {for}, {foreach}等等。django，velocity等是如何解析他们的？大牛用不到500行代码告诉你，是如何实现的？ （不是替换，替换需要每次请求都需要解析） Web Spreadsheet （http://aosabook.org/en/500L/web-spreadsheet.html）web的电子表格如何实现的？ 好像比较简单，但是介绍了 web storage 和 web worker，还是很值得一看的 A Web Crawler http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html不多说，几百行代码实现高效的网络爬虫， 高效！ Static Analysis http://aosabook.org/en/500L/static-analysis.html成熟的IDE都有代码检查和代码提示，怎么做的？ 看这章 Clustering by Consensus http://aosabook.org/en/500L/clustering-by-consensus.html分布式系统 paxos原理与实现。不知道paxos说明你没接触过分布式体统，接触过分布式还不懂，说明你只会用分布式系统 A Simple Object Modle http://aosabook.org/en/500L/a-simple-object-model.htmlPython是面向对象语言，对象，继承，多态，怎么用代码实现的，不到500行代码，实际不到400 行， 666.。。 An Archaeology-Inspired Database http://aosabook.org/en/500L/an-archaeology-inspired-database.html如何用python实现一个数据库，支持 query，index, transaction， 2，3百行代码和对每个函数的讲解。看完你就知道知道数据库原理，太值了 Dog Bed Database http://aosabook.org/en/500L/dbdb-dog-bed-database.html类似上一章，不过这次实现的是key-value的非关系型数据库，详细的讲解和2，3百行代码 A 3D Modeller http://aosabook.org/en/500L/a-3d-modeller.html用python实现一个3D设计，显示到屏幕，可以交互。不是很懂，但不明觉厉 A Python Interpreter Written in Python http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html手把手教你如何实现python解析器。 A Pedometer in the Real World http://aosabook.org/en/500L/a-pedometer-in-the-real-world.html你用过手机应用记录你每天走的步数，然后发送到朋友圈吗？ （没有？ 没关系。）这章告诉你如何实现步数记录，怎么算走一步。手机中有加速记，很容易获得你某一时刻在x,y,z三个方向的加速度，用这些参数，如何计算你走了多少步？ 知道吗？ 不知道，看这章，讲解加实现 A Continuous Intergration System http://aosabook.org/en/500L/a-continuous-integration-system.htmlCI System是一个专门用来测试新代码的系统，根据代码提交记录，拿到新的代码，测试，生成报告。这不是关键，关键是 如果test失败，它还会 恢复，然后从失败的那个点在跑，相当于把出错环境重现了。。。 13 A Rejection Sampler http://aosabook.org/en/500L/a-rejection-sampler.html不是很懂，和机器学习相关，如何 计算你赢得象棋比赛的概率，天气对飞机的影响等类似的问题 14 A visual programming toolkit http://aosabook.org/en/500L/blockcode-a-visual-programming-toolkit.html不太明白 A Flow Shop Scheduler http://aosabook.org/en/500L/a-flow-shop-scheduler.htmlflowshop调度问题，好像很出名的样子，最优化问题，如何从局部最优解找全局最优解 16 Optical Character Recognition几百行代码使用人工神经网络实现识别手写字母。。。 github源码：500lines/README.md at master · aosabook/500lines · GitHub 作者：小小搬运工链接：http://www.zhihu.com/question/29372574/answer/88624507来源：知乎著作权归作者所有，转载请联系作者获得授权。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块设备驱动]]></title>
    <url>%2Fpost%2F51792.html</url>
    <content type="text"><![CDATA[块设备传输数据的固定长度为一个sector,因此，输入、输出调度器和块设备的驱动必须管理扇区的数据。虚拟文件系统-&gt;磁盘设备的中间映射层，它使用一种逻辑单元来管理磁盘数据，这种逻辑单元被称之为“Block”,一个块相当于一个文件系统里面的最小磁盘存储单元。 块设备 块设备（blockdevice） 是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，他使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。 字符设备（Character device） 是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写是实时的。 块设备的驱动框架 块设备的应用在Linux中是一个完整的子系统。 在Linux中，驱动对块设备的输入或输出(I/O)操作，都会向块设备发出一个请求，在驱动中用request结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些I/O请求添加到队列中（即：请求队列），在驱动中用request_queue结构体描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的I/O调度程序子系统来负责提交 I/O 请求， 调度程序将磁盘资源分配给系统中所有挂起的块 I/O 请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候派发请求到设备。 由通用块层(Generic Block Layer)负责维持一个I/O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，通常用一个bio结构体来对应一个I/O请求。 Linux提供了一个gendisk数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是block_device_operations结构体。 当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I/O请求并将请求排序，然后，将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管），对I/O请求排序的算法称为电梯算法（elevator algorithm）。电梯算法在I/O调度层完成。内核提供了不同类型的电梯算法. 电梯算法1 noop（实现简单的FIFO，基本的直接合并与排序）,2 anticipatory（延迟I/O请求，进行临界区的优化排序），3 Deadline（针对anticipatory缺点进行改善，降低延迟时间）,4 Cfq（均匀分配I/O带宽，公平机制）PS：其实IO调度层（包括请求合并排序算法）是不需要用户管的，内核已经做好 相关数据结构block_device: 描述一个分区或整个磁盘对内核的一个块设备实例gendisk: 描述一个通用硬盘（generic hard disk）对象。hd_struct: 描述分区应有的分区信息bio: 描述块数据传送时怎样完成填充或读取块给driverrequest: 描述向内核请求一个列表准备做队列处理。request_queue: 描述内核申请request资源建立请求链表并填写BIO形成队列。 驱动的实现]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>块设备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核中驱动注册的先后顺序]]></title>
    <url>%2Fpost%2F47803.html</url>
    <content type="text"></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MMC子系统]]></title>
    <url>%2Fpost%2F24681.html</url>
    <content type="text"><![CDATA[MMC子系统系统框架： Linux MMC子系统主要分成三个部分： MMC核心层：完成不同协议和规范的实现，为host层和设备驱动层提供接口函数。MMC核心层由三个部分组成：MMC，SD和SDIO，分别为三类设备驱动提供接口函数； Host 驱动层：针对不同主机端的SDHC、MMC控制器的驱动； Client 驱动层：针对不同客户端的设备驱动程序。如SD卡、T-flash卡、SDIO接口的GPS和wi-fi等设备驱动。 代码结构1234.├── card├── core└── host MMC子系统代码主要在drivers/mmc目录下，共有三个目录： Card：与块设备调用相关驱动，如MMC/SD卡设备驱动，SDIOUART； Core：整个MMC的核心层，这部分完成不同协议和规范的实现，为host层和设备驱动层提供接口函数。 Host：针对不同主机端的SDHC、MMC控制器的驱动，这部分需要由驱动工程师来完成； 注册流程在linux系统中，系统启动时将加载相关配置的驱动模块，而各模块的加载将通过各自之间相应的结构关系进行先后顺序进行设备注册，下面是mmc子系统的注册流程 core —&gt; host —&gt; card core层的注册主要创建两条虚拟总线mmc_bus和sdio_bus，为host层 host注册主要为相关控制器的初始化及配置参数 card层主要用于与block设备进行绑定，为数据读写准备 MMC控制器驱动的软件框架在这里主要以符合sdhci标准的mmc控制器为例，结合sdhci驱动说明mmc的工作流程。 驱动的总体框架： 数据结构mmc子系统是将msc（mobile storage controller）控制器及其该控制器适配的相关外设中的细节屏蔽掉而抽象出来的一种框架。主要将控制器和卡抽象成为不同的结构mmc_host和mmc_card. mmc_host 该结构体主要为msc控制器所抽象化的一个对象，用于对当前控制器的描述。12345678910111213141516struct mmc_host &#123;struct device *parent;struct device class_dev;int index;const struct mmc_host_ops *ops;struct mmc_ios ios; /* current io bus settings */struct mmc_card *card; /* device attached to this host */const struct mmc_bus_ops *bus_ops; /* current bus driver */ . . .unsigned long private[0] ____cacheline_aligned;&#125;; 以上为该结构体的主要成员（由于成员变量过多省略部分） struct mmc_host_ops *ops 该接口主要为控制器的操作函数，用于控制器各种行为的控制，由于不同的控制器的设计和使用流程不同，mmc子系统将控制器的实际操作抽象出来，为驱动开发人员，根据实际要求进行功能实现。主要功能： 1）request 为mmc子系统中的request请求进行数据处理，其中包含对cmd命令的发送和data数据的传输（PIO，DMA） 2）set_ios 主要设置控制器的各种参数，包括时钟，电压，总线宽度及驱动类型（驱动类型跟卡自身的属性相关）等。 3）get_sd 主要由于对卡的探测，实现热插拔功能（一般可能过gpio中断实现） struct mmc_bus_ops 主要为mmc子系统中的一条虚拟总线的操作接口函数，该接口的实现由mmc子系统自己完成。 struct mmc_ios ios 主要为当前总线的设置参数，该总线指控制器和卡实际相接的数据线（cmd，lck，data），主要参数包含set_ios所设置的时钟，电压，总线宽度及驱动类型（驱动类型跟卡自身的属性相关）等参数。 mmc_card 主要是与msc控制相连的相关卡的抽象对象，其中主要描述了卡自身的一些属性 初始化控制器数据读写在mmc驱动的核心是数据的读写，根据sd协议数据的读写流程基本一致。 cmd + datacmd_line 先发送读写命令data_line 进行数据传输 读流程数据读命令:CMD17和CMD18（single block和multiple block）注:多个block和多根数据线读，流程基本一致，主要是在数据传输时，将读的数据分配给了4根数据线。 写流程数据读命令:CMD24和CMD25（single block和multiple block） 注： S: start 起始位[0] E: end 结束位[1] status 说明 “010” 数据被接受写入卡中 “101” 由于CRC错误，数据不被卡接受 “110” 由于写错误，数据不被卡接受 在写的过程中由于控制器需要等到卡将数据全部写完，才视一次传输完成。而在卡写的过程中，只有数据完全写入后，标志数据传输完成的busy位才会返回。同时返回的还有此次写数据后的状态status(CRC校验值)。如果CRC的校验值大于”010”,将代表数据传输失败（如果status为“101”， 表示写数据出现CRC错误） mmc中的request处理在mmc子系统中将msc控制器和卡初始化完成后，进入数据传输阶段。在此阶段主要维护一个属于当前控制器的一个线程kthread_run(mmc_queue_thread, mq, “mmcqd/%d%s”,host-&gt;index, subname ? subname : “”)，mmc_queue_thread线程在一个while(1)循环中现实对block层的request请求队列的数据处理。 维护mmc_queue_thread线程状态 进入该线程将其设置为set_current_state(TASK_INTERRUPTIBLE) 处理request请求数据，set_current_state(TASK_RUNNING) 数据处理完毕后，如果没有需要处理的数据，调用schedule() Block层的request请求队列请求队列的组成方式：具体的实现方式在block设备驱动继续。 request请求队列的处理 通过blk_fetch_request(q)从request请求队列中取出一个request请求。 如果request请求队列中有需要处理的数据，调用issue_fn(mq, req)的回调函数进行数据处理。 一个request请求的处理流程这里以multiple block的读写为例进行说明： 写数据的处理在一个写操作中的request基本可以分为三类: a. 使用写命令CMD25写1024block的数据写操作 b. 先进行数据同步操作，接着使用cmd13获取卡的状态,判断没有错误后,再使用CMD25写1024block数据 c. 先进行数据同步操作，再单独发送cmd13命令检测卡的状态 注: 一次request请求所传输的数据量有block层设置.在注册card层初始化mmc_queue时,根据block的设置进行配置.mmc_blk_probe-&gt;mmc_blk_alloc-&gt;mmc_blk_alloc_req-&gt;mmc_init_queue-&gt;blk_queue_max_hw_sectors-&gt;blk_limits_max_hw_sectors-&gt;BLK_DEF_MAX_SECTORS=1024 读数据的处理在进行读操作时的request,分为两类: a. 携带数据和读命令的request， 及CMD18 + data（512block） b. 进行数据同步的request 总结附：相关简写 mmcmmc（Multi-Media Card）主要指mmc子系统 sdsd（Secure Digital）拥有两层含义：一种指sd卡，另一种指sd卡协议 emmcemmc（Embedded Multi Media Card)）同样一种指emmc卡，另一种指emmc协议，该卡的主要存储介质为nand flash，因此也称e-nand3.sdiosdio（Secure Digital Input and Output Card）一种在sd标准上定义的外设接口。不过其有自己的特有协议标准。主要由于sdio接口的wifi，蓝牙等]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>MMC</tag>
        <tag>SD</tag>
        <tag>EMMC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2Fpost%2F22648.html</url>
    <content type="text"><![CDATA[在这里主要记录makedown的使用语法，以备后续写作时的不时之需。 Atom 插件123atom-hexomarkdown-scroll-syncmarkdown-writer Markdown语法 分段： 两个回车 换行 两个空格 + 回车 标题 # ~ ###### 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题 引用 &gt; 列表 * ， + ， - ， 1.选其中之一，注意后面有个空格 代码区块 四个空格 开头 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，图片地址可以是本地路劲，也可以是网络地址 强调 **文字** ， __文字__ 删除线：~~xxxx~~ 代码: 三个点 待办事宜 - [ ] 表示未完成和- [x] 表示已完成 [ ] 表示未完成 [x] 表示已完成 段落缩进 &amp;ensp;&amp;ensp;（两个空格） 流程图 操作模块 说明 start` 开始 end 结束 opration 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 1234567891011121314&apos;&apos;&apos; flow//定义部分st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...//判断和位置控制st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1&apos;&apos;&apos; st 是变量名， start 是指操作模块名，冒号后面就是内容了。需要注意的是，冒号后要加空格才能识别 时序图 12345&apos;&apos;&apos;sequenceAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!&apos;&apos;&apos; Atom和Makedown预览 命令：ctrl + shift + p 输入 markdown preview toggle(可以偷懒只输入mdpt，跟Sublime Text一样支持模糊匹配)//定义部分 st=>start: Start:>http://www.google.com[blank] e=>end:>http://www.google.com op1=>operation: My Operation sub1=>subroutine: My Subroutine cond=>condition: Yes or No?:>http://www.google.com io=>inputoutput: catch something... //判断和位置控制 st->op1->cond cond(yes)->io->e cond(no)->sub1(right)->op1{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2Fpost%2F27055.html</url>
    <content type="text"><![CDATA[union1234567891011121314151617#include&lt;stdio.h&gt;union aa&#123; int i; char a[2];&#125;;int main()&#123; union aa b; b.i = 0; //初始化内存空间，如果不清最后的b.i为随机值 b.a[0] = 10; b.a[1] = 1; printf("%d\n", b.i); printf("%d\n", (1 &lt;&lt; 8) | (10)); return 0;&#125; 结果： 266(256+10) union 类型的特点是不同类型的数据共享同一段内存，union 结构体的大小为其所含占内存最大成员大小，但在同一时刻只能有一类成员存储于其中 计算机存储的大小端不同，最后的输出结果不一定。 大小端 Little endian和Big endian是CPU存放数据的两种不同顺序 Big endian第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节） Little endian第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节） 共同体所有数据共用同一块地址空间 123456789101112131415161718#include &lt;stdio.h&gt;union aa&#123; int i; char j;&#125;;int main()&#123; union aa a; a.i = 1; if ( a.j == 1 ) printf("little-endian\n"); else printf("big-endian\n"); return 0;&#125; 指针强制类型转换 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a = 1; char * p = (char*)&amp;a; if (*p == 1) printf("little-endian\n"); else printf("big-endian\n"); return 0;&#125; 内存对齐 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值 指定对齐值：#pragma pack (value)时的指定对齐值value。 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值} 1234567891011121314151617struct std1&#123; int a; //4 char b; //1 //占空3 float c; //4 char d; //1 //占空3 double e; //8&#125;sizeof(std1) = 24struct std2&#123; char c; //1 //占空1 short s; //2&#125;;sizeof(std2) = 4 数据类型123456789#include &lt;stdio.h&gt;int main()&#123; int *p = 0; p += 6; /*累加的是p指针类型的宽度(4*6)*/ printf("%p\n", p); return 0;&#125; 输出： 0x18[24] 进程间通信 管道 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点 共享内存 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。 socket 信号（sinal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 进程间通信的方式——信号、管道、消息队列、共享内存 字符串反转123456789101112131415char* revstr(char *str)&#123; char *start = str; char *end = str + strlen(str) - 1; char ch; if (str != NULL) &#123; while (start &lt; end) &#123; ch = *start; *start++ = *end; *end-- = ch; &#125; &#125; return str;&#125; 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int my_strlen(char *str)&#123; if(*str == '\0') return 0; else return my_strlen(str+1) + 1;&#125;void reverse_string(char *string)&#123; int len = my_strlen(string); if(len &lt;= 1) return ; else &#123; char temp = string[0]; string[0] = string[len-1]; string[len-1] = '\0'; reverse_string(string+1); string[len-1] = temp; &#125;&#125;int main() &#123; char ch[] = "abcdefghijklmno"; printf("0:%s\n",ch); reverse_string(ch); printf("1:%s\n",ch); return 0;&#125; 指针与引用 C++ 1234567891011121314151617#include &lt;stdio.h&gt;void change(int*a, int &amp;b, int c)&#123; c=*a; b=30; *a=20;&#125;int main()&#123; int a=10, b=20, c=30; /*指针与引用*/ change(&amp;a,b,c); printf("%d,%d,%d\n",a,b,c); return 0;&#125; 结果：20,30,30 123456789101112131415#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;void test(int &amp;a)&#123; cout&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;a&lt;&lt;endl&lt;&lt;endl;&#125;int main(void)&#123; int a=1; cout&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;a&lt;&lt;endl&lt;&lt;endl; test(a); return 0;&#125; 0x7fffc646494c 10x7fffc646494c 1 指针传递是一种值传递的方式，他传递的只是地址值，值传递的时候中我们可以知道被调函数的形参会被当做一个局部变量来出来，会在栈中去给其分配空间用 来存储主调函数传输过来的值，该值只不过是主调函数中实参值的一个拷贝，所以在被调函数中去修改传输过来的值并不会去影响主调函数中的实参值。 引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。 指针是一个实体，而引用仅是个别名； 引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。 可以有const指针，但是没有const引用； 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的） 指针和引用的自增(++)运算意义不一样； 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏； 指针与数组关键字static 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变， 内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在） 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 关键字const 左数右指 12345const int a; //a：只读int const a; //a：只读const int *a; //"左"，指针a，数据不能变，数据只读int * const a; //"右"，指针a，指针不能变，地址只读int const * a const; //数据指针均只读 关键字const的 作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。 通过给编译器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。 关键字volatile 并行设备的硬件寄存器（如：状态寄存器），防止编译器的优化 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量 float类型和0比较大小12const float EPSINON= 0.00001;if((x &gt;= -EPSINON) &amp;&amp; (x &lt;= EPSINON))&gt;)) 不能直接用float类型的值与0进行“==”或“!=”比较 标准C语言中:单精度float浮点格式的符号位=1，有效位=23，指数未=8，产生一个32位的表示。双精度double浮点格式的符号位=1，有效位=52，指数位=11，产生一个64位的表示。 转成数值即为:V=(-1)^S 1.M 2^(E-127) 对于16.5转成二进制为00010000.1==&gt;1.00001*2^4,那么在内存的表示为:符号位 指数4+127 = 131 尾数0 10000011 00001 000000000000000000 在转换过程中由于需要往右移位, 可见对于float数整数部分越大,小数部分的精度就越低对float数来说有效数字约为7位(2^23约等于10^7),所以整数部分占的位数越多,小数部分的精度就越低,当整数部分超过9999999后小数部分已经完全无精度了 链表二分查找B-树(B+树)红黑树和AVL树参考 传指针和传指针引用的区别/指针和引用的区别（本质） C语言中static变量详解]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example]]></title>
    <url>%2Fpost%2F10323.html</url>
    <content type="text"><![CDATA[TestThis is a test page! 站点构建：C12345678#include &lt;stdio.h&gt;int main()&#123; printf("Hello World!\n"); return 0;&#125; shell1$ pwd 站点设置配置：图标选择：]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Travis-CI</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的shell命令]]></title>
    <url>%2Fpost%2F1644.html</url>
    <content type="text"><![CDATA[常用的shell命令： find, cat find1[root@linfeng etc]# find . -type f -name "*" | xargs grep "root/init.sh" -type f : 表示只找文件 -name &quot;xxx&quot; : 表示查找特定文件；也可以不写，表示找所有文件 批量修改文件名后缀 mv ./htxynl.f90 ./htxynl.f77 1find . -name &quot;*.f90&quot; | awk -F &quot;.&quot; &apos;&#123;print $2&#125;&apos; | xargs -i -t mv .&#123;&#125;.f90 .&#123;&#125;.f77 cat cat和重定向进行写文件操作 123=====&gt;$cat &gt; test.sh &lt;&lt; EOF&gt; this is test&gt; &gt; EOF &gt; : 以覆盖文件内容的方式，若此文件不存在，则创建 &gt;&gt; : 以追加的方式写入文件 tee1make USE_NINJA=false USE_CLANG_PLATFORM_BUILD=false 2&gt;&amp;1 | tee build.log ssh跨服务器拷贝文件12345xbin="u-boot-with-spl-mbr-gpt.bin"xdst="user@192.168.10.44:/home/user/x2000_ddr_test"scp $xbin fpga@192.168.4.13:/tmp/$xbinssh fpga@192.168.4.13 "scp /tmp/$xbin $xdst" ssh的key值 权限必须是600 1chmod 600 ~/.ssh/authorized_keys 添加key值 1ssh-add ~/.ssh/authorized_keys 查看生效key值 1ssh-add -l 测试key值 1ssh -T git@github.com 免密登录 1ssh-copy-id ssh name@ip 使用多个key值 man ssh_config 1cp /etc/ssh/ssh_config ~/.ssh/config 编辑~/.ssh/config12345678...# StrictHostKeyChecking ask IdentityFile ~/.ssh/id_rsa IdentityFile ~/.ssh/xxxx# IdentityFile ~/.ssh/id_dsa# IdentityFile ~/.ssh/id_ecdsa# IdentityFile ~/.ssh/id_ed25519... tftp 开发板（busybox） 1tftp -g -r user/xxxx/system.tar 192.168.4.13 tftp的服务器(PC): 123456# /etc/default/tftpd-hpaTFTP_USERNAME="tftp"TFTP_DIRECTORY="/home/"TFTP_ADDRESS="0.0.0.0:69"TFTP_OPTIONS="--secure" file: /etc/default/tftpd-hpa cpio 解压，制作 ramdisk 解压1234gunzip rootfs.cpio.gzmkdir tmpcd tmpcpio -i -F ../rootfs.cpio code: unzip_ramdisk.sh 制作1find . | cpio -o -Hnewc |gzip -9 &gt; ../image.cpio.gz -H: 选项指定打包文件的具体格式，要生成init ramfs，只能用newc格式 minicom记录串口的输出日志： 12345678910111213#!/bin/shmkdir ddecho "while [ 1 ];do killall minicom; sleep 36000;done" &gt; ./b.shchmod +x ./b.sh./b.sh &amp;while [ 1 ]do ff=`date +%Y%m%d%H%M`; echo $ff; minicom -w -C ./dd/$ff -o;done 串口输出增加时间戳： 1Ctrl + a ; n 串口打印内存信息： 1Ctrl + a; f; m Ctrl + a; f(send break)进行发送命令，m查看当前内存状态的命令 break signal m 查看当前内存状态的命令 内核提供接口drivers/tty/sysrq.c,通过按键的方式获取内核的调试信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static struct sysrq_key_op *sysrq_key_table[36] = &#123; &amp;sysrq_loglevel_op, /* 0 */ &amp;sysrq_loglevel_op, /* 1 */ &amp;sysrq_loglevel_op, /* 2 */ &amp;sysrq_loglevel_op, /* 3 */ &amp;sysrq_loglevel_op, /* 4 */ &amp;sysrq_loglevel_op, /* 5 */ &amp;sysrq_loglevel_op, /* 6 */ &amp;sysrq_loglevel_op, /* 7 */ &amp;sysrq_loglevel_op, /* 8 */ &amp;sysrq_loglevel_op, /* 9 */ /* * a: Don't use for system provided sysrqs, it is handled specially on * sparc and will never arrive. */ NULL, /* a */ &amp;sysrq_reboot_op, /* b */ &amp;sysrq_crash_op, /* c &amp; ibm_emac driver debug */ &amp;sysrq_showlocks_op, /* d */ &amp;sysrq_term_op, /* e */ &amp;sysrq_moom_op, /* f */ /* g: May be registered for the kernel debugger */ NULL, /* g */ NULL, /* h - reserved for help */ &amp;sysrq_kill_op, /* i */#ifdef CONFIG_BLOCK &amp;sysrq_thaw_op, /* j */#else NULL, /* j */#endif &amp;sysrq_SAK_op, /* k */#ifdef CONFIG_SMP &amp;sysrq_showallcpus_op, /* l */#else NULL, /* l */#endif &amp;sysrq_showmem_op, /* m */ &amp;sysrq_unrt_op, /* n */ /* o: This will often be registered as 'Off' at init time */ NULL, /* o */ &amp;sysrq_showregs_op, /* p */ &amp;sysrq_show_timers_op, /* q */ &amp;sysrq_unraw_op, /* r */ &amp;sysrq_sync_op, /* s */ &amp;sysrq_showstate_op, /* t */ &amp;sysrq_mountro_op, /* u */ /* v: May be registered for frame buffer console restore */ NULL, /* v */ &amp;sysrq_showstate_blocked_op, /* w */ /* x: May be registered on ppc/powerpc for xmon */ /* x: May be registered on sparc64 for global PMU dump */ NULL, /* x */ /* y: May be registered on sparc64 for global register dump */ NULL, /* y */ &amp;sysrq_ftrace_dump_op, /* z */&#125;; sshfs1sudo sshfs xxx@192.168.1.2:/home_back/xxx/work/aaa /home/user/aaa -o gid=1000,uid=1000,allow_other md5sum — 字符串12$echo -n '123456' | md5sume10adc3949ba59abbe56e057f20f883e - 查看硬盘型号和序列号1sudo hdparm -i /dev/sda 获取计算机硬件信息1sudo dmidecode dmidecode遵循SMBIOS/DMI标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。 格式化xml1xmllint --format run_xunit.xml 在vim中直接敲xml,进行格式化 tldr查找各种命令的常用例子 1sudo apt install tldr 123456789101112131415161718192021$tldr pspsInformation about running processes. - List all running processes: ps aux - List all running processes including the full command string: ps auxww - Search for a process that matches a string: ps aux | grep &#123;&#123;string&#125;&#125; - List all processes of the current user in extra full format: ps --user $(id -u) -F - List all processes of the current user as a tree: ps --user $(id -u) f - Get the parent pid of a process: ps -o ppid= -p &#123;&#123;pid&#125;&#125; 参考 minicom中文手册]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下字符串操作常用函数]]></title>
    <url>%2Fpost%2F43508.html</url>
    <content type="text"><![CDATA[字符串长度函数size_t strlen(const char *string); 不受限制的字符串函数char *strcpy(char *dst, const char *src); char *strcat(char *dst, const char *src); int strcmp(const char *s1, const char *s2); 字符串查找/* + 功能：查找字符串s中首次出现字符c的位置 + 说明：返回首次出现c的位置的指针，如果s中不存在c则返回NULL。 */ char *strchr(const char *str, int ch); //同上 char *strrchr(const char *str, int ch); 大小写字符转换函数int tolower(int ch); int toupper(int ch); 内存操作函数void *memcpy(void *dst, const void *src, size_t length); void *memmove(void *dst, const void *src, size_t length); void *memcmp(const void *a, const void *b, size_t length); void *memset(void *a, int ch, size_t length); 不断更新]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Micro2440数据传输--串口通信]]></title>
    <url>%2Fpost%2F15606.html</url>
    <content type="text"><![CDATA[这段时间经过这次对比赛的准备，使用到了串口通信。或许这是最简单的通信方式吧，想弄清楚简单的数据传输协议。比较经典的i2c、CAN等数据传输，到以后的usb、ZigBee的数据传输。在这里先聊一聊串口的数据传输。 在Micro2440开发板上进行串口通信，要做的第一步便是串口驱动。这次我的开发板已经移植好了串口驱动。我只需进行操作，这里简单记录串口的基本操作 收数据、发数据以后用起来也方便，驱动下次分析。 串口通信分类：同步串口通信（SPI）、异步串口通信（UART） 同步串行是指SPI（Serial Peripheral interface）的缩写，顾名思义就是串行外围设备接口。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息，TRM450是SPI接口。 异步串行是指UART（Universal Asynchronous Receiver/Transmitter），通用异步接收/发送。UART是一个并行输入成为串行输出的芯片，通常集成在主板上。UART包含TTL电平的串口和RS232电平的串口。 TTL电平是3.3V的，而RS232是负逻辑电平，它定义+5~+12V为低电平，而-12~-5V为高电平，MDS2710、MDS SD4、EL805等是RS232接口，EL806有TTL接口。 串口数据传输的特点1.传输速度慢，数据量不大，数据一位一位的顺序传输 2.支持双向通信，只需一对数据线,也可以一根单向通信 TXD ---------&gt; RXD RXD &lt;--------- TXD GND &lt;--------&gt; GND 串口的参数配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137int set_opt(int fd, int nSpeed, int nBits, char nEvent, int nStop) &#123; struct termios newtio; struct termios oldtio; if(tcgetattr(fd,&amp;oldtio) != 0) &#123; perror(&quot;SetupSerial 2&quot;); return -1; &#125; bzero(&amp;newtio,sizeof(newtio)); newtio.c_cflag |= CLOCAL |CREAD; newtio.c_cflag &amp;= ~CSIZE; switch(nBits) &#123; case 7: newtio.c_cflag |= CS7; break; case 8: newtio.c_cflag |= CS8; break; &#125; switch(nEvent) &#123; case &apos;O&apos;: newtio.c_cflag |= PARENB; newtio.c_cflag |= PARODD; newtio.c_iflag |= (INPCK | ISTRIP); break; case &apos;E&apos;: newtio.c_iflag |= (INPCK |ISTRIP); newtio.c_cflag |= PARENB; newtio.c_cflag &amp;= ~PARODD; break; case &apos;N&apos;: newtio.c_cflag &amp;= ~PARENB; break; &#125; switch(nSpeed) &#123; case 2400: cfsetispeed(&amp;newtio,B2400); cfsetospeed(&amp;newtio,B2400); break; case 4800: cfsetispeed(&amp;newtio,B4800); cfsetospeed(&amp;newtio,B4800); break; case 9600: cfsetispeed(&amp;newtio,B9600); cfsetospeed(&amp;newtio,B9600); break; case 115200: cfsetispeed(&amp;newtio,B115200); cfsetospeed(&amp;newtio,B115200); break; case 460800: cfsetispeed(&amp;newtio,B460800); cfsetospeed(&amp;newtio,B460800); break; default: cfsetispeed(&amp;newtio,B9600); cfsetospeed(&amp;newtio,B9600); break; &#125; if(nStop == 1)&#123; newtio.c_cflag &amp;= ~CSTOPB; &#125; else if(nStop ==2)&#123; newtio.c_cflag |= CSTOPB; &#125; newtio.c_cc[VTIME] = 0; newtio.c_cc[VMIN] = 0; tcflush(fd,TCIFLUSH); if((tcsetattr(fd,TCSANOW,&amp;newtio)) != 0) &#123; perror(&quot;com set error&quot;); return -1; &#125; printf(&quot;set done!\n&quot;); return 0; &#125; int open_port(int fd,int comport) &#123; char *dev[]=&#123;&quot;/dev/ttySAC0&quot;,&quot;/dev/ttySAC1&quot;,&quot;/dev/ttySAC2&quot;&#125;; long vdisable; if(comport == 1) &#123; fd = open(&quot;/dev/ttySAC0&quot;,O_RDWR|O_NOCTTY|O_NDELAY); if(fd == -1)&#123; perror(&quot;Can&apos;t Open Serial Port&quot;); return -1; &#125; &#125; else if(comport == 2) &#123; fd = open(&quot;/dev/ttySAC1&quot;,O_RDWR|O_NOCTTY|O_NDELAY); if(fd == -1)&#123; perror(&quot;Can&apos;t Open Serial Port&quot;); return -1; &#125; &#125; else if(comport == 3) &#123; fd = open(&quot;/dev/ttySAC2&quot;,O_RDWR|O_NOCTTY|O_NDELAY); if(fd == -1)&#123; perror(&quot;Can&apos;t Open Serial Port&quot;); return -1; &#125; &#125; if(fcntl(fd,F_SETFL,0) &lt; 0)&#123; printf(&quot;fcntl failed\n&quot;); &#125; else&#123; printf(&quot;fcntl=%d\n&quot;,fcntl(fd,F_SETFL,0)); &#125; if(isatty(STDIN_FILENO) == 0)&#123; printf(&quot;standard input is not a terminal device\n&quot;); &#125; else&#123; printf(&quot;isatty sucess!\n&quot;); &#125; printf(&quot;fd-open=%d\n&quot;,fd); return fd; &#125; ###接收串口数据 nread = read(fd,buff,n)； 发送串口数据nwrite = write(fd,buff,length); 实际应用上面两个程序可以完成数据的收发，在具体的项目中在串口的数据传输中多种数据的传输时，会涉及到一些简单的数据处理，需要自定义一些协议。这时串口数据的收发必须精确的每个字符，不能多一个也不能少一个。 read、write函数，它们读写的字符必须精准，在write时写入数据的大小必须和字符串的大小一致。在送单一的数据时，对写数据大小不做要求可是在自定义协议中数据的大小关系到对方的解析。 这次使用的数据格式：FD 00 06 02 00 31 33 33 C8 1234567891011121314151617181920212223242526272829char Speaker(char CMD,char par,char * pString)&#123; char headOfFrame[5]; char length; //定义字符串长度 char ecc = 0; //定义校验字节 int i = 0; if (pString == NULL) //空字符串 return 1; headOfFrame[0]=0XFD; //构造帧头FD headOfFrame[1]=0X00; //构造数据区长度的高字节 length = strlen(pString); //需要发送文本的长度 headOfFrame[2]=length+3; //构造数据区长度的低字节 headOfFrame[3]=CMD; //构造命令字：合成播放命令 headOfFrame[4]=par; //构造命令参数：编码格式为GB2312 for(i=0;i&lt;5;i++) //依次发送构造好的5个帧头字节 &#123; ecc=ecc^(headOfFrame[i]); //对发送的字节进行异或校验 write(fd,&amp;headOfFrame[i],1); &#125; for(i=0;i&lt;length;i++) //依次发送待合成的文本数据 &#123; ecc=ecc^(*pString); write(fd,pString,1); pString ++; &#125; write(fd,&amp;ecc,1); //最后发送校验和 return 0; //成功返回0&#125;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL链接中汉字乱码转UTF-8和gb2312]]></title>
    <url>%2Fpost%2F34196.html</url>
    <content type="text"><![CDATA[在使用URL向服务器提交数据的时候，如果我们提交的数据中存在汉字，就会出现下列情况http://192.168.11.22/cgi-bin/serial.cgi?type=text&amp;text=%C9%DB%CD%FB%C8%A8 %C9%DB%CD%FB%C8%A8代表着什么，不是我们想要的数据，那它是什么呢？ 去除所有%号：C9DBCDFBC8A8使用汉字内码查询可以看到 将汉字内码转成一个汉字 gb2312 两个字节表示一个汉字 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char str[3]; str[0]=201; /*201为C9的十进制值*/ str[1]=219; /*219为DB的十进制值*/ str[2]=&apos;\0&apos;; printf(&quot;C9DB的汉字的值为:%s&quot;,str); return 0; } 注：在终端先可以正确输出‘邵’，（使用gb2312编码，在linux下输出乱码，Windows下正常输出） utf-8 三个字节表示一个汉字 多个汉字输出/*将十六进制数转为十进制*/ int hex_to_decade(char * s) { char *digits=&quot;0123456789ABCDEF&quot;; /*判断大小写，小写的话转为大写，达到统一*/ if (islower (s[0])) s[0]=toupper(s[0]); if (islower (s[1])) s[1]=toupper(s[1]); return 16*(strchr(digits,s[0])-strchr(digits,&apos;0&apos;))+(strchr(digits,s[1])-strchr(digits,&apos;0&apos;)); } void url_to_gb_or_utf(char *get_url, char *return_gb_or_utf) { int url_position;/*用来保存get_url的位置*/ int return_position;/*用来保存解码后的字符串的位置*/ int url_len;/*用来保存get_url的长度*/ char tmp[2];/*保存%后面的十六进制字符*/ url_len = strlen(get_url); return_position = 0; fprintf(stdout, &quot;length=%d\n&quot;, url_len); for ( url_position = 0; url_position &lt; url_len; ) { /*如果是%将它后面的十六进制字符考到数组里*/ if ( get_url[url_position] == &apos;%&apos; ){ tmp[0] = get_url[url_position+1];/*第一个十六进制字符*/ tmp[1] = get_url[url_position+2];/*第二个*/ // tmp[2] = &apos;\0&apos;; **串口通信中会出现乱码，结尾必须不能有其他字符** url_position+= 3; /*使url_position跳到的下一个%*/ /*将十六进制数转为十进制后考入要返回的数组里*/ return_gb_or_utf[return_position] = hex_to_decade(tmp); fprintf(stdout, &quot;------%d\n&quot;, return_gb_or_utf[return_position] ); } /*如果不是特殊字符，如英文，数字那么直接返回*/ else{ return_gb_or_utf[return_position] = get_url[url_position]; url_position++; } return_position++; } return_gb_or_utf[return_position] = 0; } **十六进制转十进制可使用：strtol函数 汉字编码 UTF-8：Unicode TransformationFormat-8bit，允许含BOM，但通常不含BOM。是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24为（三个字节）来编码。 GBK是国家标准GB2312基础上扩容后兼容GB2312的标准。GBK的文字编码是用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBD大。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Micro2440开发板启动Linux]]></title>
    <url>%2Fpost%2F32798.html</url>
    <content type="text"><![CDATA[1.Micro2440移植Linux2.6的流程 移植uboot-&gt;移植内核-&gt;移植文件系统 这里只记录在开发板启动时，移植的基本步骤： 2.烧写Linux内核镜像a.修改uboot环境变量setenv bootargs &apos;root=/dev/mtdblock2 noinitrd console=ttySAC0,115200&apos; setenv bootcmd &apos;nand read 0x30008000 0x200000 0x400000;bootm&apos; 注：root=/dev/mtdblock2指定根文件系统路径，/dev/mtdblock2表示在nandflash的第三块分区中（第一块分区用0表示）。bootm指使用uImage引导修改完uboot引导命令后，就制作uImage b.制作内核镜像根据自己项目的需求的开发板的设计，剪裁linux内核进行编译。linux内核编译完有两种不同格式的内核镜像（uImage和zImage）。uImage和zImage的区别： 这两个都是内核，zImage是真正的内核，在内存中的地址0x30008000；而uImage是包含64字节头的内核，在头中存放着bootargs环境变量，在内存中的地址0x30007fc0![uImage和zImage区别]（/images/uImage-zImage.PNG） 到这时你就要选择到底使用哪个镜像了，这里根据你uboot的环境变量bootcmd判断。 c.选择镜像烧写zImage到这里想那就烧写正真的内核吧zImage，我们uboot中也是在0x30008000内存地址中启动的，将zImage烧写到nandflash启动开发板，内核启动错。 Starting kernel ... test:machid:805306624 test: bi_boot_params:0x31f5bfb8 test:starting 1 data abort pc : [&lt;30008008&gt;] lr : [&lt;31f98ba4&gt;] sp : 31f5ba94 ip : 30008000 fp : 31f5bca4 r10: 00000000 r9 : 00000001 r8 : 31f5bfdc r7 : 00000000 r6 : 31fcbd1c r5 : 31f5c83d r4 : 00000000 r3 : 31f5bfb8 r2 : 30000100 r1 : 000000c1 r0 : 00000000 Flags: nZCv IRQs off FIQs off Mode SVC_32 Resetting CPU ... 内核不断重启就是进不去，是因为缺失内核的一个头部信息，需要添加64字节的内核头，zImage也需要添加。怎么添加头呢，需要什么工具？编译完成uboot已经提供的这个工具mkimage工具使用参数解析： -A指定cpu体系结构 -O指定是什么操作系统 -T指定映像类型，如standalone、kernel、ramdisk、multi、firmware、script、filesystem等 -C指定映像压缩方式，如none(不压缩)、gzip、bzip2。这里不对uImage进行压缩 -a指定映象在内存中的加载地址，映象下载到内存中时，要按照用MKIMAGE制作映象时，这个参数所指定的地址值来下载 -e 指定映象运行的入口点地址，这个地址就是-a参数指定的值加上0x40（因为前面有个MKIMAGE添加的0x40个字节的头） -n 指定映象名 -d 指定制作映象的源文件 添加所需头信息： 16:23 [root@linfeng boot]#mkimage -n &apos;linux-2.6&apos; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d zImage zImage.img 正真内核烧写这么麻烦那就以后使用uImage 烧写uImage将uImage镜像直接烧写到nandflash，启动开发板，无法启动。不着急刚才uboot环境变量还没有修改过来呢，重新进入uboot修改环境变量 setenv bootcmd &apos;nand read 0x30007fc0 0x200000 0x400000;bootm&apos; =====经过第二次的内核烧写测试，使用该方法也不可行，同样会报出内核恐慌错误现在可以正常启动，成功进入内核后有出现： yaffs: dev is 32505858 name is &quot;mtdblock2&quot; yaffs: passed flags &quot;&quot; yaffs: Attempting MTD mount on 31.2, &quot;mtdblock2&quot; yaffs: auto selecting yaffs2 yaffs_read_super: isCheckpointed 0 VFS: Mounted root (yaffs filesystem) on device 31:2. Freeing init memory: 156K Warning: unable to open an initial console. Kernel panic - not syncing: No init found. Try passing init= option to kerne. Backtrace: [&lt;c00341cc&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0329f3c&gt;] (dump_stack+0x18/0x) r7:00000000one_wire_status: 4 r6:00000000 r5:c001f308 r4:c0481c50 [&lt;c0329f24&gt;] (dump_stack+0x0/0x1c) from [&lt;c0329f8c&gt;] (panic+0x4c/0x114) [&lt;c0329f40&gt;] (panic+0x0/0x114) from [&lt;c002f598&gt;] (init_post+0xa8/0x10c) r3:00000000 r2:c393a100one_wire_status: 4 r1:c393a200 r0:c03db74c [&lt;c002f4f0&gt;] (init_post+0x0/0x10c) from [&lt;c00084b4&gt;] (kernel_init+0xe4/0x114) r5:c001f308 r4:c04813e0 [&lt;c00083d0&gt;] (kernel_init+0x0/0x114) from [&lt;c004bbbc&gt;] (do_exit+0x0/0x620) r5:00000000 r4:00000000 这是没有找到yaffs文件系统，因为你还没有移植呢 移植yaffs文件系统将你自己做好的文件系统使用mkyaffs2image工具制作出文件系统镜像。可是这时使用nand write 0x30008000 0x600000 0x2100000进行烧写后，开发板启动后同样进不到文件系统。正确的烧写命令： nand write.yaffs 0x30008000 0x600000 0x2100000 写入yaffs文件系统时，下载的文件系统有多大。就烧写多大，但是大小必须是2k倍 烧写的方式通过tftp将uboot、kernel、文件系统下载到0x30008000这块可读可写的内存中，然后使用nand相关命令进行操作。nandflash操作命令： nand - NAND sub-system Usage: nand info - show available NAND devices nand device [dev] - show or set current device nand read - addr off|partition size nand write - addr off|partition size read/write ‘size’ bytes starting at offset ‘off’ to/from memory address ‘addr’, skipping bad blocks. nand erase [clean] [off size] - erase ‘size’ bytes from offset ‘off’ (entire device if not specified) nand read[.yaffs[1]] is not provide temporarily! nand write[.yaffs[1]] addr off size - write the size&#39; byte yaffs image stg at offsetoff’ from memory address `addr’ (.yaffs1 for 512+16 NAND) nand bad - show bad blocks nand dump[.oob] off - dump page nand scrub - really clean NAND erasing bad blocks (UNSAFE) nand markbad off […] - mark bad block(s) at offset (UNSAFE) nand biterr off - make a bit error at offset (UNSAFE) 附：NSF文件系统启动时，uboot环境变量的设置setenv bootargs &apos;noinitrd console=ttySAC0,115200 init=/linuxrc root=/dev/nfs nfsroot=192.168.11.11:/work/embedded/rootfs ip=192.168.11.22:192.168.11.11:192.168.11.11:255.255.255.0:micro2440.arm9.net:eth0&apos; setenv bootcmd &apos;tftp 0x30007fc0 uImage ; bootm&apos;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新时间戳]]></title>
    <url>%2Fpost%2F31965.html</url>
    <content type="text"><![CDATA[时间戳不相同时更新命令：第一种： touch * 第二种：（文件很多） find . -type f -exec touch {} \;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mini2440基于boa服务器通过WEB控制GPIO]]></title>
    <url>%2Fpost%2F63421.html</url>
    <content type="text"><![CDATA[本文是基于BOA服务器，通过CGI（通用网管接口）控制开发板的GPIO。CGI通用网关接口是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。 在这里以控制LED为例。 1.客户端控制界面采用CGI将浏览器端的控制信息传到boa服务器端,index.html文件 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;web控制mini2440开发板led&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align=&quot;center&quot;&gt;基于mini2440的web控制GPIO口&lt;/h1&gt; &lt;form action=&quot;/cgi-bin/cgi_led.cgi&quot; method=&quot;get&quot;&gt; &lt;p align=&quot;center&quot;&gt;led的测试工作&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;请输入需要控制的led &lt;input type=&quot;text&quot; name=&quot;led_control&quot;/&gt;&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;请输入控制led的动作 &lt;input type=&quot;text&quot; name=&quot;led_state&quot;/&gt;&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;sure&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;back&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2.服务器端数据处理通过客户端浏览器的from表单将，控制信息提交到服务器，服务器获取数据并通过有名管道将控制数据传给调用LED驱动的控制程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#define MYFIFO "/www/myfifo"#define MAX_BUFFER_SIZE PIPE_BUFint main()&#123; char* data; //定义一个指针用于指向QUERY_STRING存放的内容 char buff[MAX_BUFFER_SIZE]; int fd, nwrite; int led_control, led_state; printf("Content-type: text/html\n\n"); printf("&lt;html&gt;\n"); printf("&lt;head&gt;&lt;title&gt;cgi led demo&lt;/title&gt;&lt;/head&gt;\n"); printf("&lt;body&gt;\n"); printf("&lt;p&gt;led is setted successful! you can watch the led's change&lt;/p&gt;\n"); printf("&lt;p&gt;&lt;a herf=index.html&gt;&lt;button&gt;get back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\n"); printf("&lt;/body&gt;\n"); data = getenv("QUERY_STRING"); //getenv()读取环境变量的当前值的函数 strcpy(buff, data); fd = open(MYFIFO, O_WRONLY); if(-1 == fd) &#123; printf("Open fifo file error\n"); exit(1); &#125; if((nwrite = write(fd, buff, sizeof(buff))) &lt; 0) &#123; printf("\nWrite data error\n"); exit(1); &#125; if(sscanf(buff,"led_control=%d&amp;led_state=%d",&amp;led_control,&amp;led_state)!=2) &#123; //利用sscnaf（）函数的特点将环境变量分别提取出led_control和led_state这两个值 printf("&lt;p&gt;please input right"); printf("&lt;/p&gt;"); &#125; printf("&lt;p&gt;led_control = %d,led_state = %d&lt;/p&gt;", led_control, led_state); if(led_control&gt;3) &#123; printf("&lt;p&gt;Please input 0&lt;=led_control&lt;=3!"); printf("&lt;/p&gt;"); &#125; if(led_state&gt;1) &#123; printf("&lt;p&gt;Please input 0&lt;=led_state&lt;=1!"); printf("&lt;/p&gt;"); &#125; close(fd); printf("&lt;/html&gt;\n"); return 0;&#125; 3.控制端（GPIO驱动调用）通过管道接受到控制数据，调用驱动程序实现对LED灯的控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;linux/micro2440_leds.h&gt;#define MYFIFO "/www/myfifo"#define LEDS_DEVICE "/dev/led4s"#define MAX_BUFFER_SIZE PIPE_BUFint main(int argc, char* argv[])&#123; int led_fd, fifo_fd, led_control,led_state, nread; struct leds_stat oneStat; char buff[MAX_BUFFER_SIZE]; //定义一个指针用于指向QUERY_STRING存放的内容 led_fd = open(LEDS_DEVICE, O_RDWR); //打开led设备 if(-1 == led_fd) &#123; perror("open led device"); exit(1); &#125; if(-1 == access(MYFIFO, F_OK)) &#123; if((mkfifo(MYFIFO, 0666) &lt; 0) &amp;&amp; (errno != EEXIST)) &#123; printf("Connot create fifo file\n"); exit(1); &#125; &#125; fifo_fd = open(MYFIFO, O_RDONLY); if(-1 == fifo_fd) &#123; perror("open fifo file error\n"); exit(1); &#125; while(1) &#123; //memset(buff, 0, sizeof(buff));使用会使控制数据出错 if((nread = read(fifo_fd, buff, sizeof(buff))) &lt; 0) &#123; perror("Read data error"); exit(1); &#125; if(sscanf(buff,"led_control=%d&amp;led_state=%d",&amp;led_control,&amp;led_state)!=2) &#123; //利用sscnaf（）函数的特点将环境变量分别提取出led_control和led_state这两个值 printf("please input right \n"); exit(1); &#125; if(led_control&gt;3) &#123; printf("Please input 0&lt;=led_control&lt;=3!"); exit(1); &#125; if(led_state&gt;1) &#123; printf("Please input 0&lt;=led_state&lt;=1!"); exit(1); &#125; oneStat.led_nr = led_control; oneStat.led_st = led_state; ioctl(led_fd, LEDS_SET_ONE, &amp;oneStat); &#125; close(led_fd); close(fifo_fd); return 0;&#125; 4.总结本文主要参考http://blog.csdn.net/rwzhou1/article/details/23381811，采用管道的方式将数据的获取与功能的实现分离，更有利于对GPIO的控制。由于对LED驱动自己编写的跟上文中的有所不同，只有通过管道的方式实现。 在使用GET获取环境变量时，只能将getenv(“QUERY_STRING”);赋予字符指针，不能使用使用字符数组。 在使用管道的时候，由于管道数据传输为半双通因此在管道的两端只能赋予某一种权限，如读端以只读权限打开，写端以只写权限打开。如果某一端以读写权限打开程序将一直阻塞数据无法传输（刚开始习惯性的当做文件，直接以读写权限打开出错）。 控制端从管道读取数据时，将数据保存到字符数组中。在读取之前不能使用memset(buff, 0, sizeof(buff));函数将数组清零，如果数组清零接受到的数据与发送的数据信息相同，但大小不同会在数据解析的时候会出错，无法实现控制。]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>Boa</tag>
        <tag>S3C2440</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOA服务器的配置与cgic移植]]></title>
    <url>%2Fpost%2F54877.html</url>
    <content type="text"><![CDATA[上次在开发板上成功移植完boa服务器，最近使用C语言进行CGI编程，只在宿主机上搭建CGI的测试环境。 BOA服务器的配置： Port：boa服务器监听的端口，默认的端口是80。如果端口小于1024，则必须是 root用户启动服务器。 Listen：绑定的ip地址。不使用这个参数时，将绑定所有的地址。 User：连接到服务器的客户端的身份，可以是用户名或UID。 Group：连接到服务器的客户端的组，可以是组名或GID。 ServerAdmin：服务器出故障时要通知的邮箱地址。 ErrorLog：指定错误日志文件。如果路径没有以”/“开始，则相对于ServerRoot路径。没有配置时默 认的文件是/dev/stderr。若不想记录日志，指定文件为/dev/null。 AccessLog：设置存取日志文件，与ErrorLog类似。 UseLocaltime：设置使用本地时间，使用UTC时注释这个参数。这个参数没有值。 VerboseCGILogs：在错误日志文件中记录CGI启动和停止时间，若不记录，注释这个参数。这个参数没有值。 ServerName：指定服务器的名称，当客户端使用gethostname + gethostbyname时返回给客户端。 VirtualHost：虚拟主机开关。使用此参数，则会在DocumentRoot设定的目录添加一个ip地址作为新的DocumentRoot来处理客户端的请求。如DocumentRoot设置为/var/www，则http://localhost/转换 成/var/www/127.0.0.1/，若注释此参数，则为/var/www/。 DocumentRoot：HTML文件的根目录（也就是网站的目录,使用yum安装的话，为/var/www/boa/html）。 DirectoryIndex：网站访问的第一个网页，默认是index.html（如果使用yum安装的话，地址为：/var/www/boa/html/index.html ） UserDir：指定用户目录。 DirectoryIndex：指定预生成目录信息的文件，注释此变量将使用DirectoryMaker变量。这个变量也就是设置默认主页的文件名。 DirectoryMaker：指定用于生成目录的程序，注释此变量将不允许列目录。 DirectoryCache：当DirectoryIndex文件不存在，而DirecotryMaker又被注释掉时，将列出这个参数指定目录给客户端。 KeepAliveMax：每个连接允许的请求数量。如果将此值设为” 0 “，将不限制请求的数目。 KeepAliveTimeOut：在关闭持久连接前等待下一个请求的秒数。（秒）。 MimeTypes：设置包含mimetypes信息的文件，一般是/etc/mime.types。 DefaultType：默认的mimetype类型，一般是text/html。 CGIPath：相当于给CGI程序使用的$PATH变量。 SinglePostLimit：一次POST允许最大的字节数，默认是1MB。 AddType: 增加MimeType没有指定的类型，例: AddType type extension [extension …]。要使用cgi，必须添加cgi类型：AddType application/x-httpd-cgi cgi Redirect：重定向文件。 Aliases：指定路径的别名。 ScriptAlias：指定脚本路径的虚拟路径。 移植boa配置文件只修改强调的部分，具体修改方法参考转载的上文。 移植CGIC库1.下载cgic库源码2.解压#tar zxvf cgic205.tar.gz 3.修改Markfile编译器ARM开发板移植CC=arm-linux-gcc AR=arm-linux-ar RANLIB=arm-linux-ranlib 宿主机测试CC=gcc AR=ar RANLIB=ranlib markfile部分gcc cgictest.o -o cgictest.cgi ${LIBS} 修改为： $(CC) $(CFLAGS) cgictest.o -o cgictest.cgi ${LIBS} gcc capture.o -o capture ${LIBS} 修改为： $(CC) $(CFLAGS) capture.o -o capture ${LIBS} 宿主机测试只是为了练习CGI编写。 遇到的错误1.在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc 出现502错误：The CGI was not CGI/1.1 compliant. 整了我好长时间主要还是不细心，同时在遇到问题解决问题的时候不应该盲目，为了解决错误而去找答案应该先捋一捋自己做事的过程，看看有没有出差。]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>Boa</tag>
        <tag>cgic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[M-JPEG技术]]></title>
    <url>%2Fpost%2F60991.html</url>
    <content type="text"><![CDATA[M-JPEG是一种基于静态图像压缩技术JPEG发展起来的动态图像压缩技术，可以生成序列化的运动图像。其主要特点是基本不考虑视频流中不同帧之间的变化，只单独对某一帧进行压缩，其压缩倍数为20~80倍，适合静态画面的压缩，分辨率可从352×288到704×576。以往的JPEG压缩技术是直接处理整个画面，所以要等到整个压缩档案传输完成才开始进行解压缩成影像画面，而这样的方式造成传输一个高解析画面时须耗时数十秒甚至数分钟。而新一代的M-JPEG是采取渐层式技术，先传输低解析的图档，然后再补送细部之资料，使画面品质改善。 M-JPEG压缩技术可以获取清晰度很高的视频图像，而且可以灵活设置每路的视频清晰度和压缩帧数。因期压缩后之格式可读单一画面，所以可以任意剪接。 M-JPEG因采用帧内压缩方式也适于视频编辑。 M-JPEG的主要缺点是压缩效率低，M-JPEG算法是根据每一帧图像的内容进行压缩，而不是根据相邻帧图像之间的差异来进行压缩，因此造成了大量冗余信息被重复存储，存储占用的空间大到每帧8~15K字节，最好也只能做到每帧3K字节，但如果因此而采用高压缩比则视频质量会严重降低。 JPEG是应用相当普遍的文件格式，能使图像占用最少的的空间，又能显示极佳的效果，在设计网页时，一般将文件存储为JPEG格式。 如果一幅彩色图片所占空间比较大，则可以将它存成压缩格式，以减小所占空间，如果此格式用于输出或印刷，那就需要解压缩]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>M-JPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移植mjpg-streamer]]></title>
    <url>%2Fpost%2F50611.html</url>
    <content type="text"><![CDATA[Mjpg‐streamer是一个开源软件，用于从webcam摄像头采集图像，把它们以流的形式通过基于ip的网络传输到浏览器如Firefox，Cambozola，VLC播放器，Windows的移动设备或者其他拥有浏览器的移动设备 移植Mjpg-streamer需要libjpeg库，因此要先移植libjpeg 1.移植jpega. 从http:&lt;//www.ijg.org/files/&gt;下载jpeg源码包；b. 解压，进入其目录tar zxvf jpegsrc.v9a.tar.gz cd /work/embedded/video/jpeg-9a c. 配置源码，（具体配置项可以运行命令./configure –help看看是什么意思，根据实际情况修改）#./configure CC=arm-linux-gcc --host=arm-unknown-linux --prefix=/work/embedded/video/jpeg --enable-shared --enable-static 其中/work/embedded/video/jpeg是编译后安装的目录，根据实际情况修改 d. 编译：#make e. 安装：#make install f. 拷贝库文件到开发板文件系统将/work/embedded/video/jpeg-9a/jpeg目录下全部文件拷贝到开发板文件系统/work/embedded/rootfs/usr/local/mjpg-streamer下(此目录为mjpg-streamer在开发板的安装目录，当然你也可以把它放在开发板的/lib/目录下） cp lib/* /work/embedded/rootfs/lib/ 2. 移植mjpg-streamera. 下载源码，在https://sourceforge.net/projects/mjpg-streamer/下载的源码#tar zxvf mjpg-streamer-r63.tar.gz b. 修改plugins/input_uvc/MakfileCFLAGS = -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC 为（即添加头文件-I） CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC -I/work/embedded/v ideo/jpeg-9a/jpeg/include 修改 $(CC) $(CFLAGS) -ljpeg -o $@ input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo 为(即添加库文件-L) $(CC) $(CFLAGS) -ljpeg -L/work/embedded/video/jpeg-9a/jpeg/lib -o $@ input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo c. 编译#make CC=arm-linux-gcc d. 建立mjpg-streamer安装目录mkdir /work/embedded/rootfs/usr/local/mjpg-streamer cp *.so /work/embedded/rootfs/usr/local/mjpg-streamer cp mjpg-stream /work/embedded/rootfs/usr/local/mjpg-streamer 将源码目录中的start.sh到/work/embedded/rootfs/mjpg-streamer目录下，www目录下的所有文件拷贝到/work/embedded/rootfs/www下，然后就可以测试啦 e. 在开发板中运行./start.sh修改start.sh脚本文件 ./mjpg_streamer -o &quot;output_http.so -w ./www&quot; 具体的修改方法可以根据start.sh文件中的注释或查看mjpg-streamer的帮助 ./mjpg_streamer --help 参考文章： http://www.linuxidc.com/Linux/2012-02/54797p4.htmhttp://blog.chinaunix.net/uid-27070031-id-3458957.html]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>mjpg-streamer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Micro2440 移植boa服务器]]></title>
    <url>%2Fpost%2F62852.html</url>
    <content type="text"><![CDATA[Boa是一种非常小巧的Web服务器，其可执行代码只有大约60KB左右。作为一种单任务Web服务器，Boa只能依次完成用户的请求，而不会fork出新的进程来处理并发连接请求。但Boa支持CGI，能够为CGI程序fork出一个进程来执行。Boa的设计目标是速度和安全。 下面结合网上一些文档,及自己的实验给大家介绍一下Boa服务器移植的具体操作步骤。 环境 主机：redhat linux 目标：Micro2440开发板 1.下载Boa源码下载地址: http://www.boa.org/最新发行版本： 0.94.13下载 boa-0.94.13.tar.gz将其拷贝到/opt/FriendlyARM/boa文件夹（自己创建的FriendlyARM/boa目录）解压：# tar xzf boa-0.94.13.tar.gz 2.修改文件(1)修改boa-0.94.13的 src/compat.h文件 找到 #define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff 修改成 #define TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff 否则会出现错误： util.c:100:1: error: pasting &quot;t&quot; and &quot;-&gt;&quot; does not give a valid preprocessing token make: *** [util.o] 错误 1 (2)修改boa-0.94.13的src/log.c 注释掉 if (dup2(error_log, STDERR_FILENO) == -1) { DIE(&quot;unable to dup2 the error log&quot;); } 为： /*if (dup2(error_log, STDERR_FILENO) == -1) { DIE(&quot;unable to dup2 the error log&quot;); }*/ 否则会出现错误： log.c:73 unable to dup2 the error log:bad file deor (3)修改boa-0.94.13的src/boa.c 注释掉下面两句话： if (passwdbuf == NULL) { DIE(”getpwuid”); } if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) { DIE(”initgroups”); } 为 #if 0 if (passwdbuf == NULL) { DIE(”getpwuid”); } if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) { DIE(”initgroups”); } #endif 否则会出现错误： boa.c:211 - getpwuid: No such file or directory 注释掉下面语句： if (setuid(0) != -1) { DIE(”icky Linux kernel bug!”); } 为 #if 0 if (setuid(0) != -1) { DIE(”icky Linux kernel bug!”); } #endif 否则会出现问题： boa.c:228 - icky Linux kernel bug!: No such file or directory 3、生成Makefile文件 执行： #cd /opt/FriendlyARM/boa/boa-0.94.13/src #./configure 4、修改Makefile #cd /opt/FriendlyARM/boa/boa-0.94.13/src vim Makefile 修改CC = gcc 为 CC = arm-linux-gcc 修改CPP = gcc -E 为 CC = arm-linux-gcc -E 5、编译 还是在/opt/FriendlyARM/boa/boa-0.94.13/src目录下 #make ls -l boa -rwxr-xr-x 1 root root 189223 Jun 26 09:02 boa 然后为生成的二进制文件boa瘦身 arm-linux-strip boa ls -l boa -rwxr-xr-x 1 root root 59120 Jun 26 09:03 boa 可以发现boa的大小前后差距很大这为我们节省了很大的空间 6、Boa的配置 这一步的工作也在电脑虚拟机上完成。 在boa-0.94.13目录下已有一个示例boa.conf，可以在其基础上进行修改。如下： #vi boa.conf (1)Group的修改 修改 Group nogroup 为 Group 0 (2)user的修改 修改 User nobody 为 User 0 或者统一设置为 User root Group root (3)ScriptAlias的修改 修改ScriptAlias/cgi-bin/ /usr/lib/cgi-bin/ 为 ScriptAlias/cgi-bin/ /www/cgi-bin/ (5)DoucmentRoot的修改 修改DoucmentRoot /var/www 为DoucmentRoot /www (6)ServerName的设置 修改#ServerName www.your.org.here 为 ServerName www.your.org.here 否则会出现错误“gethostbyname::No such file or directory” (7)AccessLog修改 修改AccessLog /var/log/boa/access_log 为#AccessLog /var/log/boa/access_log否则会出现错误提示：“unable to dup2 the error log: Bad file deor” 7、以下配置和boa.conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建： 创建目录/etc/boa并且把主机的boa可执行文件（/opt/FriendlyARM/boa/boa-0.94.13/src） 和 boa.conf（/opt/FriendlyARM/boa/boa-0.94.13）拷贝到这个目录下 #mkdir /etc/boa 注：boa.conf配置文件必须放在/etc/boa中。boa可执行文件位置可随意，否则启动boa将报错。 Could not chdir to “/etc/boa”: aborting 创建HTML文档的主目录/www #mkdir /www 创建CGI脚本所在录 /www/cgi-bin #mkdir /www/cgi-bin 在www下添加测试主页index.html &lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;title&gt;Test Boa&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello BOA&lt;br&gt; &lt;/body&gt; &lt;/html&gt; 创建日志文件夹 /var/log #mkdir /var/log 8.执行boa服务器进入/etc/boa目录，修改boa的执行权限， #chmod +x boa #./boa 开启boa 9.在windows xp ie输入开发板的ip（http://192.168.1.230）地址，即可访问到mini2440的默认网页。]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>boa</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RT73网卡的移植]]></title>
    <url>%2Fpost%2F58471.html</url>
    <content type="text"><![CDATA[经过对RT73类网卡驱动源码的几次编译，修改了多出报错信息之后，还是无法完成移植。最终还是用了友善之臂提供的usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz工具集。 #tar zxvf usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz -C / 根据友善之臂提供的文档，解压完直接使用scan-wifi、start-wifi等命令就可以使用该无线网卡，可是我使用scan-wifi时搜索不到任何热点。 最后在网上找根据这篇文章,给开发板安装了iwconfig工具，并重新配置了一下。 # ifconfig rausb0 inet 192.168.1.77 up # route add default gw 192.168.1.1 # iwconfig rausb0 essid &quot;linuxer&quot; # iwconfig rausb0 mode mananed # iwconfig rausb0 channel 6 scan-wifi成功 这里做简单的记录为保存这几个工具，以备日后再用]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>RT73</tag>
        <tag>网卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[很久没有更新过了]]></title>
    <url>%2Fpost%2F20021.html</url>
    <content type="text"><![CDATA[今天看看已经很久没有更新过博客了，最开始的时候想自己搭建一个小窝写一写自己的所思所想。 经过这段时间的培训，笔记做了很多的整理，可是总感觉少了点什么？ 或许是对某写问题得到深入思索吧，在这里以后不仅记录对技术的实现更应该写写背后思索 继续开始做吧，我的无线网卡驱动移植难吗，下次就是分析一下无线网卡的移植和方法]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redhat更新yum源进行软件在线安装]]></title>
    <url>%2Fpost%2F44387.html</url>
    <content type="text"><![CDATA[yum安装 YUM是Redhat Linux在线安装更新及软件的工具，但是这是RHEL5的收费功能，如果没有购买Redhat的服务时不能使用RHEL5的更新源的，会提示注册。由于CentOS是从Redhat演化而来的免费Linux版本，因此可以利用CentOS的yum更新源来实现RHEL5的YUM功能。 配置方法如下：检查yum是否安装，默认情况下都是安装好的，总共4各包 [root@localhost /]# rpm -qa |grep yum yum-3.2.22-20.el5 yum-security-1.1.16-13.el5 yum-metadata-parser-1.1.2-3.el5 yum-updatesd-0.9-2.el5 yum-rhn-plugin-0.5.4-13.el5 更新yum源 修改/etc/yum.conf文件，用下面代码全部覆盖。定义yum更新源，这里使用的是上海交大的CentOS更新源 [main] cachedir=/var/cache/yum keepcache=1 debuglevel=2 logfile=/var/log/yum.log pkgpolicy=newest distroverpkg=redhat-release tolerant=1 exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 [base] name=CentOS-5-Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever5&amp;arch=$basearch&amp;repo=os #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/ baseurl=http://ftp.sjtu.edu.cn/centos/5/os/$basearch/ gpgcheck=0 gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5 #released updates [update] name=CentOS-5-Updates #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=updates baseurl=http://ftp.sjtu.edu.cn/centos/5/updates/$basearch/ gpgcheck=0 gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5 #packages used/produced in the build but not released [addons] name=CentOS-5-Addons #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=addons baseurl=http://ftp.sjtu.edu.cn/centos/5/addons/$basearch/ gpgcheck=0 gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5 #additional packages that may be useful [extras] name=CentOS-5-Extras #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=extras baseurl=http://ftp.sjtu.edu.cn/centos/5/extras/$basearch/ gpgcheck=0 gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-5-Plus #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=centosplus baseurl=http://ftp.sjtu.edu.cn/centos/5/centosplus/$basearch/ gpgcheck=0 enabled=0 gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5 #contrib - packages by Centos Users [contrib] name=CentOS-5-Contrib #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=contrib baseurl=http://ftp.sjtu.edu.cn/centos/5/contrib/$basearch/ gpgcheck=0 enabled=0 gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5 # vi dag.repo [dag] name=Dag RPM Repository for RHEL5 baseurl=http://ftp.riken.jp/Linux/dag/redhat/el5/en/$basearch/dag/ enabled=1 gpgcheck=0 gpgkey=http://ftp.riken.jp/Linux/dag/packages/RPM-GPG-KEY.dag.txt] 修改yum.conf配置文件中[main]部分的参数详细说明如下： [main] //main开头的块用于对客户端进行配置，在main后也可以指定yum源（不推荐这样做），与/etc/yum.repo.d中指定yum源相同 cachedir=/var/cache/yum #cachedir：yum更新软件时的缓存目录，默认设置为/var/cache/yum keepcache=[1 or 0] #设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存 debuglevel=2 #debuglevel：Debug信息输出等级，范围为0-10，缺省为2 logfile=/var/log/yum.log #logfile：存放系统更新软件的日志的目录。用户可以到/var/log/yum.log文件去查询自己在过去的日子里都做了哪些更新。 pkgpolicy=newest #包的策略。一共有两个选项，newest和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository中同时存在，yum应该安装哪一个，如果是newest，则yum会安装最新的那个版本。如果是last，则yum会将服务器id以字母表排序，并选择最后的那个服务器上的软件安装。一般都是选newest。 distroverpkg=redhat-release #指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何针对自己发行版的rpm包。 tolerant=1 #如果值为1，则yum会忽略任何的有关包的错误。举例来说，当执行yum来安装baz时，如果baz包已经安装在系统中了，则yum会继续重复安装baz，而不会报错。默认值为1。 exactarch=1 #设置为1，则yum只会安装和系统架构匹配的软件包，例如，yum不会将i686的软件包安装在适合i386的系统中。默认为1 retries=20 #网络连接发生错误后的重试次数，如果设为0，则会无限重试。默认值为6 obsoletes=1 #此选项在进行发行版跨版本升级的时候会用到。 gpgcheck=1 #有1和0两个选择，分别代表是否是否进行gpg校验。这个选项如果设置在[main]部分，则对每个repository都有效。默认值为0. plugins = 1 //是否启用插件，默认1为允许，0表示不允许 修改完yum.conf文件，使用下列命令进行配置。 yum clean all 清楚缓存 yum makecache 更新生成缓存 使用yum安装软件1. 用YUM安装删除软件 注：Yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 在系统中添加删除软件是常事，yum同样可以胜任这一任务，只要软件是rpm安装的。安装的命令是，yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断。删除的命令是，yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。 用YUM安装软件包命令： yum install xxx 用YUM删除软件包命令： yum remove xxx 2. 用YUM查询软件信息 我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。你可以用 yum search keyword这样的命令来进行搜索，比如我们要则安装一个Instant Messenger,但又不知到底有哪些，这时不妨用yum search messenger这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到gaim,kopete等等，并从中选择。有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yum info packagename这个指令来获取信息。 使用YUM查找软件包命令： yum search 列出所有可安装的软件包命令： yum list 列出所有可更新的软件包命令： yum list updates 列出所有已安装的软件包命令： yum list installed 列出所有已安装但不在 Yum Repository 内的软件包命令： yum list extras 列出所指定的软件包命令： yum list Ubuntu中的高级包管理方法apt-get apt-get的一大好处是极大地减小了所谓依赖关系恶梦的发生几率(dependency hell)，即使是陷入了dependency hell,apt-get也提供了很好的援助手段。通常 apt-get 都和网上的压缩包一起出没，从互联网上下载或是安装。 apt方式安装： 打开一个终端，su -成root用户； apt-cache search soft 注：soft是您要找的软件的名称或相关信息 假如2中找到了软件soft.version，则用apt-get install soft.version命令安装软件 注：只要您能够上网，只需要用apt-cache search查找软件，用apt-get install软件 常用的APT命令参数 apt-cache search package 搜索包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package 安装包 sudo apt-get install package - - reinstall 重新安装包 sudo apt-get -f install 修复安装&quot;-f = --fix-missing&quot; sudo apt-get remove package 删除包 sudo apt-get remove package - - purge 删除包，包括删除配置文件等 sudo apt-get update 更新源sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-get dselect-upgrade 使用 dselect 升级 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 其他软件安装技巧1. linux下安装软件，如何知道软件安装位置 注：一般的软件的默认安装目录在/usr/local或者/opt里，可以到那里去找找. 指令名称：whereis 功能介绍：在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。 语法格式：whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…] 常用参数说明： -b 只查找二进制文件。 -B &lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。 -m 只查找说明文件。 -M &lt;目录&gt; 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。 -S &lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。 应用：#whereis 软件名 –&gt;查看软件安装路径 #which 软件名 –&gt;软件软件的运行路径 2. 通过rpm包管理器安装的软件： rpm包 可以用命令： #rpm –ql 包名 如 rpm -ql gcc 来查看gcc的文件都安装到哪里去了 #rpm -qa | grep 包名 来查看有没有安装这个包 ， #rpm -qa 查看全部已经安装的包名 deb包 可以用命令： #dpkg -L 包名 查看如 dpkg -L gcc 来查看gcc的文件。 #dpkg -l | grep 包名 来查看有没有安装某个包 ， # dpkg -l 是查看全部包的 其他更多软件安装方法技巧 参考[http://blog.chinaunix.net/uid-28769209-id-4257451.html]:http://blog.chinaunix.net/uid-28769209-id-4257451.html]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机延时函数简单分析]]></title>
    <url>%2Fpost%2F3878.html</url>
    <content type="text"><![CDATA[初识延时程序123456void delay(unsigned int xms)&#123; unsigned int i,j; for(i=xms;i&gt;0;i--) for(j=112;j&gt;0;j--);&#125; 使用此函数可以达到我们想要的延时，使二极管发生闪烁。这也是我刚学单片机的小白，遇到的第一个问题。为什么要用延时，难道仅仅是为了闪烁，它还有啥作用；当我们调用delay(500)时，它到底延时了多长时间。。。。 由于是自学所以只能靠自己了，通过查阅参考书和在网上搜索，自己也算理解一点。现在就将自己理解的记录一下，就当做笔记了 术语解释 振荡周期：也称时钟周期，是指为单片机提供时钟脉冲信号的振荡源的周期，两个相邻同方向峰值之间的时间,一个时钟周期 ＝晶振的倒数。。 状态周期：每个状态周期为时钟周期的2倍，是振荡周期经二分频后得到的。 机器周期：指单片机完成一个基本操作所花费的时间，一般使用微秒来计量单片机的运行速度，12Mhz的频率，其周期为1/12乘10的-6方s,那么1个机器周期就是它的12倍，即1us。51 单片机的一个机器周期包括12个时钟振荡周期，也就是说如果51 单片机采用12MHz 晶振，那么执行一个机器周期就只需要1μs；如果采用的是6MHz 的晶振，那么执行一个机器周期就需要2 μs。 指令周期：指单片机执行一条指令所需要的时间，一般利用单片机的机器周期来计量指令周期。在51 单片机里有单周期指令（执行这条指令只需一个机器周期），双周期指令（执行这条指令只需要两个机器周期），四周期指令（执行这条指令需要四个机器周期）。除了乘、除两条指令是四周期指令，其余均为单周期或双周期指令。也就是说，如果51 单片机采用的是12MHz 晶振，那么它执行一条指令一般只需1~2 微秒的时间；如果采用的是6MH 晶振，执行一条指令一般就需2~4 微秒的时间。 MCS-51单片机的一个机器周期=6个状态周期=12个时钟周期 为什么要用延时 时序是描述对象之间发送消息的时间顺序显示多个对象之间的动态协作，这样就需要等待，等待就可以通过延时子程序实现。 为了单纯的等待，比如交通信号灯的控制，红灯绿灯黄灯都有时间控制，亮的长短就要由延时程序控制，或者CPU速度快于外设速度时，就需要用延时程序做等待！ 为了某些时序逻辑器件的时序要求。 延时的具体实现方法 在单片机编程里面并没有真正的延时指令，从上面的概念中我们知道单片机每执行一条指令都需要一定的时间，所以要达到延时的效果，只须让单片机不断地执行没有具体实际意义的指令，从而达到了延时。 汇编语言中基本的延时语句 数据传送指令 MOV数据传送指令功能是将数据从一个地方复制、拷贝到另一个地方。 MOV R7，#80H ；将数据80H 送到寄存器R7，这时寄存器R7里面存放着80H，就单这条指令而言并没有任何实际意义，而执行该指令则需要一个机器周期。 空操作指令 NOP空操作指令功能只是让单片机执行没有意义的操作，消耗一个机器周期。 循环转移指令 DJNZ循环转移指令功能是将第一个数进行减1 并判断是否为0，不为0 则转移到指定地点；为0 则往下执行。 DJNZ R7，KK ； 将寄存器R7 的内容减1 并判断寄存器R7 里的内容减完1 后是否为0如果不为0 则转移到地址标号为KK 的地方；如果为0 则执行下一条指令。这条指令需要2个机器周期。利用以上三条指令的组合就可以比较精确地编写出所需要的延时程序。 C51下的延时语句 使用空的for循环，可以多层嵌套，比如上面给出的例子 使用while()语句 注意：在C51中定义循环变量时，尽量采用无符号整型；for，while循环变量体变量采用减减方法。 延时程序时间的计算汇编指令的时间计算1234 MOV R6， #20D1：MOV R7， #248 DNJZ R7，$ //循环248次，共用248X2us, DNJZ R6，D1 我觉得应该从最后往前算，在MOR R7，#248执行一次前提下，用时1X2us,然后循环减248，用时248X2us,故共用时[2+2X248]us。然而又由于DNJZ R6，D1，上面的过程又循环20次，故上面的循环最终用时20X[2+2X248]us。接着注意到单纯DNJZ R6，D1会用时20X2=40us最后注意过执行唯一一次的 MOV R6，#20会用时1X2us。 C51延时函数的计算 500ms延时子程序程序:.(晶振12MHz,一个机器周期1us.一条指令周期2us) 1234567void delay500ms(void)&#123; unsigned char i,j,k; for(i=15;i&gt;0;i--) for(j=202;j&gt;0;j--) for(k=81;k&gt;0;k--);&#125; 计算分析:程序共有三层循环 一层循环n:R52 = 812 = 162us DJNZ 2us 二层循环m:R6(n+3) = 202165 = 33330us DJNZ 2us + R5赋值 1us = 3us 三层循环: R7(m+3) = 1533333 = 499995us DJNZ 2us + R6赋值 1us = 3us 循环外: 5us [子程序调用 2us + 子程序返回 2us + R7赋值 1us = 5us ] 延时总时间 = 三层循环 + 循环外 = 499995+5 = 500 000us =500ms 所以开头给出来得延时函数delay(500)时间，循环外+ 两层循环 = 5+1122500us = 56005us = 56.005ms =0.056005s 1s延时子程序 : 12345678void delay1s(void)&#123; unsigned char h,i,j,k; for(h=5;h&gt;0;h--) for(i=4;i&gt;0;i--) for(j=116;j&gt;0;j--) for(k=214;k&gt;0;k--);&#125; 时间计算 time = 221411645 + 5 = 992 965us = 0.992965s ≈ 1s 51单片机数据类型大小测试12345678910111213141516171819#include&lt;reg52.h&gt;sbit led1=P1^0;sbit led2=P1^1;sbit led4=P1^3;void main()&#123; int char_size, int_size; char_size = sizeof(char); int_size = sizeof(int); if(char_size==1) //测试char占一个字节 led1 = 0; if(int_size==2) //测试int 占两个字节 led2 = 0; while(1);&#125;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>硬件设计</tag>
        <tag>51</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware文件共享]]></title>
    <url>%2Fpost%2F36698.html</url>
    <content type="text"><![CDATA[看这破网速实在是蛋疼，200多兆的更新文件，下载了半个小时。闲来无事就随便写写，这次不知道咋了。一个VMware tool安装完居然找不到共享文件夹。网上找半天解决办法，照着来一遍吧，最简单可是设置成功后，只要系统一挂起或是重启，好像共享有关闭了。写到这突然觉得是不是，重启后VMware共享服务给关了，没有办法自动重启服务。现在想试试可已经重新安装了一遍VMware tool，将open-vm-dkms工具更新后，看能不能重新挂载hgfs文件。 呵呵，这就是现在蛋疼的地方，第一次使用apt-get upgarde 软件名 更新软件，以为是只更新单独软件，谁知道更新了423个软件包。这就是我们小白的痛苦吧，也不敢中断怕软件更新不完整，开个玩笑，呵呵。软件更新是先下载，在进行更新软件操作，我现在正在下载。这个月流量刚开始这点流量不是事。只是希望更新完后，共享文件可以顺利挂载mount -t vmhgfs .host:/ /mnt/hgfs 一个回车OK。vmhgfs表示文件系统类型，VMware虚拟操作系统与宿主机之间共享的特定文件类型。根据monut命令的格式，.host:/ 应该表示需要挂载的文件，没加共享文件名，表示VMware共享的所有宿主机的文件。在虚拟操作系统ubuntu 12.10 下可以使用vmware-hgfsclient命令查看宿主机共享文件名。 终于快下载完了，边写边搜边想，感觉还是不能显示共享文件夹，安装完了试试在说吧。 文件共享终于成功了，还是网络的力量大啊呵呵呵。]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式(Regular Expression) [^,*]与[^,]*区别]]></title>
    <url>%2Fpost%2F10189.html</url>
    <content type="text"><![CDATA[正则表达式(Regular Expression) [^,]与[^,]区别： $ sed ‘s/[^,]*/{&amp;}/‘ example.txt $ sed ‘s/[^,*]/{&amp;}/‘ example.txt 使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu*t将匹配字符u一次或多次。 只匹配[ ] 内字符。可以是一个单字符，也可以是字符序列 []在指定模式匹配的范围或限制方面很有用。结合使用*与[ ]更是有益， 例如:[ A - Z a - Z ] 将匹配所有单词 注意* :^符号的使用，当直接用在第一个括号里，意指否定或不匹配括号里内容。 如:[^a-zA-Z]匹配任一非字母型字符，而[ ^ 0 - 9 ]匹配任一非数字型字符。 $ sed ‘s/[^,*]/{&amp;}/‘ example.txt 表示把开头不是一个或多个“，”时的第一个字符加上{} 只对第一个字符“1”加上了{}，主要原因是[ ]内的字符一次只匹配一个。 表示把不是“，”之前的所有字符串，加上{} 截取字符串 原文本文件 example.txt102,John Smith,IT Manager103,Raj Reddy,Sysadmin104,Anand Ram,Developer105,Jane Miller,Sales Manager,123,lin,feng,,,sss 截取非数字的所有字符 –失败 $ sed ‘s/[^0-9]*/ /‘ example.txt 失败原因：[^0-9]表示匹配一非数字型字符，而[^0-9]*表示一或多个非数字型字符，但只要有一个字符匹配成立，就进行替换。 截取非数字的所有字符 –成功 $ sed ‘s/[^0-9].*/ /‘ example.txt]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getch、getche、getchar的区别和缓冲区的概念]]></title>
    <url>%2Fpost%2F26893.html</url>
    <content type="text"><![CDATA[输入输出缓冲区的概念（C++用的多一些） 转载于：http://blog.csdn.net/cxyol/article/details/628324 我想以一个例子说明，比如我想把一篇文章以字符序列的方式输出到计算机显示器屏幕上，那么我的程序内存作为数据源而显示器驱动程序作为数据目标，如果数据源直接对数据目标发送数据的话。数据目标获得第一个字符，便将它显示。然后从端口读取下一个字符，可是这时就不能保证数据源向端口发送的恰好是第二个字符（也许是第三个，而第二个已经在数据目标显示时发送过了）。这样的话就不能保证输出的数据能完整的被数据目标所接受并处理。 为了解决这个问题，我们需要在数据源与数据目标中间放置一个保存完整数据内容的区域，那就是 “缓冲区”。这样的话， 数据源可以不考虑数据目标正在处理哪部分数据，只要把数据输出到缓冲区就可以了，数据目标也可以不考虑数据源的发送频率，只是从缓冲区中依次取出下一个数据。从而保证了数据发送的完整性，同时也提高了程序的效率。 当然getch(),getche()没有用到缓冲区。 几个函数的区别getch() 首先不要忘了，要用getch()必须引入头文件conio.h，以前学C语言的时候，我们总喜欢用在程序的末尾加上它，利用它来实现程序运行完了暂停不退出的效果。如果不加这句话，在TC2.0的环境中我们用Ctrl+F9编译并运行后，程序一运行完了就退回到TC环境中，我们根本来不及看到结果，这时要看结果，我们就要按Alt+F5回到DOS环境中去看结果，这很麻烦。而如果在程序的结尾加上一行getch();语句，我们就可以省掉会DOS看结果这个步骤，因为程序运行完了并不退出，而是在程序最后把屏幕停住了，按任意键才退回到TC环境中去。 那我们来看看getch()到底起的什么作用，getch()实际是一个输入命令，作用是从键盘接收一个字符，而且并不把这个字符显示出来，就是说，你按了一个键后它并不在屏幕上显示你按的什么，而继续运行后面的代码，所以我们在C++中可以用它来实现“按任意键继续”的效果，即程序中遇到getch();这行语句，它就会把程序暂停下来，等你按任意键，它接收了这个字符键后再继续执行后面的代码。 你也许会问，为什么我们在C++中就没有在程序的末尾加上getch()，解释是，软件总是不断更新的，不好的地方当然要进行改正，getch()加在程序末尾，它又不赋值给任何变量，所以它在这个地方完全是垃圾代码，与程序无关。C++中考虑到这一点，于是在每次程序运行完了并不退出，而是自动把屏幕停下来，并显示“press any key…”叫你按任意键退出，这就好比C++在它的环境中运行程序，在程序的末尾自动加上了一行getch();语句，并且在这行语句前还添加了一行输出语句cout&lt;&lt;”press any key…”;来提示你程序结束了，按任意键继续。 实际上我们编译好的程序在程序结束了本身是不会停下来的，我们可以在编译产生的Debug目录中找到这个编译好的应用程序（扩展名exe），在文件夹中双击运行它，你会发现屏幕闪了一下MS-DOS窗口就关闭了，因为程序运行完就自动退出了，回到了windows环境，当然，如果我们在DOS环境中运行这个程序，我们就可以直接在看到DOS屏幕上看到程序运行结果，因为程序运行完后并不清屏。但是，visual stdio.net2003有返回到了tc那样的情况，你必需要有个getch()才行。 getche() getche()和getch()很相似，它也需要引入头文件conio.h，那它们之间的区别又在哪里呢？不同之处就在于getch()无返回显示，getche()有返回显示。就这么一点看看下面的例子： #include&lt;stdio.h&gt; #include&lt;conio.h&gt; void main() { char ch; for(int i=0;i&lt;5;i++) { ch=getch(); printf(&quot;%c&quot;,ch); } } 首先这是个连续5次的循环来实现5次停顿，等待我们输入，我们编译并运行这个程序，假设我们分别输入abcde，屏幕上显示的结果是abcde，这个abcde并不是在ch=getch();中输出的，我们把printf(“%c”,ch);这行语句去掉，就会发现我们按5次任意键程序就结束了，但屏幕上什么都没有显示。 然后我们在把代码中的getch()换成getche()看看有什么不同，我们还是分别输入abcde，这时屏幕上显示的结果是aabbccddee，我们把printf(“%c”,ch);这行语句再去掉看看，显示的结果就是abcde了，说明程序在执行ch=getche();这条语句的时候就把我们输入的键返回显示在屏幕上，有无回显就是它们的唯一区别。 有人会说，既然是C的函数库中的，那么就应该淘汰了，我们还研究它，还用它干嘛？但是我发现还是有用着它的地方，否则我也不会在这里说这么多来耽误大家的时间。我就举个例子吧，程序如下： #include&lt;stdio.h&gt; #include&lt;conio.h&gt; void main() { char ch=&apos;*&apos;; while(ch==&apos;*&apos;) { printf(&quot;\n按 * 继续循环，按其他键退出！&quot;); ch=getch(); } printf(&quot;\n退出程序！&quot;); } 我们可以在这个循环体中添加我们想要的功能，程序中按*继续循环，其他任意键退出，而且利用getch()无回显的特性，我们不管按什么，都不会在屏幕上留下痕迹，使我们的界面达到美观效果，如果还有更好的办法实现这个功能。例子： void main() { char c, ch; c=getch(); /*从键盘上读入一个字符不回显送给字符变量c*/ putchar(c); /*输出该字符*/ ch=getche(); /*从键盘上带回显的读入一个字符送给字符变量ch*/ putchar(ch); printf(&quot;/n/n&quot;); } 值得注意的是前面两个函数都是从键盘读入数据！ getchar() 还有getchar是很值得研究的：getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了。而getch()和getche()是conio.h中的库函数，它的作用是从键盘接收字符。getchar带有显示。 与前面两个函数的区别在于： getchar()函数等待输入直到按回车才结束（前提是缓冲区没有数据），回车前的所有输入字符都会逐个显示在屏幕上。但只有第一个字符作为函数的返回值。 #include&lt;stdio.h&gt; #include&lt;conio.h&gt; void main() { char c; c=getchar(); /*从键盘读入字符直到回车结束*/ //getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c putchar(c); /*显示输入的第一个字符*/ printf(&quot;\n\n&quot;); } 例四：呵呵，这个程序你运行一下，相信你又会有疑问了。这个就是从缓冲区中读取了例子。第一次getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。 #include&lt;stdio.h&gt; #include&lt;conio.h&gt; void main() { char c; while ((c=getchar())!=&apos;\n&apos;) /*每个getchar()依次读入一个字符*/ printf(&quot;%c&quot;,c); /*按照原样输出*/ printf(&quot;\n\n&quot;); } 程序运行时，首先停下来，等你输入一串字符串，输入完毕后，它把你输入的整个字符串都输出来了，咦，你不是说getchar()只返回第一个字符么，这里怎么？ 因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，这里开闸动作就相当于调用一次getchar()。我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，我们调用一次getchar()就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，直到不满足循环条件退出为止。 例子中循环条件里的’\n’实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，而getchar()函数就是等待输入（或缓冲区中的数据）直到按回车才结束，所以实现了整个字符串的输出。当然，我们也可以把循环条件改一下，比如while ((c=getchar())!=’a’)，什么意思呢，意思就是遇到字符’a’就停止循环，当然意思是如果你输入“12345a213123\n”那么只会输出到a，结果是12345a。 再次注意：用getchar()它是从“流”中间去读取，所以第一个getchar()接受的是刚刚中断的流队列中即将出列的第一个字符（不限于回车符，上面举过例子了），如果流队列不为空，执行getchar()就继续放水，直到把回车符也放空为止，空了之后再在执行getchar()就停下等待你的输入了；我们用getch()为什么每次都是等待用户的输入呢？因为getch()是从键盘接收，即时的接收，并不是从stdin流中去读取数据。 补充：按键盘上的回车产生了2个字符:回车符(‘\r’)和换行符(‘\n’)。回车符’\r’(CR:carriage return:倒车）使光标回到这行的首部，换行符(‘\n’)(new line)然后再换行。 所以当输入字符’w’,并按下回车键以后。首先得到回车符。那个getchar函数结束了。 但是还存在一个换行符。所以如果用getchar()来做判断的时候。最好再写一次getchar()清除缓冲区的’/n’. 如何清空输入缓冲区的内容？ 如果我想让getchar()每次都能够等待用户输入的话就要清空缓冲区，下面就介绍方法（不同平台） C标准规定 fflush()函数是用来刷新输出（stdout）缓存的。对于输入（stdin），它是没有定义的。但是有些编译器也定义了 fflush( stdin )的实现，比如微软的VC。其它编译器是否也定义了 fflush( stdin )的实现应当查找它的手册。GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓存。 对于没有定义 fflush( stdin )的编译器，可以使用 fgets()函数来代替它（比用 getchar()、scanf()等函数通用性好）。可以这样忽略输入流中留下的回车等其它输入，从而使下一次的输入总保持一个“干净”的状态。（这个是任何平台下都可以的） // ... char sbuf[1024]; // ... fgets( sbuf, 1024, stdin ); // ... 在windows 的vc下面就可以这样了 for(int i=0;i&lt;10;++i) { char ch=getchar(); fflush(stdin); //每次都会有等待状态了 } 运用实例//从键盘输入一些字符，逐个把它们送到磁盘上去，直到输入一个&quot;#&quot;为止 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void main() { FILE *fp; char ch,filename[10]; scanf(&quot;%s&quot;,filename); if((fp=fopen(filename,&apos;w&apos;))==NULL) { printf(&quot;cannnot open file\n&quot;); exit(0); /* 终止程序 */ } ch=getchar(); /* 此语句用来接收在执行scanf语句时最后输入的回车符 */ ch=getchar( ); /* 接收输入的第一个字符 */ while(ch!=&apos;#&apos;) { fputc(ch,fp); putchar(ch); ch=getchar(); } putchar(10); /*向屏幕输出一个换行符 */ fclose(fp); } 运行情况如下： file1.c↙ (输入磁盘文件名)computer and c#↙ (输入一个字符串)computer and c (输出一个字符串)]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>输入输出</tag>
        <tag>getch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态分配二维数组]]></title>
    <url>%2Fpost%2F42179.html</url>
    <content type="text"><![CDATA[动态创建 动态数组是指在声明时没有确定数组大小的数组；当要用它时，C语言中用malloc语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。 有时根据题意需得根据输入的二维数来动态的创建二维数组，那么此时就不能想以前一样直接定义多少行多少列了。因为不知道行列多少，假如设定太大浪费空间，申请太小完成不了程序的数据存储。因此需要合理的开辟二维空间。 动态数组与静态数组的对比 对于静态数组，其创建非常方便，使用完也无需释放，要引用也简单，但是创建后无法改变其大小是其致命弱点！对于动态数组，其创建麻烦，使用完必须由程序员自己释放，否则严重会引起内存泄露。但其使用非常灵活，能根据程序需要动态分配大小。 遵循原则 申请的时候从外层往里层，逐层申请；释放的时候从里层往外层，逐层释放。 构建所需指针 对于构建一维动态数组，需要一维指针；对于二维，则需要一维，二维指针；三维需要一，二，三维指针；依此类推。 以下的两种方法都可以建立动态的二维空间数组。 方法一： 使用指针动态分配 int i,j; int r,c; int **a; //创建二维指针来指向数组 scanf(&quot;%d%d&quot;,&amp;r,&amp;c); a = (int **) malloc(sizeof(int *) * r);//注意申请的指针格式 for (j=0;j&lt;r;j++){ a[j] = (int *) malloc(sizeof(int) * c); …… …… } 释放为： for (j=0;j&lt;r;j++) free(a[j]);//先释放一维指针 free(a);//最后释放我二维指针 方法二： 建立链表来存放二维数组。 typedef struct arr { int *array; }arr; main() { arr *array1; int rowx,rowy; int i,j,k=0; scanf(&quot;%d %d&quot;,&amp;rowx,&amp;rowy); array1=(arr *)malloc(sizeof(arr)*rowx);//创建链表数组 for(i=0;i&lt;rowx;i++) //再在每一个链表中创建一维数组，这样整体就构成二维数组 array1[i].array=(int *)malloc(sizeof(int)*rowy); …… …… 释放同上： for (j=0;j&lt;rowx;j++) free(array1[j].array); free(array); ｝ 示例#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main() { int n1,n2,n3; int ***array; int i,j,k; puts(&quot;输入一维长度:&quot;); scanf(&quot;%d&quot;,&amp;n1); puts(&quot;输入二维长度:&quot;); scanf(&quot;%d&quot;,&amp;n2); puts(&quot;输入三维长度:&quot;); scanf(&quot;%d&quot;,&amp;n3); array=(int***)malloc(n1*sizeof(int**));//第一维 for(i=0; i&lt;n1; i++) { array[i]=(int**)malloc(n2*sizeof(int*)); //第二维 for(j=0;j&lt;n2;j++) { array[i][j]=(int*)malloc(n3*sizeof(int)); //第三维 for(k=0;k&lt;n3;k++) { array[i][j][k]=i+j+k+1; printf(&quot;%d\t&quot;,array[i][j][k]); } puts(&quot;&quot;); } puts(&quot;&quot;); } for(i=0;i&lt;n1;i++) { for(j=0;j&lt;n2;j++) { free(array[i][j]);//释放第三维指针 } } for(i=0;i&lt;n1;i++) { free(array[i]);//释放第二维指针 } free(array);//释放第一维指针 return 0; }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对目前学习的简单回顾与规划]]></title>
    <url>%2Fpost%2F16809.html</url>
    <content type="text"><![CDATA[我的大学 现在回想起来，已经来到沈阳快有两年了。在他乡的我应该算是很幸运了，有亲人、朋友的照顾，谢谢你们。同时，遇到了我的室友，是我和他们一起度过这段时光。我们在一起二过，呵呵呵。也许在大学的每一个宿舍里都有一群，可以陪你一起二的人。他们使你的大学生活有了不一样的记忆。我真是太不争气了，想着想着就不知道，怎么写了。其实今天也没有想着，写一些琐碎的事。可是当写下了标题后，就想说点啥。可是又不知道从何写起，等以后准备好了以后再写一篇“我的大学”。 我的学习 在高中的时候，听别人说在大学就可以轻松了。可是，现在真的“轻松”了吗？想学点东西有时可真是累，不知道学的有没有用。可是当你知道自己学的东西，是自己以后的可能从业方向时，有一次一次的坚持不下来。而有开始反问自己，呵呵呵，想着想着我都感到自己好笑了。我记得好像有人说过“人本身就是一个矛盾体”，是不是我这个矛盾体太大了。 还记得我在大一的时候，由于没有电脑上网时间不多。对一些专业方面的事，不大了解，只是听老师给我们讲的一些。那时周末没事干就去图书馆找一些小说看，现在想来那时抱着一本喜欢的小说还是挺不错的。记得看过的第一本小说是《伏藏》作者现在已经忘了，主要是通过西藏活佛仓央嘉措和他的情人与情歌的故事，写出了活佛与他的大爱，“伏藏”伏下的不是对世人的愤怒，而是大爱。现在已经很久没看过小说了，去年快放寒假的时候，在当当网买了一本《失控》，最坑人的是它从北京邮到沈阳整整用了八天时间。那时听说这本书不错，所以就买了。现在有时间了看看，实在是太难消化了，里面存在着大量的专业知识。不过是非常不错的一本书。 说了这么半天废话，写点正事。给自己一个总结，一个方向 一直想学一些Linux方面的知识，想继续走下去。从以前的一些简单操作与日常管理和Gcc、makefile等，到现在想学习的shell、网络编程、与嵌入式Linux。 上学期学习完C++后，感觉对面向对象编程理解不深，想通过学习Qt编程加以巩固。 好好学习操作系统、微机原理，同时也希望这学期不在挂科 随想 上面的一点东西都是自己，的一些简单想法和愿望吧。已经很久没写过东西了，现在都不会写了。用了一个下午才写了这篇随笔吧，也只能说是随笔了。可是让人想了很多，这也许是写博客的一个好处吧，给自己一个思考的时间。我一直在思考学习技术层次的东西到底有用吗，在大学我们到底学的是什么。技术这个东西只要你肯花时间和精力，一定会学会成为高手。在自己以后的工作中可以独挡一面吧。我现在还是一名学生，没有工作过可能有些观点不正确。 技术的学习可能就像是学功夫（我也是个功夫迷，喜欢成龙、李连杰），学功夫只会一些招式，成不了大师。它们都有一些内功心法提高自己的修为与功夫。我想学技术也应该差不多，我们应该思考一个命令、一个算法、一种模式背后所存在的方法和哲学吧。今天无意中看到这篇文章感触很深。就像里面说的我们认识了解一个事物，应该深入到它所存在的价值和背后的哲学，而不是简单的理解一些表象的东西。这样才可以真正提高自身的能力。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github简单使用命令]]></title>
    <url>%2Fpost%2F56471.html</url>
    <content type="text"><![CDATA[基本工作流程 初始化（init）一个新的版本库，然后将目录中的所有文件纳入管理，Git把这个过程称为stage，最后以快照的方式提交所有文件。 $ git init $ git add . $ git commit -m ‘initial commit’ 创建一个新的分支（branch），将它检出（checkout）为活动分支，然后就可以编辑、载入和提交新的快照。 git branch featureA $ git checkout featureA (edit files) $ git add (files) $ git commit -m ‘add feature A’ 参与GitHub上的开源项目 先将托管在GitHub上的项目克隆（clone）到本地，做过更改之后推送回GitHub，然后发送一个pull请求，项目的维护者就会收到邮件通知。 在GitHub上fork（拷贝一份到你的版本库列表）项目： $ git clone https://github.com/my-user/project $ cd project (edit files) $ git add (files) $ git commit -m ‘Explain what I changed’ $ git push origin master]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github搭建博客的简单记录]]></title>
    <url>%2Fpost%2F32555.html</url>
    <content type="text"><![CDATA[起源 自从想写博客开始，就一直在找一个网站写一些自己的博文。把自己的在学习中的一些体验与心得记录下来。之前在一些网站上注册过一些博客，可是广告太多了，文本格式编排很麻烦。后来看到了搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门这篇文章，就一直想这搭建一个这样的博客，终于在这个寒假接近尾声之际搭建好了。其中遇到了各种麻烦真是一言难尽，在这里简单记录一些搭建过程。 博客搭建1. 安装jekyll进行博客站点的本地预览 jekyll的安装需要提前安装ruby $ sudo apt-get ruby1.9.1-dev $ gem install rdiscount $ gem install RedCloth 2. 安装Git将站点文件提交到Github 在本地站点库目录下 $ git init $ git add . $ git commit -m “first page” $ git remote add origin https://github.com/username/username.github.com.git $ git push -u origin master 3. 利用jekyll进行本地预览 终端执行： $ jekyll serve 然后在浏览器访问[http://0.0.0.0:4000/] 参考 本站主题是直接从Luyfclone下来的。 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门 使用Jekyll在GitHub上架设Blog 像黑客一样写博客——Jekyll入门 Markdown 语法说明 (简体中文版)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
